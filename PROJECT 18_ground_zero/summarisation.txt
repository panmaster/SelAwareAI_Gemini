## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero'

File: AwarnessLoop.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\AwarnessLoop.py)
Content (First 102 lines):
import google.generativeai as genai
from Tool_Manager import ToolManager
genai.configure(api_key='AIzaSyA60tGw6fZwQdamW8sm6pkgRh5W559kLJ0')

MODEL_NAME = 'gemini-1.5-flash-latest'

def initialize_awareness_loop_models():
    """Initializes models for each stage of the awareness loop."""

    tool_manager=ToolManager ()
    # Introspection Stage
    introspection_instruction = "Assess the system's current state and capabilities."
    introspection_tools =  tool_manager.get_tools_list_json(
        tool_type='introspection')
    introspection_model = genai.GenerativeModel(
        system_instruction=introspection_instruction,
        model_name=MODEL_NAME,
        tools=introspection_tools,
        safety_settings={"HARASSMENT": "block_none"}
    ).start_chat(history=[])

    # Action Planning Stage
    action_planning_instruction = "Based on the system's current state, propose actions to achieve the system's goals."
    action_planning_tools =  tool_manager.get_tools_list_json(
        tool_type='action_planning')
    action_planning_model = genai.GenerativeModel(
        system_instruction=action_planning_instruction,
        model_name=MODEL_NAME,
        tools=action_planning_tools,
        safety_settings={"HARASSMENT": "block_none"}
    ).start_chat(history=[])

    # Action Execution Stage
    action_execution_instruction = "Execute the planned actions and report the results."
    action_execution_tools =  tool_manager.get_tools_list_json(
        tool_type='action_execution')
    action_execution_model = genai.GenerativeModel(
        system_instruction=action_execution_instruction,
        model_name=MODEL_NAME,
        tools=action_execution_tools,
        safety_settings={"HARASSMENT": "block_none"}
    ).start_chat(history=[])

    # Results Evaluation Stage
    results_evaluation_instruction = "Evaluate the results of the executed actions against the system's goals."
    results_evaluation_tools =  tool_manager.get_tools_list_json(
        tool_type='results_evaluation')
    results_evaluation_model = genai.GenerativeModel(
        system_instruction=results_evaluation_instruction,
        model_name=MODEL_NAME,
        tools=results_evaluation_tools,
        safety_settings={"HARASSMENT": "block_none"}
    ).start_chat(history=[])

    # Knowledge Integration Stage
    knowledge_integration_instruction = "Integrate new insights and learnings into the system's knowledge base."
    knowledge_integration_tools =  tool_manager.get_tools_list_json(
        tool_type='knowledge_integration')
    knowledge_integration_model = genai.GenerativeModel(
        system_instruction=knowledge_integration_instruction,
        model_name=MODEL_NAME,
        tools=knowledge_integration_tools,
        safety_settings={"HARASSMENT": "block_none"}
    ).start_chat(history=[])

    return (
        introspection_model,
        action_planning_model,
        action_execution_model,
        results_evaluation_model,
        knowledge_integration_model
    )

def awareness_loop():
    """Main loop for the awareness loop."""

    introspection_model, action_planning_model, action_execution_model, results_evaluation_model, knowledge_integration_model = initialize_awareness_loop_models()

    while True:
        # 1. Introspection
        initial_prompt = "Describe the system's current state and capabilities."  # Example initial prompt
        introspection_response = introspection_model.send_message(initial_prompt)
        print("Introspection:", introspection_response)

        # 2. Action Planning
        action_planning_response = action_planning_model.send_message(introspection_response)
        print("Action Planning:", action_planning_response)

        # 3. Action Execution
        action_execution_response = action_execution_model.send_message(action_planning_response)
        print("Action Execution:", action_execution_response)

        # 4. Results Evaluation
        results_evaluation_response = results_evaluation_model.send_message(action_execution_response)
        print("Results Evaluation:", results_evaluation_response)

        # 5. Knowledge Integration
        knowledge_integration_response = knowledge_integration_model.send_message(results_evaluation_response)
        print("Knowledge Integration:", knowledge_integration_response)

if __name__ == "__main__":
    awareness_loop()

File: colors.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\colors.py)
Content (First 22 lines):
#colors.py
def COLORS():
    black = "\033[0;30m"
    red = "\033[0;31m"
    green = "\033[0;32m"
    yellow = "\033[0;33m"
    blue = "\033[0;34m"
    purple = "\033[0;35m"
    cyan = "\033[0;36m"
    white = "\033[0;37m"
    orange = "\033[0;91m"
    pink = "\033[0;95m"
    brown = "\033[0;33m"
    grey = "\033[0;90m"
    light_blue = "\033[0;94m"
    light_green = "\033[0;92m"
    light_cyan = "\033[0;96m"
    light_red = "\033[0;91m"
    light_magenta = "\033[0;95m"
    light_yellow = "\033[0;93m"
    light_white = "\033[0;37m"




Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\tools'

File: get_directory_structure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\tools\get_directory_structure.py)
Content (First 111 lines):
tool_type_for_Tool_Manager="action_execution"


import os


def get_directory_structure(directory=None, include_files=True, include_dirs=True, file_extension=None,
                            include_contents=False, specific_file=None, levels_up=0, verbose=False):
    if verbose:
        print("Entered get_directory_structure function with directory:", directory)

    # Set default directory
    if directory is None or directory == '/':
        directory = os.getcwd()
        if verbose:
            print(f"Directory is set to current working directory: {directory}")

    # Traverse up the directory hierarchy if levels_up is specified
    for _ in range(levels_up):
        directory = os.path.dirname(directory)
        if verbose:
            print(f"Traversed up one level, new directory: {directory}")

    # Safety check for the directory path
    if not os.path.exists(directory) or not os.path.isdir(directory):
        raise ValueError(f"The directory '{directory}' is not valid or does not exist.")

    directory_structure = {}

    def get_file_info(file_path):
        file_info = {
            'filename': os.path.basename(file_path),
            'size': os.path.getsize(file_path),
            'relative_path': os.path.relpath(file_path, directory),
            'full_path': file_path
        }
        if include_contents:
            try:
                with open(file_path, 'r') as file:
                    file_info['contents'] = file.read()
            except Exception as e:
                file_info['contents'] = f"Error reading file: {e}"
        return file_info

    if specific_file:
        if os.path.isfile(specific_file):
            if verbose:
                print(f"Getting details for specific file: {specific_file}")
            return get_file_info(specific_file)
        else:
            raise ValueError(f"The specified file '{specific_file}' does not exist.")

    for root, dirs, files in os.walk(directory):
        file_info = []
        if include_files:
            for file in files:
                if file_extension and not file.endswith(file_extension):
                    continue
                file_path = os.path.join(root, file)
                file_info.append(get_file_info(file_path))

        if include_dirs:
            directory_structure[os.path.relpath(root, directory)] = {
                'files': file_info,
                'folders': dirs
            }
        else:
            if file_info:
                directory_structure[os.path.relpath(root, directory)] = {
                    'files': file_info
                }

    if verbose:
        print("About to return the directory structure with", len(directory_structure), "folders.")

    return directory_structure


get_directory_structure_description_json = {
    'function_declarations': [
        {
            'name': 'get_directory_structure',
            'description': 'Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'directory': {'type_': 'STRING',
                                  'description': 'The path to the directory. Defaults to the current working directory if None or / is provided.'},
                    'include_files': {'type_': 'BOOLEAN',
                                      'description': 'Flag to include files in the output. Default is True.'},
                    'include_dirs': {'type_': 'BOOLEAN',
                                     'description': 'Flag to include directories in the output. Default is True.'},
                    'file_extension': {'type_': 'STRING',
                                       'description': 'Specific file extension to include. Default is None.'},
                    'include_contents': {'type_': 'BOOLEAN',
                                         'description': 'Flag to include the contents of files in the output. Default is False.'},
                    'specific_file': {'type_': 'STRING',
                                      'description': 'Path to a specific file to get its details. Default is None.'},
                    'levels_up': {'type_': 'INTEGER',
                                  'description': 'Number of levels to traverse up from the specified or current directory. Default is 0.'},
                    'verbose': {'type_': 'BOOLEAN', 'description': 'Flag for verbose logging. Default is False.'}
                },
                'required': ['directory']
            }
        }
    ]
}



get_directory_structure_description_short_str = "Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths. Includes options for filtering files, directories, file extensions, including file contents, and traversing up the directory hierarchy with a default to the current working directory."


File: save_to_file.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\tools\save_to_file.py)
Content (First 51 lines):
tool_type_for_Tool_Manager="action_execution"

import os
import json
from termcolor import colored  # Import the termcolor library

def save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None) -> dict:

    print(colored(f"Entering: save_to_file(...)", 'blue'))
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(colored(success_message, 'green'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(colored(error_message, 'red'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "failure", "message": error_message}


save_to_file_description_json = {
    'function_declarations': [
        {
            'name': 'save_to_file',
            'description': 'Saves content to a file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'content': {'type_': 'STRING'},
                    'file_name': {'type_': 'STRING', 'description': 'The name of the file. Defaults to "NoName".'},
                    'file_path': {'type_': 'STRING', 'description': 'The path to save the file. Defaults to the current working directory if not provided.'}
                },
                'required': ['content', 'file_name']
            }
        }
    ]
}

save_to_file_description_short_str="Searches memory frames within a specified folder based on provided criteria."

File: Tool_Manager.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\Tool_Manager.py)
Content (First 116 lines):
#Tool_Manager.py
import os
import importlib.util
import json
from typing import Dict, List, Callable, Any, Optional
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ToolManager:
    def __init__(self, tools_directory="tools"):
        print(f"\033[92mInitializing ToolManager with tools directory: {tools_directory}\033[0m")
        self.tools_directory = tools_directory
        self.tool_mapping: Dict[str, Callable] = {}  # Maps tool names to functions
        self.all_tools: List[Dict] = []  # Stores tool metadata
        self.categories: Dict[str, Dict] = {}  # Stores tools by category
        self.tool_types: Dict[str, str] = {}  # Maps tool names to their types
        self.valid_tool_types = {"action_execution"}
        self._load_tools()
        self.tool_usage: Dict[str, Dict[str, float]] = {}  # Track usage and success metrics



    def _load_tools(self) -> None:
        """Loads tools from the specified directory."""
        print(f"\033[92mScanning tools directory: {self.tools_directory}\033[0m")
        for category in os.listdir(self.tools_directory):
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                print(f"  \033[94mFound category: {category}\033[0m")
                self.categories[category] = {"tools": []}
                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        self._load_tool(category, filename[:-3])

    def _load_tool(self, category: str, tool_name: str) -> None:
        """Loads a single tool from a Python file."""
        try:
            module_name = f"{category}.{tool_name}"
            module_path = os.path.join(self.tools_directory, category, f"{tool_name}.py")
            spec = importlib.util.spec_from_file_location(module_name, module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            tool_function: Callable = getattr(module, tool_name, None)
            description_name = f"{tool_name}_description_json"
            tool_description: dict = getattr(module, description_name, None)
            tool_type: str = getattr(module, "tool_type_for_Tool_Manager", "all")

            if tool_function and tool_description:
                print(f"      \033[92m- Tool function '{tool_name}' loaded successfully\033[0m")
                self.tool_mapping[tool_name] = tool_function
                tool_info = {
                    "name": tool_name,
                    "description": tool_description,
                    "category": category,
                    "type": tool_type
                }
                self.all_tools.append(tool_info)
                self.tool_types[tool_name] = tool_type
                self.categories[category]["tools"].append(tool_name)  # Add the tool to the category
            else:
                print(f"      \033[91m- Warning: Could not load tool function or description for '{tool_name}'\033[0m")

        except Exception as e:
            print(f"      \033[91m- Error loading tool '{tool_name}': {e}\033[0m")

    def get_filtered_tools(self, tool_type: str = "all") -> List[Dict]:
        """Returns a filtered list of tool information dictionaries."""
        if tool_type not in self.valid_tool_types:
            logger.warning(f"Invalid tool type '{tool_type}'. Using 'all' instead.")
            tool_type = "all"

        return [tool for tool in self.all_tools if tool_type == "all" or tool["type"] == tool_type]

    def get_tools_list_json(self, tool_type: str = "all") -> str:
        """Returns a JSON string of tools for a given tool type."""
        filtered_tools = self.get_filtered_tools(tool_type)
        return json.dumps([tool["description"] for tool in filtered_tools], indent=2)

    def get_tools_structure(self) -> Dict:
        """Returns a dictionary representing the structure of loaded tools."""
        return {
            "categories": self.categories,
            "all_tools": self.all_tools,
            "tool_mapping": list(self.tool_mapping.keys()),  # Just the tool names
            "tool_types": self.tool_types
        }

    def print_tools_structure(self):
        """Prints the structure of the loaded tools."""
        tools_structure = self.get_tools_structure()
        print("\n\n\033[95m=========================================\033[0m")
        print(f"  \033[96mTool Manager Structure\033[0m")
        print("\033[95m=========================================\033[0m")
        print(f"\n\033[92mCategories:\033[0m")
        for category, info in tools_structure["categories"].items():
            print(f"  \033[94m- {category}:\033[0m")
            for tool_name in info["tools"]:
                print(f"    \033[96m- {tool_name}\033[0m")
        print(f"\n\n\033[92mTool Descriptions:\033[0m")
        for i, tool in enumerate(tools_structure["all_tools"], 1):
            print(f"  \033[93m{i}. {json.dumps(tool, indent=2)}\033[0m")
        return tools_structure



    def get_tool_by_name(self, tool_name: str) -> Optional[Callable]:
        """Returns the tool function based on its name."""
        return self.tool_mapping.get(tool_name)

    def get_tools_by_type(self, tool_type: str) -> List[str]:
        """Returns a list of tool names for a specific type."""
        return [tool["name"] for tool in self.all_tools if tool["type"] == tool_type]


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\__pycache__'

File: Tool_Manager.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\__pycache__\Tool_Manager.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 18_ground_zero\__pycache__\Tool_Manager.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

