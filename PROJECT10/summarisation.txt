## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT_10'

File: emotional_engine.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT_10\emotional_engine.py)
Content (First 58 lines):
import json
from typing import Dict, Any
import asyncio

class EmotionalEngine:
    def __init__(self):
        self.current_emotion = "neutral"
        self.emotion_intensity = 0.5
        self.emotion_history = []

    async def update(self, input_text: str, output_text: str):
        # Simple keyword-based emotion detection
        emotions = {
            "joy": ["happy", "excited", "delighted"],
            "sadness": ["sad", "depressed", "unhappy"],
            "anger": ["angry", "furious", "irritated"],
            "fear": ["scared", "afraid", "terrified"],
            "surprise        }

        detected_emotions = []
        for emotion, keywords in emotions.items():
            if any(keyword in input_text.lower() or keyword in output_text.lower() for keyword in keywords):
                detected_emotions.append(emotion)

        if detected_emotions:
            self.current_emotion = detected_emotions[0]  # Just use the first detected emotion for simplicity
            self.emotion_intensity = 0.8
        else:
            self.current_emotion = "neutral"
            self.emotion_intensity = 0.5

        self.emotion_history.append({
            "emotion": self.current            "intensity": self.emotion_intensity,
            "input": input_text,
            "output": output_text
        })

    async def get_emotional        return {
            "current_emotion": self.current_emotion,
            "intensity": self.emotion_intensity
        }

    async def save_emotional_state(self):
        with open("brain_settings/emotional_state.json", "w") as f:
            json.dump({                "current_emotion": self.current_emotion,
                "intensity": self.emotion_intensity,
                "history": self.emotion_history[-10:]  # Save last 10 emotional states
            }, f)

    async def load_emotional_state(self):
        try:
            with open("brain_settings/emotional_state.json", "r") as f:
                data = json.load(f)
                self.current_emotion = data["current_emotion"]
                self.emotion_intensity = data["intensity"]
                self.emotion_history = data["history"]
        except FileNotFoundError:
            pass  # No previous emotional state found,

File: main.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT_10\main.py)
Content (First 86 lines):
import os
import datetime
import json
import asyncio
import google.generativeai as genai
from typing import List, Dict, Any
import logging
from fastapi import FastAPI
from pydantic import BaseModel

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration
genai.configure(api_key='YOUR_API_KEY')
MEMORY_DIR = "memories"
STATE_FILE = "brain_settings/State_of_mind.json"
PROMPTS_FILE = "brain_settings/prompts.json"


class AdaptiveCognitiveArchitecture:
    def __init__(self):
        self.neural_core = NeuralCore()
        self.memory_lattice = MemoryLattice()
        self.emotional_engine = EmotionalEngine()
        self.attention_mechanism = AttentionMechanism()
        self.tool_manager = ToolManager()
        self.learning_subsystem = LearningSubsystem()
        self.ethical_governance = EthicalGovernance()
        self.introspection_engine = IntrospectionEngine()

    async def process_input(self, user_input: str):
        context = await self.memory_lattice.get_relevant_context(user_input)
        focused_input = self.attention_mechanism.focus(user_input, context)

        response = await self.neural_core.generate_response(focused_input)

        await self.emotional_engine.update(user_input, response)
        await self.memory_lattice.store(user_input, response)
        await self.learning_subsystem.learn(user_input, response)

        ethical_assessment = await self.ethical_governance.assess(response)
        if not ethical_assessment['is_ethical']:
            response = await self.neural_core.generate_response(
                f"Please rephrase the following response to adhere to ethical guidelines: {response}"
            )

        await self.introspection_engine.reflect(user_input, response)
        return response


class NeuralCore:
    def __init__(self):
        self.model = genai.GenerativeModel(model_name="gemini-1.5-pro")

    async def generate_response(self, input_text: str) -> str:
        try:
            response = await self.model.generate_content(input_text)
            return response.text
        except Exception as e:
            logger.error(f"Error generating response: {e}")
            return "I apologize, but I'm having trouble generating a response right now."


# FastAPI setup
app = FastAPI()


class Query(BaseModel):
    text: str


aca = AdaptiveCognitiveArchitecture()


@app.post("/interact")
async def interact(query: Query):
    response = await aca.process_input(query.text)
    return {"response": response}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)

File: memory_lattice.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT_10\memory_lattice.py)
Content (First 66 lines):
import json
import os
from datetime import datetime
from typing import List, Dict, Any
import asyncio


class MemoryLattice:
    def __init__(self):
        self.working_memory: List[Dict[str, Any]] = []
        self.episodic_memory: List[Dict[str, Any]] = []
        self.semantic_memory: Dict[str, Any] = {}
        self.memory_dir = "memories"
        os.makedirs(self.memory_dir, exist_ok=True)

    async def get_relevant_context(self, query: str) -> List[str]:
        # TODO: Implement more sophisticated relevance ranking
        recent_memories = self.working_memory[-5:]  # Get last 5 items
        return [f"{m['input']}: {m['output']}" for m in recent_memories]

    async def store(self, input_text: str, output_text: str):
        timestamp = datetime.now().isoformat()
        memory = {
            'timestamp': timestamp,
            'input': input_text,
            'output': output_text
        }

        # Store in working memory
        self.working_memory.append(memory)
        if len(self.working_memory) > 100:
            self.working_memory.pop(0)

        # Store in episodic memory
        self.episodic_memory.append(memory)

        # Save to file
        filename = f"{self.memory_dir}/memory_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(memory, f)

    async def update_semantic_memory(self, key: str, value: Any):
        self.semantic_memory[key] = value

        # Save semantic memory to file
        with open(f"{self.memory_dir}/semantic_memory.json", 'w') as f:
            json.dump(self.semantic_memory, f)

    async def load_memories(self):
        # Load episodic memories
        for filename in os.listdir(self.memory_dir):
            if filename.startswith("memory_") and filename.endswith(".json"):
                with open(os.path.join(self.memory_dir, filename), 'r') as f:
                    memory = json.load(f)
                    self.episodic_memory.append(memory)

        # Sort episodic memories by timestamp
        self.episodic_memory.sort(key=lambda x: x['timestamp'])

        # Load semantic memory
        if os.path.exists(f"{self.memory_dir}/semantic_memory.json"):
            with open(f"{self.memory_dir}/semantic_memory.json", 'r') as f:
                self.semantic_memory = json.load(f)

        # Initialize working memory with most recent episodic memories
        self.working_memory = self.episodic_memory[-100:]

