## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero'

File: AwarnessLoop.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\AwarnessLoop.py)
Content (First 427 lines):
import google.generativeai as genai
from Tool_Manager import ToolManager
import ast
import datetime
import hashlib
import time
import os
import json  # Import for JSON serialization
from tabulate import tabulate
from google.generativeai import protos
from ProjectManagerTables import ProjectManager  # Import the ProjectManager

MODEL_NAME = 'gemini-1.5-flash-latest'
genai.configure(api_key='AIzaSyDRG9wrwwpO5fCo8ALChdkTN4rOrueNbOE')  # Replace with your actual API key


# ANSI color codes
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


# Emojis for visual enhancement
TASK_EMOJI = "ðŸ“„"
SUBTASK_EMOJI = "   â””â”€ "
IN_PROGRESS_EMOJI = "â³"
COMPLETED_EMOJI = "âœ…"
FOCUS_EMOJI = "ðŸŽ¯"


# ================ Awareness Loop Class =========================

class AwarenessLoop:
    def __init__(self):
        self.tool_manager = ToolManager()
        self.models = self.initialize_models()
        self.counter = 0
        self.previous_feedback = ""
        self.session = self.create_session_with_sanitisation()
        self.project_manager = ProjectManager()  # Initialize the ProjectManager

    def create_session_with_sanitisation(self):
        now = datetime.datetime.now()
        date_time_str = now.strftime("%Y-%m-%d %H:%M:%S.%f")
        date_time_bytes = date_time_str.encode('utf-8')
        hash_object = hashlib.sha256(date_time_bytes)
        return hash_object.hexdigest()

    stages = [
        ('introspection', "Introspection, be concise", 'gemini-1.5-flash-latest', 'os'),
        ('action_planning',
         "Based on the system's current state, propose actions to achieve the system's goals. Be concise",
         'gemini-1.5-flash-latest', 'focus'),
        ('action_execution', "Execute the planned actions and report the results. You can call functions",
         'gemini-1.5-flash-latest', 'os'),
        (
            'results_evaluation', "Evaluate the results of the executed actions against the system's goals. Be concise",
            'gemini-1.5-flash-latest', 'focus'),
        ('knowledge_integration', "Integrate new insights and learnings into the system's knowledge base",
         'gemini-1.5-flash-latest', 'focus')
    ]

    def initialize_models(self):
        print("\n" + Colors.HEADER + "--- Initializing Models ---" + Colors.ENDC)

        models = {}

        for stage, instruction, model_name, tool_type in self.stages:
            tool_names = self.tool_manager.get_tools_by_type(tool_type)
            tools = [self.tool_manager.get_tool_by_name(tool_name) for tool_name in tool_names]

            print(f"\n{Colors.BLUE}Initializing Model: {model_name}{Colors.ENDC}")
            print(f"{Colors.CYAN}Stage: {stage}{Colors.ENDC}")
            print(f"{Colors.CYAN}Instruction: {instruction}{Colors.ENDC}")
            print(f"{Colors.CYAN}Tool Type: {tool_type}{Colors.ENDC}")
            print(f"{Colors.CYAN}Tools: {tools}{Colors.ENDC}")

            try:
                models[stage] = genai.GenerativeModel(
                    system_instruction=instruction,
                    model_name=model_name,
                    tools=tools,
                    safety_settings={"HARASSMENT": "block_none"}
                ).start_chat(history=[])

                # Check model status directly
                model_status = models[stage].status
                print(f"{Colors.GREEN}Model {model_name} initialized successfully! Status: {model_status}{Colors.ENDC}\n")

            except Exception as e:
                print(f"{Colors.FAIL}Error initializing model {model_name}: {e}{Colors.ENDC}\n")
                # Consider adding more detailed error handling, like logging the error

        print(Colors.HEADER + "--- Model Initialization Complete ---" + Colors.ENDC + "\n")
        return models

    def interpret_function_calls(self, response):
        print(f"\n{Colors.BLUE}--- Interpreter for function calls started ---{Colors.ENDC}")
        results = {}
        extracted_text = ""
        function_calls = []

        try:
            # Access candidates list directly
            for candidate in response.candidates:
                for part in candidate.content.parts:
                    if part.text:
                        extracted_text += part.text
                    if part.function_call:
                        function_call = part.function_call
                        function_calls.append({
                            'name': function_call.name,
                            'args': function_call.arguments  # Extract arguments as a string
                        })

            if function_calls:
                for call in function_calls:
                    function_name = call['name']
                    function_args_str = call['args']  # Get arguments as a string

                    print(f"{Colors.CYAN}Calling function: {function_name}{Colors.ENDC}")
                    print(f"{Colors.CYAN}Arguments (string): {function_args_str}{Colors.ENDC}")

                    try:
                        # Safely evaluate the arguments string into a dictionary
                        function_args = ast.literal_eval(function_args_str) if function_args_str else {}
                        print(f"{Colors.CYAN}Arguments (dict): {function_args}{Colors.ENDC}")

                        # Get the tool function
                        tool_function = self.tool_manager.get_tool_by_name(function_name)

                        if tool_function:
                            # Execute the tool function with the provided arguments
                            result = tool_function(**function_args)
                            results[function_name] = result
                            print(f"{Colors.GREEN}Result: {result}{Colors.ENDC}")
                        else:
                            print(f"{Colors.WARNING}Tool function '{function_name}' not found{Colors.ENDC}")

                    except (SyntaxError, ValueError) as e:
                        print(f"{Colors.FAIL}Error parsing function arguments: {e}{Colors.ENDC}")

            if not results:
                results = []
                print(f"{Colors.WARNING}No functions were called{Colors.ENDC}")

            print(f"\n{Colors.BLUE}--- Results returned from function calls ---{Colors.ENDC}")
            for func, res in results.items():
                print(f"{Colors.CYAN}{func}: {res}{Colors.ENDC}")

        except Exception as e:
            print(f"{Colors.FAIL}An error occurred while processing the response: {e}{Colors.ENDC}")
            return None, None, None

        extracted_text = extracted_text.strip() if extracted_text else ""
        function_calls = function_calls if function_calls else None

        print(f"\n{Colors.BLUE}Final Results:{Colors.ENDC}")
        print(f"{Colors.CYAN}Extracted Text: {extracted_text}{Colors.ENDC}")
        print(f"{Colors.CYAN}Function Calls: {function_calls}{Colors.ENDC}")

        print(f"{Colors.BLUE}--- Interpreter for function calls finished ---{Colors.ENDC}\n")
        return extracted_text, function_calls, results

    def extract_text_and_function_call(self, response):
        extracted_text = ""
        function_calls = []

        try:
            for candidate in response.candidates:
                for part in candidate.content.parts:
                    if part.text:
                        extracted_text += part.text
                    if part.function_call:
                        function_call = part.function_call
                        function_calls.append({
                            'name': function_call.name,
                            'args': function_call.arguments  # Get arguments as a string
                        })
        except Exception as e:
            print(f"{Colors.FAIL}An error occurred while processing the response: {e}{Colors.ENDC}")
            return "", []

        extracted_text = extracted_text.strip() if extracted_text else ""
        function_calls = function_calls if function_calls else []

        print(f"\n{Colors.BLUE}Final Results:{Colors.ENDC}")
        print(f"{Colors.CYAN}Extracted Text: {extracted_text}{Colors.ENDC}")
        print(f"{Colors.CYAN}Function Calls: {function_calls}{Colors.ENDC}")

        return extracted_text, function_calls

    def print_project_tables(self):
        """Prints the active and completed project tables."""

        self.print_projects(self.project_manager.active_projects, "Active Projects")
        self.print_projects(self.project_manager.completed_projects, "Completed Projects")

    def introspection(self, user_input=""):
        # Print project tables before introspection
        self.print_project_tables()

        # Format project data as JSON strings
        active_projects_str = json.dumps({
            project_name: project.to_dict()  # Use the to_dict method
            for project_name, project in self.project_manager.active_projects.items()
        }) if self.project_manager.active_projects is not None else "{}"

        completed_projects_str = json.dumps({
            project_name: project.to_dict()  # Use the to_dict method
            for project_name, project in self.project_manager.completed_projects.items()
        }) if self.project_manager.completed_projects is not None else "{}"

        # Create a single dictionary to represent all data
        all_data = {
            "active_projects": json.loads(active_projects_str),
            "completed_projects": json.loads(completed_projects_str),
            "previous_feedback": self.previous_feedback
        }

        introspection_prompt = f"{json.dumps(all_data, indent=2)}\nAll inputs, self introspection, you can use function calls"
        if user_input:
            introspection_prompt += user_input

        print(f"{Colors.CYAN}Introspection Prompt: {introspection_prompt}{Colors.ENDC}") # Print the prompt

        # Check if the model is ready
        print(f"Model status: {self.models['introspection'].status}")

        introspection_response = self.models['introspection'].send_message(introspection_prompt)
        print(f"{Colors.HEADER}INTROSPECTION{Colors.ENDC}")
        print(f"{Colors.CYAN}{introspection_response}{Colors.ENDC}")

        introspection_text, introspection_function_calls = self.extract_text_and_function_call(
            introspection_response)
        introspection_text = introspection_text or ""

        if introspection_function_calls:
            for call in introspection_function_calls:
                print(f"{Colors.CYAN}Function Call: {call}{Colors.ENDC}")
                introspection_text += f"Function Call: {call['name']}({call['args']})\n"

        introspection_results = self.interpret_function_calls(introspection_response)
        if introspection_results is not None:
            introspection_text += f"\nIntrospection function results: {str(introspection_results)}"

        return introspection_text

    def action_planning(self, introspection_result):
        action_planning_prompt = f"{introspection_result}\nBased on this introspection, develop a strategic plan of actions. Consider short-term and long-term goals, potential obstacles, and available resources."
        print(f"{Colors.CYAN}Action Planning Prompt: {action_planning_prompt}{Colors.ENDC}") # Print the prompt
        action_planning_response = self.models['action_planning'].send_message(action_planning_prompt)

        print(f"{Colors.HEADER}ACTION PLANNING{Colors.ENDC}")
        print(f"{Colors.CYAN}{action_planning_response}{Colors.ENDC}")

        action_planning_text, action_planning_function_calls = self.extract_text_and_function_call(
            action_planning_response)
        action_planning_text = action_planning_text or ""

        if action_planning_function_calls:
            for call in action_planning_function_calls:
                print(f"{Colors.CYAN}Function Call: {call}{Colors.ENDC}")
                action_planning_text += f"Function Call: {call['name']}({call['args']})\n"

        action_planning_results = self.interpret_function_calls(action_planning_response)
        if action_planning_results is not None:
            action_planning_text += f"\nAction planning function results: {str(action_planning_results)}"

        return action_planning_text

    def action_execution(self, action_plan):
        action_execution_prompt = f"{action_plan}\nExecute the planned actions. Provide a detailed report on the steps taken, any challenges encountered, and immediate outcomes."
        print(f"{Colors.CYAN}Action Execution Prompt: {action_execution_prompt}{Colors.ENDC}") # Print the prompt
        action_execution_response = self.models['action_execution'].send_message(action_execution_prompt)

        print(f"{Colors.HEADER}ACTION EXECUTION{Colors.ENDC}")
        print(f"{Colors.CYAN}{action_execution_response}{Colors.ENDC}")

        action_execution_text, action_execution_function_calls = self.extract_text_and_function_call(
            action_execution_response)
        action_execution_text = action_execution_text or ""

        if action_execution_function_calls:
            for call in action_execution_function_calls:
                print(f"{Colors.CYAN}Function Call: {call}{Colors.ENDC}")
                action_execution_text += f"Function Call: {call['name']}({call['args']})\n"

        # Example of interacting with ProjectManager
        if 'update_task' in action_execution_text:
            try:
                # Assuming action_plan contains instructions like
                # "update_task: {'project_name': 'My Project', 'task_guid': 'some_guid', 'completeness': 0.5}"
                update_info = ast.literal_eval(action_execution_text.split('update_task:')[1].strip())
                if self.project_manager.update_task(**update_info):
                    print("Task updated successfully!")
                else:
                    print("Task update failed.")
            except Exception as e:
                print(f"Error updating task: {e}")

        action_execution_results = self.interpret_function_calls(action_execution_response)
        if action_execution_results is not None:
            action_execution_text += f"\nAction execution function results: {str(action_execution_results)}"

        return action_execution_text

    def results_evaluation(self, execution_result):
        results_evaluation_prompt = f"{execution_result}\nCritically evaluate the results of the executed actions. Assess their effectiveness, identify any unexpected outcomes, and determine the degree of goal achievement."
        print(f"{Colors.CYAN}Results Evaluation Prompt: {results_evaluation_prompt}{Colors.ENDC}") # Print the prompt
        results_evaluation_response = self.models['results_evaluation'].send_message(
            results_evaluation_prompt)

        print(f"{Colors.HEADER}RESULTS EVALUATION{Colors.ENDC}")
        print(f"{Colors.CYAN}{results_evaluation_response}{Colors.ENDC}")

        results_evaluation_text, results_evaluation_function_calls = self.extract_text_and_function_call(
            results_evaluation_response)
        results_evaluation_text = results_evaluation_text or ""

        if results_evaluation_function_calls:
            for call in results_evaluation_function_calls:
                print(f"{Colors.CYAN}Function Call: {call}{Colors.ENDC}")
                results_evaluation_text += f"Function Call: {call['name']}({call['args']})\n"

        results_evaluation_results = self.interpret_function_calls(results_evaluation_response)
        if results_evaluation_results is not None:
            results_evaluation_text += f"\nResults evaluation function results: {str(results_evaluation_results)}"

        return results_evaluation_text

    def knowledge_integration(self, evaluation_result):
        knowledge_integration_prompt = f"{evaluation_result}\nIntegrate the new insights and learnings from this iteration into the system's knowledge base. Identify key takeaways, update existing knowledge, and suggest areas for future focus or improvement."
        print(f"{Colors.CYAN}Knowledge Integration Prompt: {knowledge_integration_prompt}{Colors.ENDC}") # Print the prompt
        knowledge_integration_response = self.models['knowledge_integration'].send_message(
            knowledge_integration_prompt)

        print(f"{Colors.HEADER}KNOWLEDGE INTEGRATION{Colors.ENDC}")
        print(f"{Colors.CYAN}{knowledge_integration_response}{Colors.ENDC}")

        knowledge_integration_text, knowledge_integration_function_calls = self.extract_text_and_function_call(
            knowledge_integration_response)
        knowledge_integration_text = knowledge_integration_text or ""

        if knowledge_integration_function_calls:
            for call in knowledge_integration_function_calls:
                print(f"{Colors.CYAN}Function Call: {call}{Colors.ENDC}")
                knowledge_integration_text += f"Function Call: {call['name']}({call['args']})\n"

        knowledge_integration_results = self.interpret_function_calls(knowledge_integration_response)
        if knowledge_integration_results is not None:
            knowledge_integration_text += f"\nKnowledge integration function results: {str(knowledge_integration_results)}"

        self.previous_feedback = knowledge_integration_text
        return knowledge_integration_text

    def print_projects(self, projects, title):
        if projects is not None:
            print(f"\n{Colors.HEADER}{title}:{Colors.ENDC}")
            for project_name, project in projects.items():
                print(f"\n{Colors.BOLD}--- {project_name} ---{Colors.ENDC}")
                print(tabulate(self.project_manager.get_project_data(project), headers=[
                    "Parent Task", "Task Name", "Goal", "Time Horizon",
                    "Focus", "Status", "Importance", "Difficulty",
                    "Completeness", "Cost", "Result"
                ]))

    def save_log(self, loop_data):
        filepath = f"conversationLogs/log_{self.counter}"
        os.makedirs(os.path.dirname(filepath), exist_ok=True)

        print(f"{Colors.GREEN}Saving log{Colors.ENDC}")
        with open(filepath, "a+") as f:
            f.write(f"----------------------Loop {self.counter}---------------------------\n")
            for stage, data in loop_data.items():
                f.write(f"{stage.upper()} PROMPT:\n{data['prompt']}\n")
                f.write(f"{stage.upper()} RESPONSE:\n{data['response']}\n****\n")

    def run_loop(self):
        while True:
            try:
                user_input = input(f"{Colors.BOLD}Admin input: {Colors.ENDC}") if self.counter % 3 == 0 else ""

                loop_data = {}

                introspection_result = self.introspection(user_input)
                loop_data['introspection'] = {'prompt': user_input, 'response': introspection_result}

                action_plan = self.action_planning(introspection_result)
                loop_data['action_planning'] = {'prompt': introspection_result, 'response': action_plan}

                execution_result = self.action_execution(action_plan)
                loop_data['action_execution'] = {'prompt': action_plan, 'response': execution_result}

                evaluation_result = self.results_evaluation(execution_result)
                loop_data['results_evaluation'] = {'prompt': execution_result, 'response': evaluation_result}

                knowledge_integration_result = self.knowledge_integration(evaluation_result)
                loop_data['knowledge_integration'] = {'prompt': evaluation_result,
                                                      'response': knowledge_integration_result}

                self.save_log(loop_data)
                self.counter += 1

                time.sleep(0.2)  # Small delay between iterations

            except Exception as e:
                print(f"{Colors.FAIL}Error occurred: {e}{Colors.ENDC}")
                # Optionally, you can add more detailed error handling or logging here


# ====================== Main Execution ===========================

def main():
    loop = AwarenessLoop()
    loop.run_loop()


if __name__ == "__main__":
    main()

File: colors.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\colors.py)
Content (First 21 lines):
COLORS = { 
    "black": "\033[0;30m",
    "red": "\033[0;31m",
    "green": "\033[0;32m",
    "yellow": "\033[0;33m",
    "blue": "\033[0;34m",
    "purple": "\033[0;35m",
    "cyan": "\033[0;36m",
    "white": "\033[0;37m",
    "orange": "\033[0;91m",
    "pink": "\033[0;95m",
    "brown": "\033[0;33m",
    "grey": "\033[0;90m",
    "light_blue": "\033[0;94m",
    "light_green": "\033[0;92m",
    "light_cyan": "\033[0;96m",
    "light_red": "\033[0;91m",
    "light_magenta": "\033[0;95m",
    "light_yellow": "\033[0;93m",
    "light_white": "\033[0;37m"
}



Subdirectory: conversationLogs
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\conversationLogs'


Subdirectory: FocusTable
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\FocusTable'

File: active_projects.json (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\FocusTable\active_projects.json)
Content (First 128 lines):
{
    "My Awesome Project": {
        "name": "My Awesome Project",
        "description": "",
        "tasks": [
            {
                "guid": "50bd66ce-2295-4ac3-a251-fd3ee39e848b",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "a063ab42-eb44-438f-a207-258079743ea5",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "e2d7fde4-93cd-4eef-b190-064699fbe1fe",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "94531f27-b9c5-48ec-b5ec-06cd4e1657f4",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "c73b8c2d-eca7-45ae-bc32-95e72c5eb3da",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "af81090d-bbb3-41ad-9351-a8c2a8dbbba2",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            },
            {
                "guid": "67b22489-46ab-4d5a-83d7-f3ff43da23f7",
                "name": "Task 1",
                "goal": "Finish something important",
                "description": null,
                "time_horizon": null,
                "focus_level": null,
                "current_focus": null,
                "status": null,
                "importance_level": null,
                "difficulty": null,
                "completeness": 1.0,
                "current_cost": 0.0,
                "result": null,
                "parent": null,
                "children": []
            }
        ],
        "completed": false
    }
}

File: ProjectManagerTables.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\ProjectManagerTables.py)
Content (First 237 lines):
import os
import json
from tabulate import tabulate
import uuid

# Emojis for visual enhancement
TASK_EMOJI = "ðŸ“„"
SUBTASK_EMOJI = "   â””â”€ "
IN_PROGRESS_EMOJI = "â³"
COMPLETED_EMOJI = "âœ…"
FOCUS_EMOJI = "ðŸŽ¯"


class Project:
    def __init__(self, name, description=""):
        self.name = name
        self.description = description
        self.tasks = {}
        self.completed = False

    def to_dict(self):
        return {
            "name": self.name,
            "description": self.description,
            "tasks": [self.task_to_dict(task) for task in self.tasks.values()],
            "completed": self.completed
        }

    def add_task(self, task):
        self.tasks[task.guid] = task

    def get_tasks(self):
        return list(self.tasks.values())

    def is_completed(self):
        return all(task.get_completeness() == 1.0 for task in self.tasks.values())

    def get_total_cost(self):
        return sum(task.get_total_cost() for task in self.tasks.values())

    def find_task(self, guid):
        task = self.tasks.get(guid)
        if task:
            return task
        for t in self.tasks.values():
            task = t.find_task(guid)
            if task:
                return task
        return None

    def task_to_dict(self, task):
        return {
            "guid": task.guid,
            "name": task.name,
            "goal": task.goal,
            "description": task.description,
            "time_horizon": task.time_horizon,
            "focus_level": task.focus_level,
            "current_focus": task.current_focus,
            "status": task.status,
            "importance_level": task.importance_level,
            "difficulty": task.difficulty,
            "completeness": task.completeness,
            "current_cost": task.current_cost,
            "result": task.result,
            "parent": task.parent.guid if task.parent else None,
            "children": [child.guid for child in task.children]
        }


class Task:
    def __init__(self, name, goal, description="", time_horizon="Short Term",
                 focus_level=3, current_focus=0, status="To Do",
                 importance_level=1, difficulty=1, completeness=0.0,
                 current_cost=0.0, result="", parent=None):
        self.guid = str(uuid.uuid4())
        self.name = name
        self.goal = goal
        self.description = description
        self.time_horizon = time_horizon
        self.focus_level = focus_level
        self.current_focus = current_focus
        self.status = status
        self.importance_level = importance_level
        self.difficulty = difficulty
        self.completeness = float(completeness) if completeness is not None else 0.0
        self.current_cost = float(current_cost) if current_cost is not None else 0.0
        self.result = result
        self.parent = parent
        self.children = []

    def get_current_cost(self):
        return self.current_cost if self.current_cost is not None else 0.0

    def get_completeness(self):
        return self.completeness if self.completeness is not None else 0.0

    def get_total_cost(self):
        return self.get_current_cost() + sum(child.get_total_cost() for child in self.children)

    def find_task(self, guid):
        if self.guid == guid:
            return self
        for child in self.children:
            found_task = child.find_task(guid)
            if found_task:
                return found_task
        return None

    def add_child(self, child):
        self.children.append(child)
        child.parent = self


class ProjectManager:
    def __init__(self):
        self.active_projects = self.load_projects_from_json('active_projects.json')
        self.completed_projects = self.load_projects_from_json('completed_projects.json')

    def load_projects_from_json(self, filename):
        folder_name = "FocusTable"
        file_path = os.path.join(folder_name, filename)
        projects = {}
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                data = json.load(f)
                for project_name, project_data in data.items():
                    project = Project(project_data["name"], project_data.get("description", ""))
                    projects[project_name] = project

                    task_objects = {}
                    for task_data in project_data.get("tasks", []):
                        task = Task(
                            task_data["name"],
                            task_data["goal"],
                            task_data.get("description", ""),
                            task_data.get("time_horizon", "Short Term"),
                            task_data.get("focus_level", 3),
                            task_data.get("current_focus", 0),
                            task_data.get("status", "To Do"),
                            task_data.get("importance_level", 1),
                            task_data.get("difficulty", 1),
                            task_data.get("completeness", 0.0),
                            task_data.get("current_cost", 0.0),
                            task_data.get("result", ""),
                        )
                        task_objects[task_data["guid"]] = task

                    for task_data in project_data.get("tasks", []):
                        task = task_objects[task_data["guid"]]
                        parent_guid = task_data.get("parent")
                        if parent_guid:
                            parent_task = task_objects.get(parent_guid)
                            if parent_task:
                                parent_task.add_child(task)
                        else:
                            project.add_task(task)

        return projects

    def save_projects_to_json(self, projects, filename):
        folder_name = "FocusTable"
        if not os.path.exists(folder_name):
            os.makedirs(folder_name)

        file_path = os.path.join(folder_name, filename)

        data_to_save = {
            project_name: self.project_to_dict(project)
            for project_name, project in projects.items()
        }

        with open(file_path, 'w') as f:
            json.dump(data_to_save, f, indent=4)

    def format_focus(self, current, target):
        return f"{FOCUS_EMOJI} {current}/{target}"

    def get_project_data(self, project):
        project_data = []
        for task in project.get_tasks():
            parent_name = f"{SUBTASK_EMOJI}{task.parent.name}" if task.parent else ""
            status_emoji = COMPLETED_EMOJI if task.get_completeness() == 1.0 else IN_PROGRESS_EMOJI
            project_data.append([
                parent_name,
                f"{TASK_EMOJI} {task.name}",
                task.goal,
                task.time_horizon,
                self.format_focus(task.current_focus, task.focus_level),
                f"{status_emoji} {task.status}",
                task.importance_level,
                task.difficulty,
                f"{task.get_completeness():.0%}",
                f"{task.get_current_cost():.2f}",
                task.result
            ])
            for child in task.children:
                status_emoji = COMPLETED_EMOJI if child.get_completeness() == 1.0 else IN_PROGRESS_EMOJI
                project_data.append([
                    f"{SUBTASK_EMOJI}{task.name}",
                    f"   {TASK_EMOJI} {child.name}",
                    child.goal,
                    child.time_horizon,
                    self.format_focus(child.current_focus, child.focus_level),
                    f"{status_emoji} {child.status}",
                    child.importance_level,
                    child.difficulty,
                    f"{child.get_completeness():.0%}",
                    f"{child.get_current_cost():.2f}",
                    child.result
                ])
        return project_data

    def project_to_dict(self, project):
        return {
            "name": project.name,
            "description": project.description,
            "tasks": [self.task_to_dict(task) for task in project.get_tasks()],
            "completed": project.completed
        }

    def update_task(self, project_name, task_guid, **kwargs):
        """Updates a task's attributes in a project."""
        project = self.active_projects.get(project_name)
        if project:
            task = project.find_task(task_guid)
            if task:
                for key, value in kwargs.items():
                    if hasattr(task, key):
                        setattr(task, key, value)
                self.save_projects_to_json(self.active_projects, 'active_projects.json')
                return True
        return False

    def get_project(self, project_name):
        """Returns a project by name."""
        return self.active_projects.get(project_name)


Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools'


Subdirectory: systemOs
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs'

File: get_directory_structure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\get_directory_structure.py)
Content (First 111 lines):
tool_type_for_Tool_Manager="os"


import os


def get_directory_structure(directory=None, include_files=True, include_dirs=True, file_extension=None,
                            include_contents=False, specific_file=None, levels_up=0, verbose=False):
    if verbose:
        print("Entered get_directory_structure function with directory:", directory)

    # Set default directory
    if directory is None or directory == '/':
        directory = os.getcwd()
        if verbose:
            print(f"Directory is set to current working directory: {directory}")

    # Traverse up the directory hierarchy if levels_up is specified
    for _ in range(levels_up):
        directory = os.path.dirname(directory)
        if verbose:
            print(f"Traversed up one level, new directory: {directory}")

    # Safety check for the directory path
    if not os.path.exists(directory) or not os.path.isdir(directory):
        raise ValueError(f"The directory '{directory}' is not valid or does not exist.")

    directory_structure = {}

    def get_file_info(file_path):
        file_info = {
            'filename': os.path.basename(file_path),
            'size': os.path.getsize(file_path),
            'relative_path': os.path.relpath(file_path, directory),
            'full_path': file_path
        }
        if include_contents:
            try:
                with open(file_path, 'r') as file:
                    file_info['contents'] = file.read()
            except Exception as e:
                file_info['contents'] = f"Error reading file: {e}"
        return file_info

    if specific_file:
        if os.path.isfile(specific_file):
            if verbose:
                print(f"Getting details for specific file: {specific_file}")
            return get_file_info(specific_file)
        else:
            raise ValueError(f"The specified file '{specific_file}' does not exist.")

    for root, dirs, files in os.walk(directory):
        file_info = []
        if include_files:
            for file in files:
                if file_extension and not file.endswith(file_extension):
                    continue
                file_path = os.path.join(root, file)
                file_info.append(get_file_info(file_path))

        if include_dirs:
            directory_structure[os.path.relpath(root, directory)] = {
                'files': file_info,
                'folders': dirs
            }
        else:
            if file_info:
                directory_structure[os.path.relpath(root, directory)] = {
                    'files': file_info
                }

    if verbose:
        print("About to return the directory structure with", len(directory_structure), "folders.")

    return directory_structure


get_directory_structure_description_json = {
    'function_declarations': [
        {
            'name': 'get_directory_structure',
            'description': 'Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'directory': {'type_': 'STRING',
                                  'description': 'The path to the directory. Defaults to the current working directory if None or / is provided.'},
                    'include_files': {'type_': 'BOOLEAN',
                                      'description': 'Flag to include files in the output. Default is True.'},
                    'include_dirs': {'type_': 'BOOLEAN',
                                     'description': 'Flag to include directories in the output. Default is True.'},
                    'file_extension': {'type_': 'STRING',
                                       'description': 'Specific file extension to include. Default is None.'},
                    'include_contents': {'type_': 'BOOLEAN',
                                         'description': 'Flag to include the contents of files in the output. Default is False.'},
                    'specific_file': {'type_': 'STRING',
                                      'description': 'Path to a specific file to get its details. Default is None.'},
                    'levels_up': {'type_': 'INTEGER',
                                  'description': 'Number of levels to traverse up from the specified or current directory. Default is 0.'},
                    'verbose': {'type_': 'BOOLEAN', 'description': 'Flag for verbose logging. Default is False.'}
                },
                'required': ['directory']
            }
        }
    ]
}



get_directory_structure_description_short_str = "Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths. Includes options for filtering files, directories, file extensions, including file contents, and traversing up the directory hierarchy with a default to the current working directory."


File: save_to_file.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\save_to_file.py)
Content (First 51 lines):
tool_type_for_Tool_Manager="os"

import os
import json
from termcolor import colored  # Import the termcolor library

def save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None) -> dict:

    print(colored(f"Entering: save_to_file(...)", 'blue'))
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(colored(success_message, 'green'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(colored(error_message, 'red'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "failure", "message": error_message}


save_to_file_description_json = {
    'function_declarations': [
        {
            'name': 'save_to_file',
            'description': 'Saves content to a file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'content': {'type_': 'STRING'},
                    'file_name': {'type_': 'STRING', 'description': 'The name of the file. Defaults to "NoName".'},
                    'file_path': {'type_': 'STRING', 'description': 'The path to save the file. Defaults to the current working directory if not provided.'}
                },
                'required': ['content', 'file_name']
            }
        }
    ]
}

save_to_file_description_short_str="Searches memory frames within a specified folder based on provided criteria."


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\__pycache__'

File: get_directory_structure.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\__pycache__\get_directory_structure.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\__pycache__\get_directory_structure.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: save_to_file.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\__pycache__\save_to_file.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\systemOs\__pycache__\save_to_file.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte


Subdirectory: Updating_Project_Manager_Table
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\Updating_Project_Manager_Table'

File: update_project_table.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\Updating_Project_Manager_Table\update_project_table.py)
Content (First 159 lines):
#update_project_table.py
tool_type_for_Tool_Manager = "focus"
import os
import json
import uuid

# Emojis for visual enhancement
TASK_EMOJI = "ðŸ“„"
SUBTASK_EMOJI = "   â””â”€ "
IN_PROGRESS_EMOJI = "â³"
COMPLETED_EMOJI = "âœ…"
FOCUS_EMOJI = "ðŸŽ¯"

ACTIVE_PROJECTS_FILE = os.path.join('..', '..', 'FocusTable', 'active_projects.json')
COMPLETED_PROJECTS_FILE = os.path.join('..', '..', 'FocusTable', 'completed_projects.json')

def update_project_table(
    project_name: str = None,
    task_guid: str = None,
    task_name: str = None,
    goal: str = None,
    description: str = None,
    time_horizon: str = None,
    focus_level: int = None,
    current_focus: int = None,
    status: str = None,
    importance_level: int = None,
    difficulty: int = None,
    completeness: float = None,
    current_cost: float = None,
    result: str = None,
    parent_task_guid: str = None,
) -> dict:
    """
    Updates the project and task data directly in the JSON files.
    Creates the JSON files if they don't exist.
    Moves completed projects to 'completed_projects.json'.

    Args:
        project_name (str, optional): Name of the project to update.
        task_guid (str, optional): Unique identifier for the task. If not provided
            for a new task, one will be generated.
        task_name (str, optional): ... (other parameter descriptions)
        # ... other parameters ...

    Returns:
        dict: A dictionary indicating success or failure and a message.
    """

    try:
        # ---- Check and Create Files if Needed ----
        if not os.path.exists(ACTIVE_PROJECTS_FILE):
            print(f"File '{ACTIVE_PROJECTS_FILE}' not found, creating it...")
            os.makedirs(os.path.dirname(ACTIVE_PROJECTS_FILE), exist_ok=True)
            with open(ACTIVE_PROJECTS_FILE, 'w') as f:
                json.dump({}, f, indent=4)

        if not os.path.exists(COMPLETED_PROJECTS_FILE):
            print(f"File '{COMPLETED_PROJECTS_FILE}' not found, creating it...")
            os.makedirs(os.path.dirname(COMPLETED_PROJECTS_FILE), exist_ok=True)
            with open(COMPLETED_PROJECTS_FILE, 'w') as f:
                json.dump({}, f, indent=4)

        # ---- Load Project Data ----
        with open(ACTIVE_PROJECTS_FILE, 'r') as f:
            active_projects = json.load(f)
        with open(COMPLETED_PROJECTS_FILE, 'r') as f:
            completed_projects = json.load(f)

        # --- Logic for Finding and Updating Projects/Tasks ---
        project = active_projects.get(project_name)
        if not project:
            if project_name:
                print(f"Project '{project_name}' not found. Creating a new project.")
                active_projects[project_name] = {"tasks": []}
                project = active_projects[project_name]
            else:
                return {"status": "failure", "message": "Project name is required."}

        if task_guid:
            target_task = next((t for t in project["tasks"] if t["guid"] == task_guid), None)
        else:
            target_task = None

        if target_task:
            # Update existing task
            for attr, value in locals().items():
                if attr not in ("project_name", "task_guid", "active_projects", "completed_projects", "project", "target_task") \
                        and value is not None:
                    target_task[attr] = value
        else:
            # Add new task
            new_task = {
                "guid": str(uuid.uuid4()) if task_guid is None else task_guid,
                "name": task_name,
                "goal": goal,
                "description": description,
                "time_horizon": time_horizon,
                "focus_level": focus_level,
                "current_focus": current_focus,
                "status": status,
                "importance_level": importance_level,
                "difficulty": difficulty,
                "completeness": completeness,
                "current_cost": current_cost,
                "result": result,
                "parent_task_guid": parent_task_guid
            }
            project["tasks"].append(new_task)

        # ---  Move Completed Projects ---
        for proj_name, proj_data in list(active_projects.items()):
            if all(task.get("completeness", 0) == 1.0 for task in proj_data.get("tasks", [])):
                completed_projects[proj_name] = active_projects.pop(proj_name)

        # ---  Save Updated Projects to JSON Files ---
        with open(ACTIVE_PROJECTS_FILE, 'w') as f:
            json.dump(active_projects, f, indent=4)
        with open(COMPLETED_PROJECTS_FILE, 'w') as f:
            json.dump(completed_projects, f, indent=4)

        return {"status": "success", "message": "Project table updated successfully."}

    except Exception as e:
        return {"status": "failure", "message": f"Error updating project table: {str(e)}"}



update_project_table_description_json = {
    'function_declarations': [
        {
            'name': 'update_project_table',
            'description': 'Updates project and task details in the stored tables. Moves completed projects to a separate file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'project_name': {'type_': 'STRING', 'description': 'Name of the project'},
                    'task_guid': {'type_': 'STRING', 'description': 'Unique identifier for the task. If not provided for a new task, one will be generated.'},
                    'task_name': {'type_': 'STRING', 'description': 'Name of the task'},
                    'goal': {'type_': 'STRING', 'description': 'Goal of the task'},
                    'description': {'type_': 'STRING', 'description': 'Detailed description of the task'},
                    'time_horizon': {'type_': 'STRING', 'description': 'Time horizon for completing the task (e.g., "Short Term", "Long Term")'},
                    'focus_level': {'type_': 'INTEGER', 'description': 'Desired level of focus for the task (e.g., 1-5)'},
                    'current_focus': {'type_': 'INTEGER', 'description': 'Current level of focus on the task'},
                    'status': {'type_': 'STRING', 'description': 'Status of the task (e.g., "To Do", "In Progress", "Completed")'},
                    'importance_level': {'type_': 'INTEGER', 'description': 'Importance of the task (e.g., 1-5)'},
                    'difficulty': {'type_': 'INTEGER', 'description': 'Difficulty level of the task (e.g., 1-5)'},
                    'completeness': {'type_': 'NUMBER', 'description': 'Percentage of task completion (0.0 - 1.0)'},
                    'current_cost': {'type_': 'NUMBER', 'description': 'Current cost incurred for the task'},
                    'result': {'type_': 'STRING', 'description': 'Outcome or result of the task'},
                    'parent_task_guid': {'type_': 'STRING', 'description': 'GUID of the parent task (if any)'}
                },
                'required': ['project_name','task_guid']
            }
        }
    ]
}

update_project_table_description_short_str = "Updates project and task details based on provided arguments. Manages data persistence in JSON files."


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\Updating_Project_Manager_Table\__pycache__'

File: update_project_table.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\Updating_Project_Manager_Table\__pycache__\update_project_table.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\tools\Updating_Project_Manager_Table\__pycache__\update_project_table.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: Tool_Manager.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\Tool_Manager.py)
Content (First 116 lines):
#Tool_Manager.py
import os
import importlib.util
import json
from typing import Dict, List, Callable, Any, Optional
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ToolManager:
    def __init__(self, tools_directory="tools"):
        print(f"\033[92mInitializing ToolManager with tools directory: {tools_directory}\033[0m")
        self.tools_directory = tools_directory
        self.tool_mapping: Dict[str, Callable] = {}  # Maps tool names to functions
        self.all_tools: List[Dict] = []  # Stores tool metadata
        self.categories: Dict[str, Dict] = {}  # Stores tools by category
        self.tool_types: Dict[str, str] = {}  # Maps tool names to their types
        self.valid_tool_types = {"os","focus"}
        self._load_tools()
        self.tool_usage: Dict[str, Dict[str, float]] = {}  # Track usage and success metrics



    def _load_tools(self) -> None:
        """Loads tools from the specified directory."""
        print(f"\033[92mScanning tools directory: {self.tools_directory}\033[0m")
        for category in os.listdir(self.tools_directory):
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                print(f"  \033[94mFound category: {category}\033[0m")
                self.categories[category] = {"tools": []}
                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        self._load_tool(category, filename[:-3])

    def _load_tool(self, category: str, tool_name: str) -> None:
        """Loads a single tool from a Python file."""
        try:
            module_name = f"{category}.{tool_name}"
            module_path = os.path.join(self.tools_directory, category, f"{tool_name}.py")
            spec = importlib.util.spec_from_file_location(module_name, module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            tool_function: Callable = getattr(module, tool_name, None)
            description_name = f"{tool_name}_description_json"
            tool_description: dict = getattr(module, description_name, None)
            tool_type: str = getattr(module, "tool_type_for_Tool_Manager", "all")

            if tool_function and tool_description:
                print(f"      \033[92m- Tool function '{tool_name}' loaded successfully\033[0m")
                self.tool_mapping[tool_name] = tool_function
                tool_info = {
                    "name": tool_name,
                    "description": tool_description,
                    "category": category,
                    "type": tool_type
                }
                self.all_tools.append(tool_info)
                self.tool_types[tool_name] = tool_type
                self.categories[category]["tools"].append(tool_name)  # Add the tool to the category
            else:
                print(f"      \033[91m- Warning: Could not load tool function or description for '{tool_name}'\033[0m")

        except Exception as e:
            print(f"      \033[91m- Error loading tool '{tool_name}': {e}\033[0m")

    def get_filtered_tools(self, tool_type: str = "all") -> List[Dict]:
        """Returns a filtered list of tool information dictionaries."""
        if tool_type not in self.valid_tool_types:
            logger.warning(f"Invalid tool type '{tool_type}'. Using 'all' instead.")
            tool_type = "all"

        return [tool for tool in self.all_tools if tool_type == "all" or tool["type"] == tool_type]

    def get_tools_list_json(self, tool_type: str = "all") -> str:
        """Returns a JSON string of tools for a given tool type."""
        filtered_tools = self.get_filtered_tools(tool_type)
        return json.dumps([tool["description"] for tool in filtered_tools], indent=2)

    def get_tools_structure(self) -> Dict:
        """Returns a dictionary representing the structure of loaded tools."""
        return {
            "categories": self.categories,
            "all_tools": self.all_tools,
            "tool_mapping": list(self.tool_mapping.keys()),  # Just the tool names
            "tool_types": self.tool_types
        }

    def print_tools_structure(self):
        """Prints the structure of the loaded tools."""
        tools_structure = self.get_tools_structure()
        print("\n\n\033[95m=========================================\033[0m")
        print(f"  \033[96mTool Manager Structure\033[0m")
        print("\033[95m=========================================\033[0m")
        print(f"\n\033[92mCategories:\033[0m")
        for category, info in tools_structure["categories"].items():
            print(f"  \033[94m- {category}:\033[0m")
            for tool_name in info["tools"]:
                print(f"    \033[96m- {tool_name}\033[0m")
        print(f"\n\n\033[92mTool Descriptions:\033[0m")
        for i, tool in enumerate(tools_structure["all_tools"], 1):
            print(f"  \033[93m{i}. {json.dumps(tool, indent=2)}\033[0m")
        return tools_structure



    def get_tool_by_name(self, tool_name: str) -> Optional[Callable]:
        """Returns the tool function based on its name."""
        return self.tool_mapping.get(tool_name)

    def get_tools_by_type(self, tool_type: str) -> List[str]:
        """Returns a list of tool names for a specific type."""
        return [tool["name"] for tool in self.all_tools if tool["type"] == tool_type]


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__'

File: colors.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\colors.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\colors.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: ProjectManagerTables.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\ProjectManagerTables.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\ProjectManagerTables.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: Tool_Manager.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\Tool_Manager.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\PROJECT 19ground_zero\__pycache__\Tool_Manager.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

