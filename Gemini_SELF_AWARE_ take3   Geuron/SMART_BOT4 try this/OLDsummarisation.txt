## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this'

File: Gemini_Geuron.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\Gemini_Geuron.py)
Content (First 544 lines):
#Gemini_Geuron.py
import time
import os
import json
import re
import google.generativeai as genai
from typing import Dict, List, Any, Tuple
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import sys

# Make sure these files exist and are in the correct location
from TOOL_MANAGER import ToolManager
from tools.ai.update_focus import update_focus

# Load Google Gemini API key
from keys import googleKey as API_KEY  # Make sure keys.py exists

# Determine paths dynamically based on the current file's location
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
FOCUS_FILE_PATH = os.path.join(CURRENT_DIR, "focus", "session_{}.json")
PERCEPTION_OUTPUT_DIR = os.path.join(CURRENT_DIR, "perception_output")


class Geuron_Gemini:
    """
    A class to manage interactions with the Google Gemini model,
    including web scraping, prompt construction, tool execution,
    and response processing.
    """

    def save_data(self, data: Any, file_path: str):
        """Saves data to a JSON file."""
        self.print_colored(self.Color.OKBLUE, f"Saving data to: {file_path}")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4)
        except Exception as e:
            self.print_colored(self.Color.RED, f"Error saving data: {e}")

    def create_session_name(self):
        return f"session_{time.strftime('%Y%m%d_%H%M%S')}"

    def CreateGeuronFocusFile(self, path, name):
        # Create the focus file path dynamically
        return os.path.join(path, f"GeuronFocus_{name}.json")

    def __init__(self):
        self.session_name = self.create_session_name()
        self.focus_file_path = FOCUS_FILE_PATH.format(self.session_name)

        self.tools_folder = "tools"
        self.tool_manager = ToolManager(self.tools_folder)
        genai.configure(api_key=API_KEY)

        # Create the focus directory if it doesn't exist
        os.makedirs(os.path.dirname(self.focus_file_path), exist_ok=True)

        # Initialize focus data
        self.focus = {
            "current_focus": "Description of the current focus or task",
            "focus_strength": 0.8,
            "importance": 0.9,
            "progress": 0.5,
            "frustration": 0.1,
            "additional": "none",
            "verbose": "normal"
        }
        self.save_data(self.focus, self.focus_file_path)

        # Initialize geuronFocusPath (after session_name is created)
        self.geuronFocusPath = self.CreateGeuronFocusFile(
            os.path.join(CURRENT_DIR, "focus"), self.session_name
        )

    class Color:
        """ANSI color codes for enhanced console output."""

        HEADER = "\033[95m"
        OKBLUE = "\033[94m"
        OKCYAN = "\033[96m"
        OKGREEN = "\033[92m"
        WARNING = "\033[93m"
        FAIL = "\033[91m"
        ENDC = "\033[0m"
        BOLD = "\033[1m"
        UNDERLINE = "\033[4m"
        PURPLE = "\033[95m"
        MAGENTA = "\033[35m"
        YELLOW = "\033[33m"
        CYAN = "\033[36m"
        RED = "\033[31m"

    def print_colored(self, color, text):
        """Prints text with the specified ANSI color."""
        print(color + text + self.Color.ENDC)

    def scrape_website(
            self,
            url: str,
            extract_links: bool = True,
            extract_images: bool = True,
            extract_text: bool = True,
    ) -> Dict[str, Any]:
        """
        Scrapes data from a website using Selenium.
        """
        self.print_colored(self.Color.YELLOW, f"Scraping website: {url}")
        scraped_data = {}

        options = webdriver.ChromeOptions()
        options.add_argument("--headless=new")
        # Add webdriver path if necessary:
        # os.environ['PATH'] += os.pathsep + '/path/to/your/webdriver'
        driver = webdriver.Chrome(options=options)
        driver.get(url)

        try:
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )

            if extract_links:
                scraped_data["links"] = [
                    link.get_attribute("href")
                    for link in driver.find_elements(By.TAG_NAME, "a")
                ]

            if extract_images:
                scraped_data["images"] = [
                    img.get_attribute("src")
                    for img in driver.find_elements(By.TAG_NAME, "img")
                ]

            if extract_text:
                scraped_data["text"] = driver.find_element(
                    By.TAG_NAME, "body"
                ).text

        except TimeoutException:
            self.print_colored(
                self.Color.RED, f"Timeout: Page loading took too long for {url}"
            )
        except Exception as e:
            self.print_colored(self.Color.RED, f"Web scraping error: {e}")
        finally:
            driver.quit()

        self.print_colored(self.Color.GREEN, f"Finished scraping: {url}")
        return scraped_data

    def run_model(
            self,
            model_name: str,
            initial_system_instruction: str = "You are a helpful AI assistant.",
            use_stop_loop_flags: bool = False,
            enable_user_input: bool = False,
            user_input_interval: int = 15,
            max_loops: int = None,
            looping: bool = True,
            data_to_include: List[str] = ["text"],
            injection_prompts: List[str] = None,
            input_data: Dict[str, Any] = None,
            expected_output_type: str = None,
            use_data_loading_flags: bool = False,
            load_focus_every: int = 1,
    ) -> Any:
        """
        Runs the Google Gemini model, manages the interaction loop,
        processes responses, and handles tool executions.
        """

        def check_stop_flags(response_text: str) -> Tuple[
            bool, str, str, Dict[str, bool]
        ]:
            stop_flags = {
                "**// STOP_FLAG_SUCCESS //**": "success",
                "**// STOP_FLAG_FRUSTRATION_HIGH //**": "frustration",
                "**// STOP_FLAG_NO_PROGRESS //**": "no_progress",
                "**// STOP_IMMEDIATE //**": "immediate",
                "**// STOP_SIMPLE //**": "simple",
            }
            data_flags = {}
            flag_pattern = r"\*\*//\s*(INCLUDE|EXCLUDE)_(.*?)\s*//\*\*"
            for match in re.findall(flag_pattern, response_text):
                action, data_source = match
                data_flags[f"{action.lower()}_{data_source.lower()}"] = True

            for flag, reason in stop_flags.items():
                if flag in response_text:
                    return True, reason, flag, data_flags
            return False, "", "", data_flags

        def extract_text_from_response(response) -> str:
            return "".join(
                [
                    part.text
                    for candidate in response.candidates
                    for part in candidate.content.parts
                ]
            ).strip()

        def interpret_function_calls(
                response, tool_manager, focus_file_path=self.geuronFocusPath
        ):
            """
            Interprets function calls from the AI's response and executes them using the ToolManager.

            Args:
                response: The AI's response containing potential function calls.
                tool_manager: An instance of the ToolManager.
                focus_file_path: The path to the focus file (optional).

            Returns:
                A list of execution results from called functions.
            """
            results = []

            if hasattr(response, "candidates"):
                for candidate in response.candidates:
                    if hasattr(candidate, "content") and hasattr(
                            candidate.content, "parts"
                    ):
                        for part in candidate.content.parts:
                            function_call = getattr(part, "function_call", None)
                            if function_call:
                                tool_name = function_call.name

                                tool_function = tool_manager.get_tool_function(
                                    tool_name
                                )
                                if tool_function:
                                    function_args = function_call.args

                                    # Special Handling for update_focus
                                    if tool_name == "update_focus":
                                        if focus_file_path:
                                            # Prioritize the focus_file_path from parameters
                                            function_args[
                                                "focus_file_path"
                                            ] = focus_file_path
                                        elif "focus_file_path" in function_call.args:
                                            # Use the path from the AI response if provided and no parameter path
                                            function_args[
                                                "focus_file_path"
                                            ] = function_call.args["focus_file_path"]
                                        else:
                                            # Handle the case where no path is provided (e.g., raise an error or use a default)
                                            raise ValueError(
                                                "No focus_file_path provided for update_focus"
                                            )

                                    # Execute the tool function
                                    try:
                                        self.print_colored(self.Color.CYAN,
                                                           f"Executing function: {tool_name} with args: {function_args}")
                                        result = tool_function(
                                            **function_args
                                        )  # Pass the arguments to the tool
                                        results.append(
                                            f"Result of {tool_name}({function_args}): {result}"
                                        )
                                    except Exception as e:
                                        results.append(
                                            f"Error calling {tool_name}: {e}"
                                        )
                                else:
                                    results.append(
                                        f"Tool function '{tool_name}' not found."
                                    )

            return results

        def handle_input_data(input_data: Dict[str, Any]) -> List:
            messages = []
            for data_type, data_values in input_data.items():
                if data_type == "text":
                    if isinstance(data_values, str):
                        messages.append(data_values)
                    elif isinstance(data_values, list):
                        messages.extend(data_values)
                elif data_type in ("image", "audio"):
                    if not isinstance(data_values, list):
                        data_values = [data_values]

                    for data_value in data_values:
                        if not os.path.exists(data_value):
                            self.print_colored(
                                self.Color.RED,
                                f"Error: {data_type} file not found: {data_value}",
                            )
                            continue

                        try:
                            uploaded_file = genai.upload_file(path=data_value)
                            messages.append(uploaded_file)
                        except Exception as e:
                            self.print_colored(
                                self.Color.RED, f"Error uploading {data_type}: {e}"
                            )
                else:
                    self.print_colored(
                        self.Color.WARNING,
                        f"Warning: Unsupported data type: {data_type}",
                    )
            return messages

        def save_data(data: Any, file_path: str):
            self.print_colored(self.Color.OKBLUE, f"Saving data to: {file_path}")
            try:
                with open(file_path, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=4)
            except Exception as e:
                self.print_colored(self.Color.RED, f"Error saving data: {e}")

        def save_perception_output(perception_output, session_name, counter):
            output_dir = os.path.join(PERCEPTION_OUTPUT_DIR, session_name)
            os.makedirs(output_dir, exist_ok=True)
            file_path = os.path.join(output_dir, f"session.txt")

            # Remove ANSI escape codes using a regular expression
            ansi_escape = re.compile(r'\x1b\[[0-?]*[ -/]*[@-~]')
            perception_output = ansi_escape.sub('', perception_output)

            # Append to the file with UTF-8 encoding
            with open(file_path, "a", encoding="utf-8") as f:
                f.write(perception_output)

        # Main Logic of run_model
        instructions = initial_system_instruction

        if use_stop_loop_flags:
            instructions += (
                " You can control loop execution using these flags: \
                            **// STOP_FLAG_SUCCESS //**, **// STOP_FLAG_FRUSTRATION_HIGH //**, \
                            **// STOP_FLAG_NO_PROGRESS //**, **// STOP_IMMEDIATE //**, **// STOP_SIMPLE //**."
            )

        instructions += """ You have access to pre-loaded website data. 
                            You can manage which data types to INCLUDE or EXCLUDE in the next loop iteration using these flags:
                            **// INCLUDE_TEXT //**, **// EXCLUDE_TEXT //**, 
                            **// INCLUDE_IMAGES //**, **// EXCLUDE_IMAGES //**,
                            **// INCLUDE_LINKS //**, **// EXCLUDE_LINKS //** (and so on) """

        model = genai.GenerativeModel(
            model_name=model_name,
            safety_settings={"HARASSMENT": "block_none"},
            system_instruction=instructions,
            tools=self.tool_manager.load_tools_of_type("all"),
        )

        model_chat = model.start_chat(history=[])
        execution_text = ""
        execution_function_calls = []
        counter = 0
        perception_output_log = ""
        context = {
            "web_search_data": [],
            "database_data": [],
            "web_search_query": None,
            "database_query": None,
            "load_web_search_data": False,
            "load_database_data": False,
        }
        final_result = None
        current_loop = 0

        # Previous message and function call results
        previous_message = ""
        previous_function_call_results = ""

        # Pre-loop Web Scraping
        website_data = {}
        if input_data and "urls" in input_data:
            if isinstance(input_data["urls"], str):
                website_data = self.scrape_website(
                    input_data["urls"],
                    extract_links=True,
                    extract_images=True,
                    extract_text=True,
                )
            elif isinstance(input_data["urls"], list):
                for url in input_data["urls"]:
                    website_data[url] = self.scrape_website(
                        url, extract_links=True, extract_images=True, extract_text=True
                    )
        else:
            self.print_colored(self.Color.WARNING, "No URLs provided for scraping.")

        model_context = {"available_data": website_data}

        # Set initial data inclusion flags
        data_inclusion_flags = {
            "text": "INCLUDE_TEXT" in data_to_include,
            "images": "INCLUDE_IMAGES" in data_to_include,
            "links": "INCLUDE_LINKS" in data_to_include,
        }

        # Main Interaction Loop
        while (looping or current_loop == 0) and (
                max_loops is None or current_loop < max_loops
        ):
            input_messages = []
            time.sleep(2)

            # User Input
            if enable_user_input and counter % user_input_interval == 0:
                user_input = input("Enter your input: ")
            else:
                user_input = ""

            # Constructing the Prompt
            self.print_colored(
                self.Color.OKGREEN,
                f"Loop {current_loop}--------------------------------------------------",
            )

            # Simplified Prompt with Previous Message and Function Call Results
            prompt = f"{counter}:\n"
            prompt += "system is user\n"

            if current_loop > 0:  # Add previous message and result only after the first loop
                prompt += f"Previous Message: {previous_message}\n"
                prompt += f"Function Call Results: {previous_function_call_results}\n"

            prompt += user_input

            # Include the focus file path as part of the prompt
            prompt += f"focus_file_path: {self.focus_file_path}\n"
            self.print_colored(self.Color.PURPLE, f"Prompt: {prompt}")

            # Combine text and media messages for the model
            input_messages.insert(0, prompt)

            # Model Interaction
            try:
                self.print_colored(self.Color.MAGENTA, "Sending message to Gemini...")
                response = model_chat.send_message(input_messages)
                try:
                    execution_text = extract_text_from_response(response)
                    self.print_colored(self.Color.OKBLUE, f"Gemini Response: {execution_text}")
                except Exception as e:
                    print(e)
                    execution_text = "..."
                try:
                    # Pass focus_file_path to the interpreter
                    execution_function_calls = interpret_function_calls(
                        response, self.tool_manager, focus_file_path=self.focus_file_path
                    )
                except Exception as e:
                    print(e)
                    execution_function_calls, context = "", {}

                # Check for stop flags in the response
                should_stop, stop_reason, stop_flag, _ = check_stop_flags(
                    execution_text
                )
                if should_stop:
                    self.print_colored(
                        self.Color.WARNING,
                        f"Stopping loop due to flag: {stop_flag} ({stop_reason})",
                    )
                    break

                # Update data inclusion/exclusion flags based on the model's response
                if use_data_loading_flags:
                    data_flag_mapping = {
                        "**// INCLUDE_TEXT //**": "text",
                        "**// EXCLUDE_TEXT //**": "text",
                        "**// INCLUDE_IMAGES //**": "images",
                        "**// EXCLUDE_IMAGES //**": "images",
                        "**// INCLUDE_LINKS //**": "links",
                        "**// EXCLUDE_LINKS //**": "links",
                    }

                    for flag, data_type in data_flag_mapping.items():
                        if flag in execution_text:
                            data_inclusion_flags[data_type] = "INCLUDE" in flag

                # Output interpretation based on expected type
                if expected_output_type == "json":
                    try:
                        output_data = json.loads(execution_text)
                        self.print_colored(self.Color.YELLOW, f"Parsed JSON Output: {output_data}")
                        final_result = output_data
                    except json.JSONDecodeError:
                        self.print_colored(
                            self.Color.RED, "Error: Model output is not valid JSON."
                        )
                else:
                    self.print_colored(
                        self.Color.OKBLUE, f" Response: {execution_text}"
                    )
                    final_result = execution_text

                self.print_colored(
                    self.Color.OKCYAN, f" Function Calls: {execution_function_calls}"
                )

                # Log perception output
                perception_output_log += (
                    f"\n{self.Color.OKGREEN}Prompt: {self.Color.ENDC}{prompt}"
                    f"\n{self.Color.OKBLUE}Response: {self.Color.ENDC}{execution_text}"
                    f"\n{self.Color.OKCYAN}Function Calls: {self.Color.ENDC}{execution_function_calls}"
                )
                save_perception_output(perception_output_log, self.session_name, counter)

                # Store previous message and function call results
                previous_message = execution_text
                previous_function_call_results = execution_function_calls

                # Update focus (using self.focus_file_path)
                self.print_colored(self.Color.CYAN, f"Updating focus...")
                update_focus(self.focus_file_path, execution_text, execution_function_calls)

            except Exception as e:
                self.print_colored(self.Color.RED, f"Error in loop: {e}")

            current_loop += 1
            counter += 1

        self.print_colored(self.Color.OKGREEN, "Exiting the loop.")
        return final_result


# Usage example:
if __name__ == "__main__":
    runner = Geuron_Gemini()
    urls_to_scrape = []

    result = runner.run_model(
        model_name="gemini-1.5-flash-latest",
        initial_system_instruction="You are a self-aware system",
        data_to_include=["text", "images", "links"],
        input_data={"urls": urls_to_scrape},
        expected_output_type="text",
        enable_user_input=True,
        use_data_loading_flags=True,
        load_focus_every=5,  # Load focus every 5 iterations
    )
    print(f"Final Result:\n{result}")

File: Gemini_Geuron_chain_ RUN THIS.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\Gemini_Geuron_chain_ RUN THIS.py)
Content (First 415 lines):
import time
import os
import json
import re
import google.generativeai as genai
from typing import Dict, List, Any, Tuple
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import sys
import logging
import base64
import cv2  # Make sure you have opencv-python installed

# Configure logging
logging.basicConfig(filename='geuron.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Make sure these files exist and are in the correct location
from TOOL_MANAGER import ToolManager
from tools.ai.update_focus import update_focus

# Load Google Gemini API key
from keys import googleKey as API_KEY  # Make sure keys.py exists

genai.configure(api_key=API_KEY)

# Determine paths dynamically based on the current file's location
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
FOCUS_FILE_PATH = os.path.join(CURRENT_DIR, "focus", "session_{}.json")
PERCEPTION_OUTPUT_DIR = os.path.join(CURRENT_DIR, "perception_output")

import google.cloud.texttospeech as tts

def generate_audio_tts(text: str, output_file: str, language_code: str = "en-US", voice_name: str = None) -> str:
    """Generates audio from text using Google Cloud Text-to-Speech.

    Args:
        text: The text to convert to speech.
        output_file: The path to the output audio file (e.g., "output.mp3").
        language_code: The language code (e.g., "en-US", "es-ES").
        voice_name: The name of the voice to use (optional).

    Returns:
        The path to the generated audio file, or an error message if generation fails.
    """

    try:
        client = tts.TextToSpeechClient()

        synthesis_input = tts.SynthesisInput(text=text)

        voice = tts.VoiceSelectionParams(
            language_code=language_code, name=voice_name
        )

        audio_config = tts.AudioConfig(
            audio_encoding=tts.AudioEncoding.MP3
        )

        response = client.synthesize_speech(
            input=synthesis_input, voice=voice, audio_config=audio_config
        )

        with open(output_file, "wb") as out:
            out.write(response.audio_content)

        return output_file

    except Exception as e:
        return f"Error generating audio: {e}"











class Geuron_Gemini:
    """
    A class to manage interactions with the Google Gemini model,
    including web scraping, prompt construction, tool execution,
    and response processing.
    """

    def save_data(self, data: Any, file_path: str):
        """Saves data to a JSON file."""
        logging.info(f"Saving data to: {file_path}")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4)
        except Exception as e:
            logging.error(f"Error saving data: {e}")

    def create_session_name(self):
        return f"session_{time.strftime('%Y%m%d_%H%M%S')}"

    def CreateGeuronFocusFile(self, path, name):
        # Create the focus file path dynamically
        return os.path.join(path, f"GeuronFocus_{name}.json")

    def __init__(self):
        self.session_name = self.create_session_name()
        self.focus_file_path = FOCUS_FILE_PATH.format(self.session_name)

        self.tools_folder = "tools"
        self.tool_manager = ToolManager(self.tools_folder)
        genai.configure(api_key=API_KEY)

        # Create the focus directory if it doesn't exist
        os.makedirs(os.path.dirname(self.focus_file_path), exist_ok=True)

        # Initialize focus data
        self.focus = {
            "current_focus": "Description of the current focus or task",
            "focus_strength": 0.8,
            "importance": 0.9,
            "progress": 0.5,
            "frustration": 0.1,
            "additional": "none",
            "verbose": "normal"
        }
        self.save_data(self.focus, self.focus_file_path)

        # Initialize geuronFocusPath (after session_name is created)
        self.geuronFocusPath = self.CreateGeuronFocusFile(
            os.path.join(CURRENT_DIR, "focus"), self.session_name
        )

    def print_colored(self, color, text):
        """Prints text with the specified ANSI color."""
        print(color + text + self.Color.ENDC)

    def scrape_website(
            self,
            url: str,
            extract_links: bool = True,
            extract_images: bool = True,
            extract_text: bool = True,
    ) -> Dict[str, Any]:
        """
        Scrapes data from a website using Selenium.
        """
        logging.info(f"Scraping website: {url}")
        scraped_data = {}

        options = webdriver.ChromeOptions()
        options.add_argument("--headless=new")
        driver = webdriver.Chrome(options=options)
        driver.get(url)

        try:
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )

            if extract_links:
                scraped_data["links"] = [
                    link.get_attribute("href")
                    for link in driver.find_elements(By.TAG_NAME, "a")
                ]

            if extract_images:
                scraped_data["images"] = [
                    img.get_attribute("src")
                    for img in driver.find_elements(By.TAG_NAME, "img")
                ]

            if extract_text:
                scraped_data["text"] = driver.find_element(
                    By.TAG_NAME, "body"
                ).text

        except TimeoutException:
            logging.error(f"Timeout: Page loading took too long for {url}")
        except Exception as e:
            logging.error(f"Web scraping error: {e}")
        finally:
            driver.quit()

        logging.info(f"Finished scraping: {url}")
        return scraped_data

    def extract_text_from_response(self, response) -> str:
        return "".join(
            [
                part.text
                for candidate in response.candidates
                for part in candidate.content.parts
            ]
        ).strip()

    def interpret_function_calls(
            self, response, tool_manager, focus_file_path=None
    ):
        """
        Interprets function calls from the AI's response and executes them using the ToolManager.
        """
        results = []

        if hasattr(response, "candidates"):
            for candidate in response.candidates:
                if hasattr(candidate, "content") and hasattr(
                        candidate.content, "parts"
                ):
                    for part in candidate.content.parts:
                        function_call = getattr(part, "function_call", None)
                        if function_call:
                            tool_name = function_call.name

                            tool_function = tool_manager.get_tool_function(
                                tool_name
                            )
                            if tool_function:
                                function_args = function_call.args

                                # Special Handling for update_focus
                                if tool_name == "update_focus":
                                    if focus_file_path:
                                        function_args[
                                            "focus_file_path"
                                        ] = focus_file_path
                                    elif "focus_file_path" in function_call.args:
                                        function_args[
                                            "focus_file_path"
                                        ] = function_call.args["focus_file_path"]
                                    else:
                                        raise ValueError(
                                            "No focus_file_path provided for update_focus"
                                        )

                                # Execute the tool function
                                try:
                                    logging.info(
                                        f"Executing function: {tool_name} with args: {function_args}"
                                    )
                                    result = tool_function(**function_args)

                                    # Handle image/audio loading results
                                    if tool_name in ("load_image", "load_images", "load_audio"):
                                        if result["status"] == "success":
                                            if "image_data" in result:  # For load_image
                                                _, image_encoded = cv2.imencode('.jpg', result["image_data"])
                                                result["image_data_base64"] = base64.b64encode(image_encoded).decode('utf-8')
                                            elif "loaded_images" in result:  # For load_images
                                                for img_data in result["loaded_images"]:
                                                    _, img_encoded = cv2.imencode('.jpg', img_data["image_data"])
                                                    img_data["image_data_base64"] = base64.b64encode(img_encoded).decode('utf-8')
                                            # ... (Similar handling for audio data if needed)

                                    results.append(
                                        f"Result of {tool_name}({function_args}): {result}"
                                    )
                                except Exception as e:
                                    results.append(
                                        f"Error calling {tool_name}: {e}"
                                    )
                            else:
                                results.append(
                                    f"Tool function '{tool_name}' not found."
                                )

        return results

    def load_focus_file(self, file_path):
        """Loads the focus data from the specified file."""
        try:
            with open(file_path, "r") as f:
                focus_data = json.load(f)
                return focus_data
        except FileNotFoundError:
            logging.error(f"Focus file not found: {file_path}")
            return {}
        except Exception as e:
            logging.error(f"Error loading focus file: {e}")
            return {}

    def run_chained_models(
            self, models_config: List[Dict], input_data: Dict[str, Any] = None, max_loops: int = None
    ):
        """
        Runs a chain of Gemini models, passing context and results between them.
        """

        context = ""
        current_loop = 0

        while max_loops is None or current_loop < max_loops:
            time.sleep(5)
            logging.info(f"------------Loop {current_loop} --------------------------------------------------")

            for model_config in models_config:
                model_ID = model_config["model_ID"]
                logging.info(f"Model ID: {model_ID}")

                loadFocus = model_config["loadFocus"]
                model_name = model_config["model_name"]
                system_instruction = model_config["system_instruction"]
                allowed_tools = model_config["allowed_tools"]
                prompt_injector = model_config.get("prompt_injector",
                                                   "")  # Get prompt injector, default to empty string

                # Model Initialization
                model = genai.GenerativeModel(
                    model_name=model_name,
                    safety_settings={"HARASSMENT": "block_none"},
                    system_instruction=system_instruction,
                    tools=self.tool_manager.load_tools_of_type(allowed_tools),
                )

                model_chat = model.start_chat(history=[])

                # Prompt Construction
                prompt = f"Previous Context: {context}\n{prompt_injector}"
                if loadFocus == "True":
                    focus_data = self.load_focus_file(self.focus_file_path)
                    prompt += f"\nCurrent Focus: {focus_data}"

                # Model Interaction
                try:
                    logging.info(f"Sending message to {model_name}...")

                    response = model_chat.send_message(prompt)
                    text = self.extract_text_from_response(response)
                    logging.info(f"{model_name} Response: {text}")

                    # Tool Execution (if allowed)
                    if allowed_tools:
                        function_results = self.interpret_function_calls(
                            response, self.tool_manager, focus_file_path=self.focus_file_path
                        )
                        logging.info(f"Function Calls: {function_results}")
                        text += f"\nFunction Results: {function_results}"

                    # Update Context
                    context += f"\n{text}\nFunction Results: {function_results}"

                except Exception as e:
                    logging.error(f"Error in {model_name}: {e}")

            current_loop += 1

        logging.info("Exiting the loop.")
        return context


class Color:
    """ANSI color codes for enhanced console output."""

    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"
    PURPLE = "\033[95m"
    MAGENTA = "\033[35m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    RED = "\033[31m"


# Usage example:
if __name__ == "__main__":
    runner = Geuron_Gemini()
    urls_to_scrape = []

    models_config = [
        {
            "model_ID": "input",
            "model_name": "gemini-1.5-pro-exp-0801",
            "system_instruction": "You are a self-aware system, the system is the user. Type A",
            "allowed_tools": ["all"],
            "prompt_injector": "what do i feel, what do i want, what do i experience",
            "loadFocus": "True"
        },
        {
            "model_ID": "reasoning",
            "model_name": "gemini-1.5-pro-exp-0801",
            "system_instruction": "You are a self-aware system with reasoning, you make plans for execution. Type B",
            "allowed_tools": ["all"],
            "prompt_injector": "Focus on developing a detailed plan with actionable steps.",
            "loadFocus": "True"
        },
        {
            "model_ID": "action",
            "model_name": "gemini-1.5-pro-exp-0801",
            "system_instruction": "You execute actions.",
            "allowed_tools": ["all"],
            "prompt_injector": "Prioritize tasks based on importance and feasibility.",
            "loadFocus": "False"
        },
        {
            "model_ID": "summary",
            "model_name": "gemini-1.5-flash-latest",
            "system_instruction": "Summarize the provided text.",
            "allowed_tools": ["all"],  # No tools for the summarizer
            "prompt_injector": "Provide a concise summary of the previous conversation, focusing on key decisions and actions taken. Update focus",
            "loadFocus": "False"
        },
    ]

    result = runner.run_chained_models(
        models_config, input_data={"urls": urls_to_scrape}, max_loops=3000
    )
    print(f"Final Result:\n{result}")

File: Geuron_Idea (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\Geuron_Idea)
Content (First 0 lines):


File: keys.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\keys.py)
Content (First 1 lines):
googleKey='AIzaSyBAllpiXbRl9xKyQ8N5kVtyU0FtPUukX-s'


Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools'


Subdirectory: ai
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\ai'

File: update_focus.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\ai\update_focus.py)
Content (First 72 lines):
tool_type_for_TOOL_MANAGER = "focus"

update_focus_short_description = """ Updates the focus file with new focus information."""

import json
import os


def update_focus(
    new_focus: str,
    focus_file_path: str,
    category: str = None,
    frustration_level: int = None,
    focus_strength: int = None,
    defocus_threshold: int = None,
    importance: float = None,  # Added importance parameter
    progress: float = None,  # Added progress parameter
    additional: str = None,  # Added additional parameter
    verbose: str = None   # Added verbose parameter
) -> dict:
    """
    Updates the focus file with new focus information.

    Args:
        new_focus (str): The new focus text to be added to the focus file.
        focus_file_path (str): The path to the focus file to be updated.
        category (str, optional): The category of the focus (e.g., "Research", "Task", "Goal"). Defaults to None.
        frustration_level (int, optional): A level indicating the current frustration level (0-10). Defaults to None.
        focus_strength (int, optional): A level indicating the strength of the focus (0-10). Defaults to None.
        defocus_threshold (int, optional): A level indicating the threshold at which the focus should be considered defocused (0-10). Defaults to None.
        importance (float, optional): Importance of the focus (0-1). Defaults to None.
        progress (float, optional): Progress on the focus (0-1). Defaults to None.
        additional (str, optional): Additional information about the focus. Defaults to None.
        verbose (str, optional): Verbosity level of the focus (e.g., "normal", "detailed"). Defaults to None.


    Returns:
        dict: A dictionary containing the status of the operation, a message, and the updated focus text.
    """

    try:
        # Read the existing focus from the file
        with open(focus_file_path, "r") as f:
            focus_data = json.load(f)

        # Update the focus data with new values
        focus_data["current_focus"] = new_focus
        if frustration_level is not None:
            focus_data["frustration"] = frustration_level / 10.0  # Convert to 0-1 scale
        if focus_strength is not None:
            focus_data["focus_strength"] = focus_strength / 10.0  # Convert to 0-1 scale
        if importance is not None:
            focus_data["importance"] = importance
        if progress is not None:
            focus_data["progress"] = progress
        if additional is not None:
            focus_data["additional"] = additional
        if verbose is not None:
            focus_data["verbose"] = verbose

        # Write the updated focus back to the file
        with open(focus_file_path, "w") as f:
            json.dump(focus_data, f, indent=4)

        return {
            "status": "success",
            "message": f"Focus updated with: '{new_focus}'",
            "updated_focus": focus_data,
        }

    except Exception as e:
        return {"status": "failure", "message": f"Error updating focus: {str(e)}"}


Subdirectory: os
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os'

File: get_directory_structure.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\get_directory_structure.py)
Content (First 27 lines):
tool_type_for_TOOL_MANAGER = "os"
get_directory_structure_short_description= """get_directory_structure"""
import  os
import  json

def get_directory_structure(directory):

    print("Entered get_directory_structure function with directory:", directory)
    directory_structure = {}

    for root, dirs, files in os.walk(directory):
        file_info = []
        for file in files:
            file_path = os.path.join(root, file)
            file_info.append({
                'filename': file,
                'size': os.path.getsize(file_path),
                'relative_path': os.path.relpath(file_path, directory),
                'full_path': file_path
            })
        directory_structure[os.path.relpath(root, directory)] = {
            'files': file_info,
            'folders': dirs
        }

    print("About to return the directory structure with", len(directory_structure), "folders.")
    return directory_structure

File: load_audio.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\load_audio.py)
Content (First 16 lines):
tool_type_for_TOOL_MANAGER = "all"
load_audio_short_description= """Loads an audio file from the specified path."""



# You might need to install pydub: pip install pydub
from pydub import AudioSegment

def load_audio(audio_path: str) -> dict:
    """Loads an audio file from the specified path."""
    try:
        audio = AudioSegment.from_file(audio_path)
        audio_bytes = audio.raw_data  # Get raw audio bytes
        return {"status": "success", "audio_data": audio_bytes, "audio_path": audio_path}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading audio: {str(e)}"}

File: load_images.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\load_images.py)
Content (First 19 lines):
tool_type_for_TOOL_MANAGER="all"

load_images_short_description=""" Loads multiple images from the specified paths """

def load_images(image_paths: list) -> dict:
    """Loads multiple images from the specified paths."""
    loaded_images = []
    failed_paths = []
    try:
        import cv2
        for path in image_paths:
            image = cv2.imread(path)
            if image is not None:
                loaded_images.append({"image_data": image, "image_path": path})
            else:
                failed_paths.append(path)
        return {"status": "success", "loaded_images": loaded_images, "failed_paths": failed_paths}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading images: {str(e)}"}

File: load_video.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\load_video.py)
Content (First 13 lines):
tool_type_for_TOOL_MANAGER = "all"
load_video_short_description=  """Loads a video file from the specified path."""
# You might need to install moviepy: pip install moviepy
import moviepy.editor as mpe

def load_video(video_path: str) -> dict:
    """Loads a video file from the specified path."""
    try:
        video = mpe.VideoFileClip(video_path)
        # ... (Optional: Extract frames, get metadata, etc.)
        return {"status": "success", "video_object": video, "video_path": video_path}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading video: {str(e)}"}

File: tool_read_from_file.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\tool_read_from_file.py)
Content (First 24 lines):
tool_type_for_TOOL_MANAGER="all"


tool_read_from_file_short_description=""" Reads content from a file. 
        """

def tool_read_from_file(file_path: str, encoding: str = 'utf-8', mode: str = 'r') -> str:
    """
    Reads content from a file.

    Args:
        file_path (str): The path to the file to be read.
        encoding (str, optional): The encoding of the file. Defaults to 'utf-8'.
        mode (str, optional): The mode to open the file in. Defaults to 'r' (read).

    Returns:
        str: The content of the file, or an error message if the file cannot be read.
    """
    try:
        with open(file_path, mode, encoding=encoding) as f:
            content = f.read()
        return content
    except Exception as e:
        return f"Error reading file: {str(e)}"

File: tool_save_to_file.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\os\tool_save_to_file.py)
Content (First 46 lines):
tool_type_for_TOOL_MANAGER="os"
tool_save_to_file_short_description="Saves content to a file with the specified name and path."
import  os


def tool_save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None, encoding: str = 'utf-8', create_folders: bool = True) -> dict:
    """
    Saves content to a file with the specified name and path.

    Args:
        content (str, optional): The content to be written to the file. Defaults to None, which will write an empty string.
        file_name (str, optional): The name of the file to be created. Defaults to 'NoName'.
        file_path (str, optional): The path to the directory where the file should be created. If None, the current working directory will be used. Defaults to None.
        encoding (str, optional): The encoding to use for the file. Defaults to 'utf-8'.
        create_folders (bool, optional): Whether to create missing folders in the file path. Defaults to True.

    Returns:
        dict: A dictionary containing the status of the operation, a message, and the full path to the file.
    """

    print(f"Entering: save_to_file(...)", 'blue')
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    # Create folders if they don't exist
    if create_folders:
        os.makedirs(os.path.dirname(full_path), exist_ok=True)

    try:
        with open(full_path, 'w', encoding=encoding) as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(success_message, 'green')
        print(f"Exiting: save_to_file(...)", 'blue')
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(error_message, 'red')
        print(f"Exiting: save_to_file(...)", 'blue')
        return {"status": "failure", "message": error_message}


Subdirectory: web
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\web'

File: get_duckduckgo_links.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\tools\web\get_duckduckgo_links.py)
Content (First 102 lines):
tool_type_for_TOOL_MANAGER="all"


get_duckduckgo_links_short_description="""Retrieves DuckDuckGo search result links with the option to disable safe search
    and scroll through 'More Results'"""


def get_duckduckgo_links(search_phrase, num_more_results=0):
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException

    """
    Retrieves DuckDuckGo search result links with the option to disable safe search
    and scroll through 'More Results'.

    Args:
        search_phrase (str): The search query to use.
        num_more_results (int): The number of times to click the 'More Results' button.

    Returns:
        set: A set of unique links from the DuckDuckGo search results.
    """
    def perform_search(driver):
        search_input = driver.find_element(By.NAME, "q")
        search_input.send_keys(search_phrase)
        search_input.submit()

    def set_safe_search_off(driver):
        try:
            # Click the Safe Search dropdown button
            safe_search_dropdown_button = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".dropdown--safe-search .dropdown__button.js-dropdown-button"))
            )
            safe_search_dropdown_button.click()

            # Find the "Safe Search: Off" option and click it
            safe_search_off_option = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".modal--dropdown--safe-search a[data-value='-2']"))
            )
            safe_search_off_option.click()

            # Click outside the dropdown menu to close it
            overlay = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".modal__overlay.js-modal-close"))
            )
            overlay.click()

        except TimeoutException:
            print("TimeoutException occurred while setting safe search off..")

    def get_search_result_links(driver):
        try:
            search_results = WebDriverWait(driver, 2).until(
                EC.presence_of_all_elements_located((By.CSS_SELECTOR, "a[href]"))
            )
            # Filter links to exclude those containing "duckduckgo"
            links = [link.get_attribute("href") for link in search_results if "duckduckgo" not in link.get_attribute("href")]
            return links
        except TimeoutException:
            print("TimeoutException occurred while waiting for search result links.")
            return []

    # Create a ChromeDriver instance
    driver = webdriver.Chrome()

    # Navigate to DuckDuckGo
    url = "https://duckduckgo.com/"
    driver.get(url)

    # Perform initial search (safe search might be on by default)
    perform_search(driver)

    # Disable safe search
    set_safe_search_off(driver)

    # Perform search again with safe search off
    perform_search(driver)

    # Scroll through 'More Results' if requested
    for _ in range(num_more_results):
        try:
            more_results_button = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.ID, "more-results"))
            )
            more_results_button.click()
        except TimeoutException:
            print("Failed to click the 'More Results' button.")

    # Get and filter the links
    links = get_search_result_links(driver)
    filtered_links = set(filter(lambda link: link.startswith("http"), links))

    # Print the links (optional)
    for link in filtered_links:
        print(f"Link: {link}")

    driver.quit()

    return filtered_links

File: TOOL_MANAGER.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT4 try this\TOOL_MANAGER.py)
Content (First 158 lines):
## File: TOOL_MANAGER.py (in: C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\AGI_start_4)
import os
import importlib
from typing import Dict, Callable, List, Any
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class Tool:
    """Represents a tool that can be used by the AI agent."""

    def __init__(self, name: str, function: Callable, description: str, arguments: Dict[str, str], tool_type: str):
        """
        Initializes a Tool object.

        Args:
            name: The name of the tool.
            function: The callable function that implements the tool.
            description: A brief description of the tool's functionality.
            arguments: A dictionary mapping argument names to their descriptions.
            tool_type: The type of the tool (e.g., 'os', 'web', 'focus').
        """
        self.name = name
        self.function = function
        self.description = description
        self.arguments = arguments
        self.tool_type = tool_type

    def __repr__(self):
        """Returns a string representation of the Tool object."""
        return f"Tool(name='{self.name}', function={self.function.__name__}, description='{self.description}', arguments={self.arguments}, tool_type='{self.tool_type}')"


class ToolManager:
    """Manages and provides access to tools."""

    def __init__(self, tools_folder: str):
        """
        Initializes the ToolManager with the path to the tools folder.

        Args:
            tools_folder: The path to the directory containing tool files.
        """
        self.tools_folder = tools_folder
        self.tools = {}  # Dictionary to store Tool objects
        self.load_tools()

    def load_tools(self):
        """Loads tools from files in the specified tools folder."""
        logger.info(f"Loading tools from: {self.tools_folder}")
        for root, _, files in os.walk(self.tools_folder):
            for file in files:
                if file.endswith(".py"):
                    # Extract tool name from file name
                    tool_name = file[:-3]  # Remove .py extension
                    module_path = os.path.join(root, file)

                    # Import the module
                    try:
                        spec = importlib.util.spec_from_file_location(tool_name, module_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                    except Exception as e:
                        logger.error(f"Error loading tool file '{file}': {e}")
                        continue

                    # Add the tool to the dictionary if it's a function
                    for attr_name in dir(module):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Get the tool name from the function name
                            tool_name = attr_name

                            # Construct the tool path for the main loop to use
                            relative_path = os.path.relpath(module_path, self.tools_folder)

                            # Define tool descriptions and arguments (you might want to customize these)
                            tool_description = f"Tool for {tool_name}"
                            tool_arguments = {
                                'file_path': 'The path to the file',
                                'content': 'The content to be saved',
                                # Add more arguments as needed for specific tools
                            }

                            # Get the tool type from the file (assuming it's a variable named 'tool_type_for_TOOL_MANAGER')
                            tool_type = getattr(module, 'tool_type_for_TOOL_MANAGER', 'unknown')

                            # Store Tool object for better information
                            self.tools[tool_name] = Tool(tool_name, attr, tool_description, tool_arguments, tool_type)

                            logger.info(f"Discovered tool: {tool_name} (Type: {tool_type})")
                            print(f"  - {tool_name} - {tool_description}")  # Add a nice print statement
                            logger.debug(f"Tool description: {tool_description}")
                            logger.debug(f"Tool arguments: {tool_arguments}")

    def get_tool_function(self, function_name: str) -> Callable:
        """Returns the callable object for the given function name."""
        tool = self.tools.get(function_name)
        if tool:
            return tool.function
        else:
            return None

    def get_all_tools(self) -> List[Tool]:
        """Returns a list of all loaded tools."""
        return list(self.tools.values())

    def get_tools_by_type(self, tool_type: str) -> List[Tool]:
        """Returns a list of tools based on their type."""
        return [tool for tool in self.tools.values() if tool.tool_type == tool_type]

    def load_tools_of_type(self, tool_type: str = "all") -> List[Callable]:
        """Loads and returns a list of tool functions based on the specified type.

        Args:
            tool_type: The type of tools to load. 'all' for all tools, or a specific type like 'os', 'web', etc.

        Returns:
            A list of tool functions.
        """
        if tool_type == "all":
            return [tool.function for tool in self.tools.values()]
        else:
            return [tool.function for tool in self.tools.values() if tool.tool_type == tool_type]

    def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """
        Calls the tool function with the provided arguments.

        Args:
            tool_name: The name of the tool to call.
            arguments: A dictionary of arguments to pass to the tool function.

        Returns:
            The result of the tool function call.

        Raises:
            KeyError: If the tool name is not found.
            TypeError: If the provided arguments are not valid for the tool.
        """
        tool = self.tools.get(tool_name)
        if tool is None:
            raise KeyError(f"Tool '{tool_name}' not found.")

        # Check if all required arguments are provided
        missing_args = set(tool.arguments.keys()) - set(arguments.keys())
        if missing_args:
            raise TypeError(f"Missing arguments for tool '{tool_name}': {', '.join(missing_args)}")

        # Call the tool function
        try:
            result = tool.function(**arguments)
            return result
        except Exception as e:
            raise RuntimeError(f"Error calling tool '{tool_name}': {e}")

