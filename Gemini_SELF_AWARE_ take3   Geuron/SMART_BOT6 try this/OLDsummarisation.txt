## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this'


Subdirectory: CONFIG
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\CONFIG'

File: config.json (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\CONFIG\config.json)
Content (First 50 lines):
 {
        "loop_type": "fixed",  # or "infinite"
        "num_loops": 5,
        "max_loops": 15,
        "models": [
            {
                "model_ID": "retrospection",
                "model_name": "gemini-1.5-pro-exp-0801",
                "system_instruction": "You are a self-aware AI reflecting on past experiences and current state. Analyze the 'Previous Context' to identify successes, failures, and areas for improvement. Consider your goals and how your actions have affected progress.",
                "allowed_tools": ["all"],
                "prompt_injector": "",
                "loadFocus": "True",
                "generateAudio": False,
                "useFlags": False
            },
            {
                "model_ID": "reasoning_planning",
                "model_name": "gemini-1.5-pro-exp-0801",
                "system_instruction": "You are a strategic AI responsible for reasoning and planning. Given the 'Previous Context', including the introspection, devise a plan of action for the next loop. Clearly outline specific objectives, the tools you'll use, and the expected outcomes. Prioritize tasks and consider potential challenges.",
                "allowed_tools": ["all"],
                "prompt_injector": "",
                "loadFocus": "True",
                "generateAudio": False,
                "useFlags": False
            },
            {
                "model_ID": "action",
                "model_name": "gemini-1.5-pro-exp-0801",
                "system_instruction": "You are an action-oriented AI. Execute the plan defined in the 'Previous Context'. Utilize your available tools and adapt to unexpected situations. Provide detailed reports of your actions and their results.",
                "allowed_tools": ["all"],
                "prompt_injector": "",
                "loadFocus": "True",
                "generateAudio": False,
                "useFlags": True,
                "flagTypes": ["STOP_FLAGS"],
                "STOP_FLAGS_instruction": "If you encounter a critical issue or achieve your primary objective, use the following format to stop: !///STOP///!STOP!///reason",
                "STOP_FLAGS_pattern": r"!///STOP///!STOP!///(.*)"
            },
            {
                "model_ID": "summarization",
                "model_name": "gemini-1.5-pro-exp-0801",
                "system_instruction": "You are an AI summarizing the events of a loop. Analyze the 'Previous Context' to create a concise summary of actions taken, results achieved, and any significant events. Include key insights and outcomes.",
                "allowed_tools": [],
                "prompt_injector": "",
                "loadFocus": "True",
                "generateAudio": False,
                "useFlags": False
            }
        ]
    }

File: Gemini_Geuron_chain_ RUN THIS.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\Gemini_Geuron_chain_ RUN THIS.py)
Content (First 336 lines):
import time
import os
import json
import re
import google.generativeai as genai
from typing import Dict, List, Any, Tuple
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import sys
import logging
import base64
import cv2

logging.basicConfig(filename='geuron.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

from TOOL_MANAGER import ToolManager
from tools.ai.update_focus import update_focus
from tools.os.update_own_config import update_own_config

from keys import googleKey as API_KEY

genai.configure(api_key=API_KEY)

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
FOCUS_FILE_PATH = os.path.join(CURRENT_DIR, "focus", "session_{}.json")
PERCEPTION_OUTPUT_DIR = os.path.join(CURRENT_DIR, "perception_output")
CONFIG_DIR = "CONFIG"  # Directory to store configurations
INITIAL_CONFIG_FILE = "Initial_Config.json"  # Initial configuration file
CURRENT_CONFIG_FILE = "Current_Config.json"  # Current configuration file

import google.cloud.texttospeech as tts


def generate_audio_tts(text: str, output_file: str, language_code: str = "en-US", voice_name: str = None) -> str:
    try:
        client = tts.TextToSpeechClient()
        synthesis_input = tts.SynthesisInput(text=text)
        voice = tts.VoiceSelectionParams(language_code=language_code, name=voice_name)
        audio_config = tts.AudioConfig(audio_encoding=tts.AudioEncoding.MP3)
        response = client.synthesize_speech(input=synthesis_input, voice=voice, audio_config=audio_config)

        with open(output_file, "wb") as out:
            out.write(response.audio_content)

        return output_file

    except Exception as e:
        return f"Error generating audio: {e}"


def loadConfig(config_file=CURRENT_CONFIG_FILE):
    """Loads the configuration from the specified file.

    Args:
        config_file (str, optional): The name of the configuration file to load. Defaults to "Current_Config.json".

    Returns:
        dict: The loaded configuration.
    """
    config_path = os.path.join(CONFIG_DIR, config_file)
    if not os.path.exists(config_path):
        if config_file == CURRENT_CONFIG_FILE:
            # Create a default Current_Config.json based on Initial_Config.json
            create_default_current_config()
        else:
            return None  # Or raise an exception if the specified config doesn't exist

    with open(config_path, "r") as f:
        return json.load(f)


def create_default_current_config():
    """Creates a default Current_Config.json based on Initial_Config.json."""
    initial_config = loadConfig(INITIAL_CONFIG_FILE)
    if initial_config:
        with open(os.path.join(CONFIG_DIR, CURRENT_CONFIG_FILE), "w") as f:
            json.dump(initial_config, f, indent=4)


class Geuron_Gemini:
    def save_data(self, data: Any, file_path: str):
        logging.info(f"Saving data to: {file_path}")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=4)
        except Exception as e:
            logging.error(f"Error saving data: {e}")

    def create_session_name(self):
        return f"session_{time.strftime('%Y%m%d_%H%M%S')}"

    def CreateGeuronFocusFile(self, path, name):
        return os.path.join(path, f"GeuronFocus_{name}.json")

    def __init__(self):
        self.session_name = self.create_session_name()
        self.focus_file_path = FOCUS_FILE_PATH.format(self.session_name)
        self.tools_folder = "tools"
        self.tool_manager = ToolManager(self.tools_folder)
        genai.configure(api_key=API_KEY)

        os.makedirs(os.path.dirname(self.focus_file_path), exist_ok=True)

        self.focus = {
            "current_focus": "Description of the current focus or task",
            "focus_strength": 0.8,
            "importance": 0.9,
            "progress": 0.5,
            "frustration": 0.1,
            "additional": "none",
            "verbose": "normal"
        }
        self.save_data(self.focus, self.focus_file_path)

        self.geuronFocusPath = self.CreateGeuronFocusFile(
            os.path.join(CURRENT_DIR, "focus"), self.session_name
        )

    def print_colored(self, color, text):
        print(color + text + self.Color.ENDC)

    def scrape_website(self, url: str, extract_links: bool = True, extract_images: bool = True,
                       extract_text: bool = True) -> Dict[str, Any]:
        logging.info(f"Scraping website: {url}")
        scraped_data = {}
        options = webdriver.ChromeOptions()
        options.add_argument("--headless=new")
        driver = webdriver.Chrome(options=options)
        driver.get(url)

        try:
            WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))

            if extract_links:
                scraped_data["links"] = [link.get_attribute("href") for link in driver.find_elements(By.TAG_NAME, "a")]

            if extract_images:
                scraped_data["images"] = [img.get_attribute("src") for img in driver.find_elements(By.TAG_NAME, "img")]

            if extract_text:
                scraped_data["text"] = driver.find_element(By.TAG_NAME, "body").text

        except TimeoutException:
            logging.error(f"Timeout: Page loading took too long for {url}")
        except Exception as e:
            logging.error(f"Web scraping error: {e}")
        finally:
            driver.quit()

        logging.info(f"Finished scraping: {url}")
        return scraped_data

    def extract_text_from_response(self, response) -> str:
        return "".join([part.text for candidate in response.candidates for part in candidate.content.parts]).strip()

    def interpret_function_calls(self, response, tool_manager, focus_file_path=None):
        results = []

        if hasattr(response, "candidates"):
            for candidate in response.candidates:
                if hasattr(candidate, "content") and hasattr(candidate.content, "parts"):
                    for part in candidate.content.parts:
                        function_call = getattr(part, "function_call", None)
                        if function_call:
                            tool_name = function_call.name
                            tool_function = tool_manager.get_tool_function(tool_name)

                            if tool_function:
                                function_args = function_call.args

                                if tool_name == "update_focus":
                                    if focus_file_path:
                                        function_args["focus_file_path"] = focus_file_path
                                    elif "focus_file_path" in function_call.args:
                                        function_args["focus_file_path"] = function_call.args["focus_file_path"]
                                    else:
                                        raise ValueError("No focus_file_path provided for update_focus")

                                try:
                                    logging.info(f"Executing function: {tool_name} with args: {function_args}")
                                    result = tool_function(**function_args)

                                    if tool_name in ("load_image", "load_images", "load_audio", "load_video"):
                                        if result["status"] == "success":
                                            if "image_data" in result:
                                                _, image_encoded = cv2.imencode('.jpg', result["image_data"])
                                                result["image_data_base64"] = base64.b64encode(image_encoded).decode(
                                                    'utf-8')
                                            elif "loaded_images" in result:
                                                for img_data in result["loaded_images"]:
                                                    _, img_encoded = cv2.imencode('.jpg', img_data["image_data"])
                                                    img_data["image_data_base64"] = base64.b64encode(img_encoded).decode(
                                                        'utf-8')
                                            elif "audio_data" in result:
                                                result["audio_data_base64"] = base64.b64encode(
                                                    result["audio_data"]).decode('utf-8')
                                            elif "video_data" in result:
                                                result["video_data_base64"] = base64.b64encode(
                                                    result["video_data"]).decode('utf-8')

                                    results.append(f"Result of {tool_name}({function_args}): {result}")
                                except Exception as e:
                                    results.append(f"Error calling {tool_name}: {e}")
                            else:
                                results.append(f"Tool function '{tool_name}' not found.")

        return results

    def load_focus_file(self, file_path):
        try:
            with open(file_path, "r") as f:
                focus_data = json.load(f)
                return focus_data
        except FileNotFoundError:
            logging.error(f"Focus file not found: {file_path}")
            return {}
        except Exception as e:
            logging.error(f"Error loading focus file: {e}")
            return {}

    def run_chained_models(self, models_config: List[Dict], input_data: Dict[str, Any] = None, max_loops: int = None):
        context = ""
        current_loop = 0
        loop_type = models_config.get("loop_type", "fixed")
        num_loops = models_config.get("num_loops", 1)
        max_loops = models_config.get("max_loops", None)

        while (loop_type == "infinite" or current_loop < num_loops) and (max_loops is None or current_loop < max_loops):
            time.sleep(5)
            logging.info(f"------------Loop {current_loop} --------------------------------------------------")

            for model_config in models_config["models"]:
                model_ID = model_config["model_ID"]
                logging.info(f"Model ID: {model_ID}")

                loadFocus = model_config["loadFocus"]
                model_name = model_config["model_name"]
                system_instruction = model_config["system_instruction"]
                allowed_tools = model_config["allowed_tools"]
                prompt_injector = model_config.get("prompt_injector", "")
                generateAudio = model_config.get("generateAudio", False)

                use_flags = model_config.get("useFlags", False)
                if use_flags:
                    flag_instruction = model_config.get("STOP_FLAGS_instruction", "")
                    prompt = f"\n{flag_instruction}"

                model = genai.GenerativeModel(
                    model_name=model_name,
                    safety_settings={"HARASSMENT": "block_none"},
                    system_instruction=system_instruction,
                    tools=self.tool_manager.load_tools_of_type(allowed_tools),
                )

                model_chat = model.start_chat(history=[])

                prompt = f"Previous Context: {context}\n{prompt_injector}"
                if loadFocus == "True":
                    focus_data = self.load_focus_file(self.focus_file_path)
                    prompt += f"\nCurrent Focus: {focus_data}"

                try:
                    logging.info(f"Sending message to {model_name}...")

                    response = model_chat.send_message(prompt)
                    text = self.extract_text_from_response(response)
                    logging.info(f"{model_name} Response: {text}")

                    if allowed_tools:
                        function_results = self.interpret_function_calls(
                            response, self.tool_manager, focus_file_path=self.focus_file_path
                        )
                        logging.info(f"Function Calls: {function_results}")
                        text += f"\nFunction Results: {function_results}"

                    if generateAudio and text is not None:
                        audio_file_path = os.path.join(
                            PERCEPTION_OUTPUT_DIR, self.session_name, f"{self.session_name}_loop{current_loop}_{model_ID}.mp3"
                        )
                        generate_audio_tts(text, audio_file_path)
                        logging.info(f"Audio generated and saved to: {audio_file_path}")

                    if use_flags:
                        flag_pattern = model_config.get("STOP_FLAGS_pattern", None)
                        if flag_pattern:
                            match = re.search(flag_pattern, text)
                            if match:
                                flag_value = match.group(1).strip()
                                logging.info(f"Stopping loop due to STOP flag: {flag_value}")
                                return context

                    context += f"\n{text}\nFunction Results: {function_results}"

                except Exception as e:
                    logging.error(f"Error in {model_name}: {e}")

            current_loop += 1

            # Reload the config after each loop
            models_config = loadConfig()  # Load Current_Config.json by default

        logging.info("Exiting the loop.")
        return context


class Color:
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKCYAN = "\033[96m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"
    PURPLE = "\033[95m"
    MAGENTA = "\033[35m"
    YELLOW = "\033[33m"
    CYAN = "\033[36m"
    RED = "\033[31m"



if __name__ == "__main__":
    runner = Geuron_Gemini()
    urls_to_scrape = []

    # Load the configuration here before starting the loop
    models_config = loadConfig()

    # The initial models_config is loaded at the start
    runner.run_chained_models(models_config)

File: Geuron_Idea (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\Geuron_Idea)
Content (First 0 lines):


File: keys.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\keys.py)
Content (First 1 lines):
googleKey='AIzaSyBAllpiXbRl9xKyQ8N5kVtyU0FtPUukX-s'


Subdirectory: KNOWLAGE_BASE
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\KNOWLAGE_BASE'


Subdirectory: MEDIA
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\MEDIA'


Subdirectory: MEMORY
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\MEMORY'


Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools'


Subdirectory: ai
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\ai'

File: update_focus.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\ai\update_focus.py)
Content (First 72 lines):
tool_type_for_TOOL_MANAGER = "focus"

update_focus_short_description = """ Updates the focus file with new focus information."""

import json
import os


def update_focus(
    new_focus: str,
    focus_file_path: str,
    category: str = None,
    frustration_level: int = None,
    focus_strength: int = None,
    defocus_threshold: int = None,
    importance: float = None,  # Added importance parameter
    progress: float = None,  # Added progress parameter
    additional: str = None,  # Added additional parameter
    verbose: str = None   # Added verbose parameter
) -> dict:
    """
    Updates the focus file with new focus information.

    Args:
        new_focus (str): The new focus text to be added to the focus file.
        focus_file_path (str): The path to the focus file to be updated.
        category (str, optional): The category of the focus (e.g., "Research", "Task", "Goal"). Defaults to None.
        frustration_level (int, optional): A level indicating the current frustration level (0-10). Defaults to None.
        focus_strength (int, optional): A level indicating the strength of the focus (0-10). Defaults to None.
        defocus_threshold (int, optional): A level indicating the threshold at which the focus should be considered defocused (0-10). Defaults to None.
        importance (float, optional): Importance of the focus (0-1). Defaults to None.
        progress (float, optional): Progress on the focus (0-1). Defaults to None.
        additional (str, optional): Additional information about the focus. Defaults to None.
        verbose (str, optional): Verbosity level of the focus (e.g., "normal", "detailed"). Defaults to None.


    Returns:
        dict: A dictionary containing the status of the operation, a message, and the updated focus text.
    """

    try:
        # Read the existing focus from the file
        with open(focus_file_path, "r") as f:
            focus_data = json.load(f)

        # Update the focus data with new values
        focus_data["current_focus"] = new_focus
        if frustration_level is not None:
            focus_data["frustration"] = frustration_level / 10.0  # Convert to 0-1 scale
        if focus_strength is not None:
            focus_data["focus_strength"] = focus_strength / 10.0  # Convert to 0-1 scale
        if importance is not None:
            focus_data["importance"] = importance
        if progress is not None:
            focus_data["progress"] = progress
        if additional is not None:
            focus_data["additional"] = additional
        if verbose is not None:
            focus_data["verbose"] = verbose

        # Write the updated focus back to the file
        with open(focus_file_path, "w") as f:
            json.dump(focus_data, f, indent=4)

        return {
            "status": "success",
            "message": f"Focus updated with: '{new_focus}'",
            "updated_focus": focus_data,
        }

    except Exception as e:
        return {"status": "failure", "message": f"Error updating focus: {str(e)}"}

File: update_own_config.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\ai\update_own_config.py)
Content (First 58 lines):
# tools/os/update_own_config.py
tool_type_for_TOOL_MANAGER = "os"
update_own_config_short_description = """Updates the AI's own configuration file (config.json)."""

import json
import os

def update_own_config(config_path: str = "CONFIG/config.json", **kwargs) -> dict:
    """
    Updates the AI's own configuration file (config.json).

    Available Parameters:

    General Parameters:
        - loop_type (str): Type of loop ('fixed' or 'infinite').
        - num_loops (int): Number of loops to execute in a 'fixed' loop.
        - max_loops (int): Maximum number of loops allowed, even in an 'infinite' loop.

    Model-Specific Parameters (for each model in the `models` list):
        - model_ID (str): Unique identifier for the model.
        - model_name (str): Name of the Gemini Pro model to use (e.g., "gemini-1.5-pro-exp-0801").
        - system_instruction (str): System instructions for the model, guiding its behavior.
        - allowed_tools (list): List of allowed tool names for the model (e.g., ["all", "web", "os"]).
        - prompt_injector (str): Text to be injected into the prompt before sending it to the model.
        - loadFocus (bool): Whether to load the focus data for the model.
        - generateAudio (bool): Whether to generate audio output for the model's responses.
        - useFlags (bool): Whether to use flags for controlling loop termination (e.g., STOP flags).
        - flagTypes (list): List of flag types to use (e.g., ["STOP_FLAGS"]).
        - STOP_FLAGS_instruction (str): Instructions for how to use STOP flags.
        - STOP_FLAGS_pattern (str): Regular expression pattern for detecting STOP flags.

    Args:
        config_path (str, optional): Path to the config.json file. Defaults to "CONFIG/config.json".
        **kwargs: Key-value pairs representing the configuration parameters to be updated.

    Returns:
        dict: A dictionary containing the status of the operation and a message.
    """
    try:
        with open(config_path, "r") as f:
            config = json.load(f)

        for key, value in kwargs.items():
            # Basic validation (you might want to add more robust validation)
            if key == "loop_type" and value not in ["fixed", "infinite"]:
                return {"status": "failure", "message": "Invalid loop_type. Must be 'fixed' or 'infinite'."}

            # For model-specific parameters, you'll need to iterate through the `models` list
            # and find the model with the matching `model_ID` to update its parameters.

            config[key] = value

        with open(config_path, "w") as f:
            json.dump(config, f, indent=4)

        return {"status": "success", "message": f"Configuration updated successfully."}
    except Exception as e:
        return {"status": "failure", "message": f"Error updating configuration: {str(e)}"}


Subdirectory: os
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os'

File: get_directory_structure.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\get_directory_structure.py)
Content (First 27 lines):
tool_type_for_TOOL_MANAGER = "os"
get_directory_structure_short_description= """get_directory_structure"""
import  os
import  json

def get_directory_structure(directory):

    print("Entered get_directory_structure function with directory:", directory)
    directory_structure = {}

    for root, dirs, files in os.walk(directory):
        file_info = []
        for file in files:
            file_path = os.path.join(root, file)
            file_info.append({
                'filename': file,
                'size': os.path.getsize(file_path),
                'relative_path': os.path.relpath(file_path, directory),
                'full_path': file_path
            })
        directory_structure[os.path.relpath(root, directory)] = {
            'files': file_info,
            'folders': dirs
        }

    print("About to return the directory structure with", len(directory_structure), "folders.")
    return directory_structure

File: load_audio.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\load_audio.py)
Content (First 16 lines):
tool_type_for_TOOL_MANAGER = "all"
load_audio_short_description= """Loads an audio file from the specified path."""



# You might need to install pydub: pip install pydub
from pydub import AudioSegment

def load_audio(audio_path: str) -> dict:
    """Loads an audio file from the specified path."""
    try:
        audio = AudioSegment.from_file(audio_path)
        audio_bytes = audio.raw_data  # Get raw audio bytes
        return {"status": "success", "audio_data": audio_bytes, "audio_path": audio_path}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading audio: {str(e)}"}

File: load_images.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\load_images.py)
Content (First 19 lines):
tool_type_for_TOOL_MANAGER="all"

load_images_short_description=""" Loads multiple images from the specified paths """

def load_images(image_paths: list) -> dict:
    """Loads multiple images from the specified paths."""
    loaded_images = []
    failed_paths = []
    try:
        import cv2
        for path in image_paths:
            image = cv2.imread(path)
            if image is not None:
                loaded_images.append({"image_data": image, "image_path": path})
            else:
                failed_paths.append(path)
        return {"status": "success", "loaded_images": loaded_images, "failed_paths": failed_paths}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading images: {str(e)}"}

File: load_video.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\load_video.py)
Content (First 26 lines):
tool_type_for_TOOL_MANAGER = "all"
load_video_short_description = """Loads a video file from the specified path."""

import cv2
import base64

def load_video(video_path: str) -> dict:
    """Loads a video file from the specified path and returns its base64 encoded data."""
    try:
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            return {"status": "failure", "message": f"Error opening video file: {video_path}"}

        frames = []
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            _, frame_encoded = cv2.imencode('.jpg', frame)
            frames.append(frame_encoded)

        cap.release()
        video_data_base64 = base64.b64encode(b''.join(frames)).decode('utf-8')
        return {"status": "success", "video_data": video_data_base64, "video_path": video_path}
    except Exception as e:
        return {"status": "failure", "message": f"Error loading video: {str(e)}"}

File: tool_read_from_file.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\tool_read_from_file.py)
Content (First 24 lines):
tool_type_for_TOOL_MANAGER="all"


tool_read_from_file_short_description=""" Reads content from a file. 
        """

def tool_read_from_file(file_path: str, encoding: str = 'utf-8', mode: str = 'r') -> str:
    """
    Reads content from a file.

    Args:
        file_path (str): The path to the file to be read.
        encoding (str, optional): The encoding of the file. Defaults to 'utf-8'.
        mode (str, optional): The mode to open the file in. Defaults to 'r' (read).

    Returns:
        str: The content of the file, or an error message if the file cannot be read.
    """
    try:
        with open(file_path, mode, encoding=encoding) as f:
            content = f.read()
        return content
    except Exception as e:
        return f"Error reading file: {str(e)}"

File: tool_save_to_file.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\os\tool_save_to_file.py)
Content (First 46 lines):
tool_type_for_TOOL_MANAGER="os"
tool_save_to_file_short_description="Saves content to a file with the specified name and path."
import  os


def tool_save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None, encoding: str = 'utf-8', create_folders: bool = True) -> dict:
    """
    Saves content to a file with the specified name and path.

    Args:
        content (str, optional): The content to be written to the file. Defaults to None, which will write an empty string.
        file_name (str, optional): The name of the file to be created. Defaults to 'NoName'.
        file_path (str, optional): The path to the directory where the file should be created. If None, the current working directory will be used. Defaults to None.
        encoding (str, optional): The encoding to use for the file. Defaults to 'utf-8'.
        create_folders (bool, optional): Whether to create missing folders in the file path. Defaults to True.

    Returns:
        dict: A dictionary containing the status of the operation, a message, and the full path to the file.
    """

    print(f"Entering: save_to_file(...)", 'blue')
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    # Create folders if they don't exist
    if create_folders:
        os.makedirs(os.path.dirname(full_path), exist_ok=True)

    try:
        with open(full_path, 'w', encoding=encoding) as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(success_message, 'green')
        print(f"Exiting: save_to_file(...)", 'blue')
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(error_message, 'red')
        print(f"Exiting: save_to_file(...)", 'blue')
        return {"status": "failure", "message": error_message}


Subdirectory: web
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\web'

File: get_duckduckgo_links.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\tools\web\get_duckduckgo_links.py)
Content (First 102 lines):
tool_type_for_TOOL_MANAGER="all"


get_duckduckgo_links_short_description="""Retrieves DuckDuckGo search result links with the option to disable safe search
    and scroll through 'More Results'"""


def get_duckduckgo_links(search_phrase, num_more_results=0):
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException

    """
    Retrieves DuckDuckGo search result links with the option to disable safe search
    and scroll through 'More Results'.

    Args:
        search_phrase (str): The search query to use.
        num_more_results (int): The number of times to click the 'More Results' button.

    Returns:
        set: A set of unique links from the DuckDuckGo search results.
    """
    def perform_search(driver):
        search_input = driver.find_element(By.NAME, "q")
        search_input.send_keys(search_phrase)
        search_input.submit()

    def set_safe_search_off(driver):
        try:
            # Click the Safe Search dropdown button
            safe_search_dropdown_button = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".dropdown--safe-search .dropdown__button.js-dropdown-button"))
            )
            safe_search_dropdown_button.click()

            # Find the "Safe Search: Off" option and click it
            safe_search_off_option = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".modal--dropdown--safe-search a[data-value='-2']"))
            )
            safe_search_off_option.click()

            # Click outside the dropdown menu to close it
            overlay = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, ".modal__overlay.js-modal-close"))
            )
            overlay.click()

        except TimeoutException:
            print("TimeoutException occurred while setting safe search off..")

    def get_search_result_links(driver):
        try:
            search_results = WebDriverWait(driver, 2).until(
                EC.presence_of_all_elements_located((By.CSS_SELECTOR, "a[href]"))
            )
            # Filter links to exclude those containing "duckduckgo"
            links = [link.get_attribute("href") for link in search_results if "duckduckgo" not in link.get_attribute("href")]
            return links
        except TimeoutException:
            print("TimeoutException occurred while waiting for search result links.")
            return []

    # Create a ChromeDriver instance
    driver = webdriver.Chrome()

    # Navigate to DuckDuckGo
    url = "https://duckduckgo.com/"
    driver.get(url)

    # Perform initial search (safe search might be on by default)
    perform_search(driver)

    # Disable safe search
    set_safe_search_off(driver)

    # Perform search again with safe search off
    perform_search(driver)

    # Scroll through 'More Results' if requested
    for _ in range(num_more_results):
        try:
            more_results_button = WebDriverWait(driver, 1).until(
                EC.element_to_be_clickable((By.ID, "more-results"))
            )
            more_results_button.click()
        except TimeoutException:
            print("Failed to click the 'More Results' button.")

    # Get and filter the links
    links = get_search_result_links(driver)
    filtered_links = set(filter(lambda link: link.startswith("http"), links))

    # Print the links (optional)
    for link in filtered_links:
        print(f"Link: {link}")

    driver.quit()

    return filtered_links

File: TOOL_MANAGER.py (C:\Users\DELL\Desktop\self_aware_gemini\SelAwareAI_Gemini\Gemini_SELF_AWARE_ take3   Geuron\SMART_BOT6 try this\TOOL_MANAGER.py)
Content (First 158 lines):
## File: TOOL_MANAGER.py (in: C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\AGI_start_4)
import os
import importlib
from typing import Dict, Callable, List, Any
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class Tool:
    """Represents a tool that can be used by the AI agent."""

    def __init__(self, name: str, function: Callable, description: str, arguments: Dict[str, str], tool_type: str):
        """
        Initializes a Tool object.

        Args:
            name: The name of the tool.
            function: The callable function that implements the tool.
            description: A brief description of the tool's functionality.
            arguments: A dictionary mapping argument names to their descriptions.
            tool_type: The type of the tool (e.g., 'os', 'web', 'focus').
        """
        self.name = name
        self.function = function
        self.description = description
        self.arguments = arguments
        self.tool_type = tool_type

    def __repr__(self):
        """Returns a string representation of the Tool object."""
        return f"Tool(name='{self.name}', function={self.function.__name__}, description='{self.description}', arguments={self.arguments}, tool_type='{self.tool_type}')"


class ToolManager:
    """Manages and provides access to tools."""

    def __init__(self, tools_folder: str):
        """
        Initializes the ToolManager with the path to the tools folder.

        Args:
            tools_folder: The path to the directory containing tool files.
        """
        self.tools_folder = tools_folder
        self.tools = {}  # Dictionary to store Tool objects
        self.load_tools()

    def load_tools(self):
        """Loads tools from files in the specified tools folder."""
        logger.info(f"Loading tools from: {self.tools_folder}")
        for root, _, files in os.walk(self.tools_folder):
            for file in files:
                if file.endswith(".py"):
                    # Extract tool name from file name
                    tool_name = file[:-3]  # Remove .py extension
                    module_path = os.path.join(root, file)

                    # Import the module
                    try:
                        spec = importlib.util.spec_from_file_location(tool_name, module_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                    except Exception as e:
                        logger.error(f"Error loading tool file '{file}': {e}")
                        continue

                    # Add the tool to the dictionary if it's a function
                    for attr_name in dir(module):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Get the tool name from the function name
                            tool_name = attr_name

                            # Construct the tool path for the main loop to use
                            relative_path = os.path.relpath(module_path, self.tools_folder)

                            # Define tool descriptions and arguments (you might want to customize these)
                            tool_description = f"Tool for {tool_name}"
                            tool_arguments = {
                                'file_path': 'The path to the file',
                                'content': 'The content to be saved',
                                # Add more arguments as needed for specific tools
                            }

                            # Get the tool type from the file (assuming it's a variable named 'tool_type_for_TOOL_MANAGER')
                            tool_type = getattr(module, 'tool_type_for_TOOL_MANAGER', 'unknown')

                            # Store Tool object for better information
                            self.tools[tool_name] = Tool(tool_name, attr, tool_description, tool_arguments, tool_type)

                            logger.info(f"Discovered tool: {tool_name} (Type: {tool_type})")
                            print(f"  - {tool_name} - {tool_description}")  # Add a nice print statement
                            logger.debug(f"Tool description: {tool_description}")
                            logger.debug(f"Tool arguments: {tool_arguments}")

    def get_tool_function(self, function_name: str) -> Callable:
        """Returns the callable object for the given function name."""
        tool = self.tools.get(function_name)
        if tool:
            return tool.function
        else:
            return None

    def get_all_tools(self) -> List[Tool]:
        """Returns a list of all loaded tools."""
        return list(self.tools.values())

    def get_tools_by_type(self, tool_type: str) -> List[Tool]:
        """Returns a list of tools based on their type."""
        return [tool for tool in self.tools.values() if tool.tool_type == tool_type]

    def load_tools_of_type(self, tool_type: str = "all") -> List[Callable]:
        """Loads and returns a list of tool functions based on the specified type.

        Args:
            tool_type: The type of tools to load. 'all' for all tools, or a specific type like 'os', 'web', etc.

        Returns:
            A list of tool functions.
        """
        if tool_type == "all":
            return [tool.function for tool in self.tools.values()]
        else:
            return [tool.function for tool in self.tools.values() if tool.tool_type == tool_type]

    def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:
        """
        Calls the tool function with the provided arguments.

        Args:
            tool_name: The name of the tool to call.
            arguments: A dictionary of arguments to pass to the tool function.

        Returns:
            The result of the tool function call.

        Raises:
            KeyError: If the tool name is not found.
            TypeError: If the provided arguments are not valid for the tool.
        """
        tool = self.tools.get(tool_name)
        if tool is None:
            raise KeyError(f"Tool '{tool_name}' not found.")

        # Check if all required arguments are provided
        missing_args = set(tool.arguments.keys()) - set(arguments.keys())
        if missing_args:
            raise TypeError(f"Missing arguments for tool '{tool_name}': {', '.join(missing_args)}")

        # Call the tool function
        try:
            result = tool.function(**arguments)
            return result
        except Exception as e:
            raise RuntimeError(f"Error calling tool '{tool_name}': {e}")

