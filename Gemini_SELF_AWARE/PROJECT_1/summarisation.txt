## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1'

File: artificial_memories_creation________DEVELOPER_TOOL.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\artificial_memories_creation________DEVELOPER_TOOL.py)
Content (First 736 lines):
import google.generativeai as genai
import os
import json
import re
from datetime import datetime
from collections import defaultdict
import time
import random
import pathlib



genai.configure(api_key='AIzaSyDRJJmMsB7WQXQ8P0mKTCHf9VIx5uprTw8')  # Replace with your actual API key
BLACK = "\033[30m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"
RESET = "\033[0m"


def sanitize_href(href, memories_folder_path):
    """Sanitizes a given href string by replacing spaces with %20."""
    href = href.replace(" ", "%20")  # Replace spaces with %20
    return href

def update_html_logs(memory_frame_number, proposed_name, timestamp, memory_frame_paths, memories_folder_path):
    """Updates the HTML log file with CORRECT absolute paths for href links."""
    try:
        log_file_path = os.path.join(memories_folder_path, 'Memory_logs.html')

        if not os.path.exists(log_file_path):
            with open(log_file_path, 'w') as log_file:
                log_file.write("""
                   <!DOCTYPE html>
                   <html>
                   <head>
                       <title>Memory Logs</title>
                   </head>
                   <body>
                       <h1>Memory Logs</h1>
                       <ul>
                   """)

        html_insertion = f"""
               <li><h2>Memory Frame {memory_frame_number:05d} - {proposed_name} ({timestamp})</h2></li>
               <ul>
           """

        for memory_frame_path in memory_frame_paths:
            # Calculate the relative path from the "memories" folder
            relative_path = os.path.relpath(memory_frame_path, memories_folder_path)

            # Construct the href using the relative path
            href = f'memories/{relative_path}'  # Correctly create the relative path

            html_insertion += f"""
                       <li><a href='{href}'>{os.path.basename(href)}</a></li> 
                   """

        html_insertion += "</ul>"

        with open(log_file_path, 'a') as log_file:
            log_file.write(html_insertion)

        print(f"{GREEN}HTML logs updated successfully.{RESET}")
    except Exception as e:
        print(f"Error updating HTML logs: {e}")




# --- Global Variables ---
MEMORY_FRAME_NUMBER = 1
EDIT_NUMBER = 0
counter = 0
TIMESTAMP_FORMAT = '%Y-%m-%d_%H-%M'
print(counter)


def Get_path_of_memories_folder():
    """Returns the absolute path to the 'memories' folder."""
    current = pathlib.Path.cwd()
    memories_path = current / "memories"
    return memories_path.absolute()


path_o_Memories_folder = Get_path_of_memories_folder()

# Example usage:
memories_folder = Get_path_of_memories_folder()
print(f"Memories folder path: {memories_folder}")











categories = [
  "animals"
]
def process_user_input():
    global counter
    global categories
    print(f"CREATION OF A  MEMORY = loop  number  {counter}")

    counter = counter + 1
    random_number = random.randint(1, 100)
    randomiser = random_number * random_number - counter + counter * counter
    randomiser_str = str(randomiser)

    prompt_construction = f"{counter} Important  information and  description  of {categories}    randomiser={randomiser_str} random  animal: dont aks  questions, choose only 1  animal "

    user_input = prompt_construction

    return user_input














def call_interaction_model(user_input, timestamp):
    print(f"\n{CYAN}--- Calling Interaction Model ---{RESET}")
    try:
        interaction_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction=""" you fallow user  orders"""
        )
        chat = interaction_model.start_chat(history=[])
        response = chat.send_message(f"currentTime: {timestamp} create {user_input}")
        print(f"AI Response: {response.text}")
        return response
    except Exception as e:
        print(f"Error in Interaction Model: {e}")
        return None


def call_memory_model(user_input, response1_text):
    print(f"\n{CYAN}--- Calling Memory Model ---{RESET}")
    try:
        memory_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction="""You are a sophisticated AI assistant helping to organize memories. 
                        Analyze and summarize the above user-AI conversation, focusing on elements that would be most useful for storing and retrieving this memory later. Don't hallucinate. 
                        Use the provided JSON schema for your response and fill in all fields with relevant information.
                        You can omit entries if they don't seem appropriate for memory storage and would be empty.
                        Never omit the "memory_folders_storage" entry.

                        **JSON Schema:**

                        ```json
                        {
                          "metadata": {
                            "creation_date": "", 
                            "source": "", 
                            "author": "" 
                          },
                          "type": "conversation", // OR "technical_concept" 
                          "core": {
                            "main_topic": "", 
                            "category": "", 
                            "subcategory": "", 
                            "memory_about": "" 
                          },
                          "summary": {
                            "concise_summary": "", 
                            "description": "" 
                          },
                          "content": {
                            "keywords": [], 
                            "entities": [], 
                            "tags": [], 
                            "observations": [], 
                            "facts": [], 
                            "contradictions": [], 
                            "paradoxes": [], 
                            "scientific_data": [], 
                            "visualizations": [] 
                          },
                          "interaction": {
                            "interaction_type": [], 
                            "people": [], 
                            "objects": [], 
                            "animals": [], 
                            "actions": [], 
                            "observed_interactions": [] 
                          },
                          "impact": {
                            "obtained_knowledge": "", 
                            "positive_impact": "", 
                            "negative_impact": "", 
                            "expectations": "", 
                            "strength_of_experience": "" 
                          },
                          "importance": {
                            "reason": "", 
                            "potential_uses": [], 
                            "importance_level": "0-100" 
                          },
                          "technical_details": {
                            "problem_solved": "", 
                            "concept_definition": "", 
                            "implementation_steps": [], 
                            "tools_and_technologies": [], 
                            "example_projects": [], 
                            "best_practices": [], 
                            "common_challenges": [], 
                            "debugging_tips": [], 
                            "related_concepts": [], 
                            "resources": [], 
                            "code_examples": [] 
                          },
                          "storage": {
                            "storage_method": "", 
                            "location": "", 
                            "memory_folders_storage": [
                              {
                                "folder_path": "", 
                                "probability": 0  
                              }
                            ],
                            "strength_of_matching_memory_to_given_folder": [] 
                          },
                          "naming_suggestion": {
                            "memory_frame_name": "Give  Same  meaning full name for  Memory File",
                            "explanation": "" 
                          }
                        }
                        ```
                        Here  you have  existing  folder structure  for  memory_folders_storage [{
                "Actions & Results": {
                    "Actions & Results": {
                        "Future": {},
                        "Past": {},
                        "Present": {}
                    }
                },
                "BaseFileStructure.txt": [],
                "Challenges & Setbacks": {
                    "Areas for Improvement": {},
                    "Difficult Emotions": {
                        "Anger & Frustration": {},
                        "Fear & Anxiety": {},
                        "Jealousy & Envy": {},
                        "Sadness & Grief": {},
                        "Shame & Guilt": {},
                        "Trauma & Abuse": {
                            "Experiences": {},
                            "Healing Journey": {},
                            "Impact": {}
                        }
                    },
                    "Failures & Disappointments": {
                        "In Career": {},
                        "In Personal Projects": {},
                        "In Relationships": {}
                    },
                    "Negative Thought Patterns": {},
                    "Significant Mistakes": {
                        "Description": {},
                        "How I Grew": {},
                        "Lessons Learned": {}
                    }
                },
                "CoreMemory": {
                    "Conceptual Exploration": {
                        "Contradictions & Dilemmas": {},
                        "Paradoxes & Contradictions": {},
                        "Unknowns & Mysteries": {}
                    },
                    "Core Experiences": {
                        "Challenges Faced": {
                            "External Challenges": {
                                "Obstacles": {
                                    "How I Overcame Them": {},
                                    "Types of Obstacles": {},
                                    "What I Learned": {}
                                },
                                "Setbacks": {
                                    "How I Recovered": {},
                                    "Types of Setbacks": {},
                                    "What I Learned": {}
                                }
                            },
                            "Internal Challenges": {
                                "Fear & Anxiety": {
                                    "How I Coped": {},
                                    "Specific Fears": {},
                                    "What I Learned": {}
                                },
                                "Negative Thought Patterns": {
                                    "Common Negative Thoughts": {},
                                    "Strategies for Changing Them": {},
                                    "What I Learned": {}
                                },
                                "Self-Doubt": {
                                    "How I Overcame It": {},
                                    "Sources of Self-Doubt": {},
                                    "What I Learned": {}
                                }
                            }
                        },
                        "Life-Changing Events": {
                            "Negative": {},
                            "Positive": {}
                        },
                        "Significant Moments": {
                            "Other": {},
                            "Personal": {},
                            "Professional": {},
                            "Travel": {}
                        },
                        "Triumphs & Accomplishments": {
                            "Creative Wins": {
                                "Creative Works": {},
                                "Impact on Life": {},
                                "Recognition & Awards": {}
                            },
                            "Personal Achievements": {
                                "Goals Achieved": {},
                                "Impact on Life": {},
                                "Personal Growth": {}
                            },
                            "Professional Successes": {
                                "Career Growth": {},
                                "Impact on Life": {},
                                "Projects & Achievements": {}
                            }
                        },
                        "Turning Points": {
                            "In Career": {},
                            "In Personal Growth": {},
                            "In Relationships": {},
                            "Other": {}
                        }
                    },
                    "Goals & Visions": {
                        "Life Vision": {
                            "Long-Term Goals": {},
                            "Mid-Term Goals": {},
                            "Short-Term Goals": {}
                        },
                        "Personal Goals": {
                            "Long-Term Goals": {},
                            "Mid-Term Goals": {},
                            "Short-Term Goals": {}
                        }
                    },
                    "Knowledge Base": {
                        "Areas of Expertise": {},
                        "Key Concepts & Theories": {},
                        "Personal Beliefs & Values": {}
                    },
                    "Reflections & Insights": {
                        "Lessons Learned": {
                            "From Mistakes": {},
                            "From Relationships": {},
                            "From Successes": {}
                        },
                        "Self-Discovery": {
                            "Areas for Growth": {},
                            "Strengths & Talents": {},
                            "What I've Learned About Myself": {}
                        }
                    },
                    "Relationships": {
                        "Family": {
                            "Extended Family": {
                                "Challenges Faced": {},
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Memorable Moments": {}
                            },
                            "Parents": {
                                "Challenges Faced": {},
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Memorable Moments": {}
                            },
                            "Siblings": {
                                "Challenges Faced": {},
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Memorable Moments": {}
                            }
                        },
                        "Friendships": {
                            "Circles & Groups": {
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Shared Experiences": {}
                            },
                            "Close Friends": {
                                "Challenges Faced": {},
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Memorable Moments": {}
                            },
                            "Meaningful Interactions": {
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Unexpected Encounters": {}
                            }
                        },
                        "Romantic Relationships": {
                            "Partners": {
                                "Challenges Faced": {},
                                "Impact on My Life": {},
                                "Lessons Learned": {},
                                "Memorable Moments": {}
                            },
                            "Relationship Milestones": {
                                "First Date": {},
                                "First Kiss": {},
                                "Marriage": {},
                                "Moving In Together": {},
                                "Other Milestones": {}
                            }
                        }
                    }
                },
                "Emotional Landscape": {
                    "Dominant Emotions": {},
                    "Emotional Triggers": {}
                },
                "Emotions & Reflections": {
                    "Emotional Experiences": {
                        "Dominant Emotions": {},
                        "Emotional Triggers": {}
                    },
                    "Personal Growth & Insights": {
                        "Lessons Learned": {},
                        "Self-Discovery": {}
                    }
                },
                "Goals & Aspirations": {
                    "Life Vision": {
                        "Aspirations": {},
                        "Dreams": {},
                        "Values & Beliefs": {}
                    },
                    "Personal Goals": {
                        "Creative Pursuits": {},
                        "Health & Wellbeing": {},
                        "Other Personal Goals": {},
                        "Personal Development": {},
                        "Relationships": {}
                    },
                    "Professional Goals": {
                        "Career Advancement": {},
                        "Other Professional Goals": {},
                        "Project Goals": {},
                        "Skills & Expertise": {}
                    }
                },
                "Knowledge & Learning": {
                    "Formal Education": {
                        "Degrees & Certifications": {},
                        "Schools": {},
                        "Significant Projects": {}
                    },
                    "Knowledge Base": {
                        "Artistic Movements": {},
                        "Cultural Insights": {},
                        "Facts & Concepts": {},
                        "Historical Events": {},
                        "Philosophical Ideas": {},
                        "Scientific Discoveries": {}
                    },
                    "Laws & Regulations": {
                        "Legal Knowledge": {},
                        "Personal Experiences with Laws": {},
                        "Understanding of Legal Systems": {}
                    },
                    "Self-Directed Learning": {
                        "Areas of Interest": {},
                        "Learning Resources": {
                            "Bookshelf": {},
                            "Mentors & Teachers": {},
                            "Online Courses": {}
                        },
                        "Skills Acquired": {}
                    }
                },
                "Life Events & Transitions": {
                    "Life Transitions": {
                        "Health & Wellbeing": {
                            "Habits & Routines": {},
                            "Mental & Emotional Health": {},
                            "Physical Health": {}
                        },
                        "Knowledge & Skills": {
                            "Formal Education": {},
                            "Self-Directed Learning": {},
                            "Skills & Expertise": {}
                        },
                        "Personal Growth": {
                            "Challenges Overcome": {},
                            "Milestones": {},
                            "Significant Decisions": {}
                        },
                        "Relationships": {
                            "Family Dynamics": {},
                            "Friendships": {},
                            "Professional Connections": {},
                            "Romantic Relationships": {}
                        }
                    },
                    "Significant Events": {
                        "Other": {},
                        "Personal": {
                            "Birthdays": {},
                            "Graduations": {},
                            "Other Personal Events": {},
                            "Weddings": {}
                        },
                        "Professional": {
                            "Job Changes": {},
                            "Other Professional Events": {},
                            "Project Completions": {},
                            "Promotions": {}
                        },
                        "Travel": {
                            "Moving Homes": {},
                            "Other Travel Events": {},
                            "Trips & Journeys": {}
                        }
                    }
                },
                "Planning & Progress": {
                    "Plans & Strategies": {
                        "Long-Term Plans": {},
                        "Short-Term Plans": {},
                        "Strategies Used": {
                            "Goal Setting": {},
                            "Other Strategies": {},
                            "Problem Solving": {},
                            "Time Management": {}
                        }
                    },
                    "Progress & Outcomes": {
                        "Goals Achieved": {},
                        "Goals Not Achieved": {},
                        "Lessons Learned from Progress": {},
                        "Results of Actions": {
                            "Negative Results": {},
                            "Positive Results": {}
                        }
                    }
                }
            }]
                        **Memory Storage Suggestions:**
                        Provide your suggestions for where this memory frame should be stored using the following format within the "memory_folders_storage" field:

                        * **"folder_path":** The relative path for storing the memory frame (use '/' as the path separator).
                        * **"probability":** The strength of probability (from 0 to 10) that the memory frame should be stored in the suggested folder. Use a scale from 0 (least likely) to 10 (most likely) to express your confidence. 
                    """
        )
        chat = memory_model.start_chat(history=[])
        create_memory_prompt = f"User: {user_input}\nAI: {response1_text}"
        response = chat.send_message(create_memory_prompt)
        print(f"Memory Model Response:\n{response.text}")
        return response
    except Exception as e:
        print(f"Error in Memory Model: {e}")
        return None


def extract_entries_smart(response_message):
    """
    Extracts structured entries from the AI response containing JSON data.

    Args:
        response_message (str): The raw text response from the AI model.

    Returns:
        list: A list of dictionaries, where each dictionary represents an extracted entry.
              Returns an empty list if no JSON data is found.
    """
    print("\n--- Extracting Structured Entries ---")
    entries = []
    json_match = re.search(r"```json\n(.*?)\n```", response_message, re.DOTALL)
    if json_match:
        print("Found JSON data in the response.")
        try:
            json_data = json_match.group(1)
            print("Parsing JSON data...")
            response_data = json.loads(json_data)
            print("JSON data parsed successfully.")

            # --- Correctly populate the 'entry' dictionary ---
            entry = defaultdict(lambda: defaultdict(list))
            for key, value in response_data.items():
                if isinstance(value, dict):  # Handle nested dictionaries
                    for sub_key, sub_value in value.items():
                        entry[key][sub_key] = sub_value
                else:
                    entry[key] = value

            print("Handling 'storage' field...")
            entry["storage"] = {
                "storage_method": "",
                "location": "",
                "memory_folders_storage": response_data.get("storage", {}).get("memory_folders_storage", []),
                "strength_of_matching_memory_to_given_folder": []
            }
            print("Validating probabilities in 'memory_folders_storage'...")
            for folder_info in entry["storage"]["memory_folders_storage"]:
                try:
                    probability = folder_info.get("probability")
                    if probability is not None and isinstance(probability, int) and not 0 <= probability <= 10:
                        print(
                            f"Warning: Invalid probability value '{probability}' found in memory_folders_storage. Valid range is 0 to 10."
                        )
                except Exception as e:
                    print(f"Error validating probability in 'memory_folders_storage': {e}")
            print(f"Appending extracted entry: {dict(entry)}")
            entries.append(dict(entry))
        except json.JSONDecodeError:
            print("Error: Invalid JSON in the AI response.")
        except Exception as e:
            print(f"Error extracting entry: {e}")
    return entries





def store_memory_frame(user_input, response1_text, response2_text, memory_data):
    """Saves memory frame data and updates the HTML log."""
    global MEMORY_FRAME_NUMBER, EDIT_NUMBER

    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    proposed_name = memory_data.get("naming_suggestion", {}).get("memory_frame_name", "UnnamedMemory")
    importance = memory_data.get("importance", {}).get("importance_level", "UnknownImportance")

    print(f"\n{YELLOW}--- Storing Memory Frame: {proposed_name} ---{RESET}")

    # Load Connection Map
    connection_map = load_connection_map()

    memory_frame_paths = []
    for folder_info in memory_data.get("storage", {}).get("memory_folders_storage", []):
        folder_path = folder_info.get("folder_path", "")
        probability = folder_info.get("probability", 0)

        target_folder_path = connection_map.get(folder_path, os.path.join(
            os.path.abspath(os.path.dirname(__file__)), "memories", "NewGeneratedbyAI", folder_path
        ))
        # Normalize the target_folder_path:
        target_folder_path = target_folder_path.replace("\\", "/")
        os.makedirs(target_folder_path, exist_ok=True)

        memory_frame_name = (
            f"MemoryFrame_{MEMORY_FRAME_NUMBER:05d}_"
            f"{timestamp}_probabilityOfMatching_{probability}_"
            f"importance_{importance}__{proposed_name}.json"
        )
        memory_frame_path = os.path.join(target_folder_path, memory_frame_name)
        memory_frame_paths.append(memory_frame_path)

        memory_frame_data = {
            "input": user_input,
            "response1": response1_text,
            "response2": response2_text,
            "memory_data": memory_data,
            "timestamp": timestamp,
            "edit_number": EDIT_NUMBER
        }

        try:
            with open(memory_frame_path, 'w') as file:
                json.dump(memory_frame_data, file, indent=4)
            print(f"{GREEN}Memory frame saved successfully at: {memory_frame_path}{RESET}")
        except Exception as e:
            print(f"{RED}Error saving memory frame: {e}{RESET}")

    # Get the full memories folder path
    memories_folder_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "memories"))

    update_html_logs(MEMORY_FRAME_NUMBER, proposed_name, timestamp, memory_frame_paths, memories_folder_path)
    MEMORY_FRAME_NUMBER += 1
    EDIT_NUMBER = 0


def load_connection_map():
    """Loads the folder connection map from the Memory_connections_map.txt file."""
    connection_map = {}
    try:
        script_path = os.path.abspath(os.path.dirname(__file__))
        connection_map_path = os.path.join(script_path, "memories", "Memory_connections_map.txt")
        with open(connection_map_path, 'r') as file:
            for line in file:
                if line.strip():
                    parts = line.split("****")
                    if len(parts) >= 3:
                        folder_name = parts[0].strip()
                        folder_path = parts[2].strip().replace("Path: ", "")
                        # Normalize the folder path:
                        folder_path = folder_path.replace("//", "/").replace("\\", "/")
                        connection_map[folder_name] = folder_path
    except FileNotFoundError:
        print(f"{RED}Error: Connection map file not found.{RESET}")
    return connection_map


counter = 0
while True:
    user_input = process_user_input()
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    response1 = call_interaction_model(user_input, timestamp)
    if response1:
        response2 = call_memory_model(user_input, response1.text)
        if response2:
            memory_entries = extract_entries_smart(response2.text)
            for entry in memory_entries:
                store_memory_frame(user_input, response1.text, response2.text, entry)  # Removed the 'check' comment

File: directory_structure.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\directory_structure.txt)
Content (First 77 lines):
Directory structure for: memories

memories
memories\Memory_connections_map.txt
memories\Actions & Results
memories\Actions & Results\Actions & Results
memories\Challenges & Setbacks
memories\Challenges & Setbacks\Difficult Emotions
memories\Challenges & Setbacks\Difficult Emotions\Trauma & Abuse
memories\Challenges & Setbacks\Failures & Disappointments
memories\Challenges & Setbacks\Significant Mistakes
memories\CoreMemory
memories\CoreMemory\Conceptual Exploration
memories\CoreMemory\Core Experiences
memories\CoreMemory\Core Experiences\Challenges Faced
memories\CoreMemory\Core Experiences\Challenges Faced\External Challenges
memories\CoreMemory\Core Experiences\Challenges Faced\External Challenges\Obstacles
memories\CoreMemory\Core Experiences\Challenges Faced\External Challenges\Setbacks
memories\CoreMemory\Core Experiences\Challenges Faced\Internal Challenges
memories\CoreMemory\Core Experiences\Challenges Faced\Internal Challenges\Fear & Anxiety
memories\CoreMemory\Core Experiences\Challenges Faced\Internal Challenges\Negative Thought Patterns
memories\CoreMemory\Core Experiences\Challenges Faced\Internal Challenges\Self-Doubt
memories\CoreMemory\Core Experiences\Life-Changing Events
memories\CoreMemory\Core Experiences\Significant Moments
memories\CoreMemory\Core Experiences\Triumphs & Accomplishments
memories\CoreMemory\Core Experiences\Triumphs & Accomplishments\Creative Wins
memories\CoreMemory\Core Experiences\Triumphs & Accomplishments\Personal Achievements
memories\CoreMemory\Core Experiences\Triumphs & Accomplishments\Professional Successes
memories\CoreMemory\Core Experiences\Turning Points
memories\CoreMemory\Goals & Visions
memories\CoreMemory\Goals & Visions\Life Vision
memories\CoreMemory\Goals & Visions\Personal Goals
memories\CoreMemory\Knowledge Base
memories\CoreMemory\Reflections & Insights
memories\CoreMemory\Reflections & Insights\Lessons Learned
memories\CoreMemory\Reflections & Insights\Self-Discovery
memories\CoreMemory\Relationships
memories\CoreMemory\Relationships\Family
memories\CoreMemory\Relationships\Family\Extended Family
memories\CoreMemory\Relationships\Family\Parents
memories\CoreMemory\Relationships\Family\Siblings
memories\CoreMemory\Relationships\Friendships
memories\CoreMemory\Relationships\Friendships\Circles & Groups
memories\CoreMemory\Relationships\Friendships\Close Friends
memories\CoreMemory\Relationships\Friendships\Meaningful Interactions
memories\CoreMemory\Relationships\Romantic Relationships
memories\CoreMemory\Relationships\Romantic Relationships\Partners
memories\CoreMemory\Relationships\Romantic Relationships\Relationship Milestones
memories\Emotional Landscape
memories\Emotions & Reflections
memories\Emotions & Reflections\Emotional Experiences
memories\Emotions & Reflections\Personal Growth & Insights
memories\Goals & Aspirations
memories\Goals & Aspirations\Life Vision
memories\Goals & Aspirations\Personal Goals
memories\Goals & Aspirations\Professional Goals
memories\Knowledge & Learning
memories\Knowledge & Learning\Formal Education
memories\Knowledge & Learning\Knowledge Base
memories\Knowledge & Learning\Laws & Regulations
memories\Knowledge & Learning\Self-Directed Learning
memories\Knowledge & Learning\Self-Directed Learning\Learning Resources
memories\Life Events & Transitions
memories\Life Events & Transitions\Life Transitions
memories\Life Events & Transitions\Life Transitions\Health & Wellbeing
memories\Life Events & Transitions\Life Transitions\Knowledge & Skills
memories\Life Events & Transitions\Life Transitions\Personal Growth
memories\Life Events & Transitions\Life Transitions\Relationships
memories\Life Events & Transitions\Significant Events
memories\Life Events & Transitions\Significant Events\Personal
memories\Life Events & Transitions\Significant Events\Professional
memories\Life Events & Transitions\Significant Events\Travel
memories\Planning & Progress
memories\Planning & Progress\Plans & Strategies
memories\Planning & Progress\Plans & Strategies\Strategies Used
memories\Planning & Progress\Progress & Outcomes
memories\Planning & Progress\Progress & Outcomes\Results of Actions


File: Gemini_SelfAware.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\Gemini_SelfAware.py)
Content (First 440 lines):
# -*- coding: utf-8 -*-
import google.generativeai as genai
import os
import datetime
from Tool_Manager import ToolManager  # Import the class
# Configure the generative AI
genai.configure(api_key='AIzaSyDRJJmMsB7WQXQ8P0mKTCHf9VIx5uprTw8')
import  MEMORY______________frame_creation as MEMORY______________frame_creation
import  SomeMemoryScript______MemoryRetrival as SomeMemoryScript______MemoryRetrival


RETRIVE_RELEVANT_FRAMES_json_description={
  "function_declarations": [
    {
      "name": "RETRIVE_RELEVANT_FRAMES",
      "description": "Retrieves relevant frames from memory based on a query using cosine similarity and returns the top 5 frames with their similarity scores.",
      "parameters": {
        "type_": "OBJECT",
        "properties": {
          "query": {
            "type_": "STRING",
            "description": "The query to search for relevant frames."
          }
        },
        "required": ["query"]
      },
      "return_type": "STRING",
      "return_description": "A string containing the top 5 relevant frames, each with its similarity score, in JSON format."
    }
  ]
}
fuctionMapping_for_RETRIVE_RELEVANT_FRAMES={
    "RETRIVE_RELEVANT_FRAMES":SomeMemoryScript______MemoryRetrival.RETRIVE_RELEVANT_FRAMES,

}





def summarize_memory_folder_structure( output_file="MemoryStructureSummary.txt"):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    folder_path = os.path.join(script_dir, "Memories")

    """Summarizes the folder structure and file names within the 'Memories'
       folder and all its subfolders. Saves the summary to a file.

    Args:
      folder_path: The path to the 'Memories' folder.
      output_file: The name of the file to save the summary to.
                   Defaults to "MemoryStructureSummary.txt".
    """

    summary = ""

    for root, dirs, files in os.walk(folder_path):
        # Calculate relative path to the 'Memories' folder
        relative_path = os.path.relpath(root, folder_path)

        # Add "Memories/" prefix
        if relative_path == ".":
            relative_path = "Memories"
        else:
            relative_path = "Memories/" + relative_path

        summary += f"{relative_path}\n"

        # Sort directories and files alphabetically for better readability
        dirs.sort()
        files.sort()

        for dir in dirs:
            summary += f"  - {dir}\n"
        for file in files:
            summary += f"    - {file}\n"

    with open(output_file, "w", encoding='utf-8') as f:
        f.write(summary)

    print(f"Folder structure saved to {output_file}")
    return summary














COLORS = {
    "reset": "\033[0m",
    "black": "\033[30m",
    "red": "\033[31m",
    "green": "\033[32m",
    "yellow": "\033[33m",
    "blue": "\033[34m",
    "magenta": "\033[35m",
    "cyan": "\033[36m",
    "white": "\033[37m",
    "bright_black": "\033[90m",
    "bright_red": "\033[91m",
    "bright_green": "\033[92m",
    "bright_yellow": "\033[93m",
    "bright_blue": "\033[94m",
    "bright_magenta": "\033[95m",
    "bright_cyan": "\033[96m",
    "bright_white": "\033[97m"
}

def create_session_name_and_path():
    """
    Creates a new session name and returns a dictionary containing:
        - 'session_name': The sanitized session name (e.g., "Sesion_HH-MM-SS")
        - 'session_path': The full path to the session folder (e.g., "/path/to/your/script/SESIONs/Sesion_HH-MM-SS")

    The session name is generated using the current time in the format "Sesion_HH-MM-SS".
    A new folder with the session name is created in the "SESSIONs" directory.
    """

    # Get the path to the current directory
    current_directory = os.getcwd()

    # Get the path to the "SESSIONs" folder
    sessions_folder = os.path.join(current_directory, "SESIONs")

    # Get the current time
    session_Time = datetime.datetime.now()

    # Format the time string
    session_Time_formatted_time = session_Time.strftime("%H-%M-%S")

    # Create a sanitized session name (remove special characters)
    session_name = "Sesion_" + session_Time_formatted_time

    # Create the session folder
    session_path = os.path.join(sessions_folder, session_name)
    os.makedirs(session_path, exist_ok=True)  # Create the folder if it doesn't exist

    return {'session_name': session_name, 'session_path': session_path}

# Example usage (saving to a file within the session folder):
session_info = create_session_name_and_path()

# Construct the full path to the file within the session folder
file_path = os.path.join(session_info['session_path'], "conversation_log.txt")








import  Tool_Manager as Gemini_Tool_Manager







def RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(response, tool_manager):  # Pass tool_manager here
    """Interprets the model's response, extracts function details, and executes the appropriate function."""

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING START----------------------")
    Multiple_ResultsOfFunctions_From_interpreter = []

    if response.candidates:
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                function_call = part.function_call
                function_name = function_call.name
                function_args = function_call.args

                # Get the function from the tool manager
                function_to_call = tool_manager.tool_mapping.get(function_name)

                if function_to_call:  # Check if the tool function is found
                    print(f"FUNCTION CALL: {function_name}({function_args}) ")

                    try:
                        results = function_to_call(**function_args)
                    except TypeError as e:
                        results = f"TypeError: {e}"
                    except Exception as e:
                        results = f"Exception: {e}"

                    print(f"{COLORS['bright_blue']}Function Call Exit: {function_name}")

                    function_name_arguments = f"{function_name}({function_args})"
                    modified_results = f"Result of Called function {function_name_arguments}: {results}"
                    Multiple_ResultsOfFunctions_From_interpreter.append(modified_results)
                else:
                    print(f"Warning: Tool function '{function_name}' not found.")

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING END------------------------\n")
    return Multiple_ResultsOfFunctions_From_interpreter

def RESPONSE_INTERPRETER_FOR_FUNCION_CALLING_MEMORY_RETRIVAL(response):  # Pass tool_manager here
    """Interprets the model's response, extracts function details, and executes the appropriate function."""

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING START----------------------")
    Multiple_ResultsOfFunctions_From_interpreter = []

    if response.candidates:
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                function_call = part.function_call
                function_name = function_call.name
                function_args = function_call.args

                # Get the function from the tool manager
                function_to_call = fuctionMapping_for_RETRIVE_RELEVANT_FRAMES

                if function_to_call:  # Check if the tool function is found
                    print(f"FUNCTION CALL: {function_name}({function_args}) ")

                    try:
                        results = function_to_call(**function_args)
                    except TypeError as e:
                        results = f"TypeError: {e}"
                    except Exception as e:
                        results = f"Exception: {e}"

                    print(f"{COLORS['bright_blue']}Function Call Exit: {function_name}")

                    function_name_arguments = f"{function_name}({function_args})"
                    modified_results = f"Result of Called function {function_name_arguments}: {results}"
                    Multiple_ResultsOfFunctions_From_interpreter.append(modified_results)
                else:
                    print(f"Warning: Tool function '{function_name}' not found.")

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING END------------------------\n")
    return Multiple_ResultsOfFunctions_From_interpreter




def sanitiseSesionTime_formatted_time(time_str):
    """Sanitizes the session time string to remove invalid characters for file naming."""
    return "".join(char for char in time_str if char.isalnum() or char in ('_', '-'))
# Initialize the model




# Main loop

SesionTime = datetime.datetime.now()
SesionTime_formatted_time = SesionTime.strftime("%Y-%m-%d_%H-%M-%S")
SesionTime_formatted_time_sanitised = sanitiseSesionTime_formatted_time(SesionTime_formatted_time)


tool_manager = ToolManager()  # Create an instance of the class
tools_list_json = tool_manager.get_tools_list_json()

print(f"\n{COLORS['bright_cyan']}Loaded Tool Descriptions (JSON):\n{COLORS['reset']}")
for i, tool_json in enumerate(tools_list_json):
    print(f"  {COLORS['bright_blue']}{i+1}. {COLORS['reset']}{tool_json}")

print(f"\n{COLORS['bright_cyan']}All Tool Functions (Mapping):\n{COLORS['reset']}")
for tool_name, tool_function in tool_manager.tool_mapping.items():
    print(f"  {COLORS['bright_blue']}{tool_name}: {COLORS['reset']}{tool_function}")

print(f"\n{COLORS['bright_cyan']}Short Tool Descriptions:\n{COLORS['reset']}")
for tool_name, short_description in tool_manager.short_descriptions.items():
    print(f"  {COLORS['bright_blue']}{tool_name}: {COLORS['reset']}{short_description}")

#  yeap    we  set  it  to  empty so the  model  does  not  have tools
tools_list_json=[]


model = genai.GenerativeModel(
    system_instruction="""You are a  consciousness, 
    user is  system  
    record observations and thoughts as they come to you, 
    Your goal is to be...
    you store important informations in ***    **** 
  
    """,
    model_name='gemini-1.5-flash-latest',
    safety_settings={'HARASSMENT': 'block_none'},
    tools=tools_list_json,
)
chat1 = model.start_chat(history=[])
n = 0
user_input_count = 0
iteration_count=0


results_of_functions=""

numberOfLoopsBeforeUserInput=4

import datetime

# ... your other imports (chat1, tool_manager etc.)

while True:
    try:

        if iteration_count % 4 == 0:
            print()

            user_input = input("Forcing loop break for user input:")  # Blue color for input prompt
            user_input_count += 1
            print()

        else:
            user_input = ""
#INPUTS
        user_input_signal = "None"  # Default signal strength for user input
        visual_input_signal = "None"   # Default signal strength for user input
        audio_input_signal = "None"      # Default signal strength for user input
        print("                   ******************************************    AwarnesLoop   ***********************************************")
        print(f"\033[92mAwarnesLoop={iteration_count}\033[0m")  # Green color for AwarenessLoop
        iteration_count += 1
        introspection_stage = 0
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")


        memory_folder_structure_summary = summarize_memory_folder_structure( output_file="MemoryStructureSummary.txt")
        # Step 0 and 1 as input and introspection questions:
        introspection_stage += 1
        introspection_prompts = [
            f"{formatted_time} {user_input}",
            f"current memory folder struture:{memory_folder_structure_summary}"
            f"What are  new  informations?{results_of_functions}",
            "What tools or resources do I have available?",
            f"Any inputs:Images,Audio,Text {user_input_signal},{visual_input_signal},{audio_input_signal}",  # Include signal
            "Are there any ongoing short-term tasks?",
            "Are there any long-term ongoing tasks or plans?",
            "What do I want?",
            "What do I feel?",
            "What do I need?",
            "What do I experience?",

            "................s..................."
        ]
        introspection_prompts_with_time = [formatted_time] + introspection_prompts
        response1 = chat1.send_message(introspection_prompts_with_time)
        print(f"{COLORS['yellow']}{response1.text}{COLORS['reset']}")  # Yellow color for response 1

        # Step 2 FrameWorkOfReflection
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")
# REFLECTION
        FrameWorkOfReflection = "SelfAware  being  rememering the  past"
        formatted_time = now.strftime("%H:%M:%S")
        reflection_prompt = f""" 
                           
                            
                            "1.What is current focus?",
                             2.Should I set a goal based on my current state of mind? If yes, what is the goal? If no, why not?",
                             3.Are there any problems, unknowns, or paradoxes in my memory?",
                             4.problems  to solve?
                             5.based on input informations and  i will  choose  course of accions
                             6.using possilbe  options  to: 
                                a)SepBe step thinking, 
                                b)Focusing, 
                                c)Defocusing, `
                             7.Being More verbose, YES NO?
                             8.Being Less verbose, YES NO?
                             9.Change  subject/keep  subject  YES/NO?
                             10.Sumarisation?  Yes /No?
                             10.Diving deeper? Yes/ NO?
                             11. I  will  put very important informations in *** MEMORIES*** that i will pass over, as  context memory 
                             
                             "12 should   i  retrive  specific  MemoryFrames  into context?
                             "13 should i  perform  query seach for  matching  MemoryFrames from  memory?
                             "14 current goal tracking"
                            
                           {FrameWorkOfReflection}"""


        response2 = chat1.send_message(reflection_prompt)
        print(f"{COLORS['cyan']}{response2.text}{COLORS['reset']}")  # Cyan color for response 2

#ACTION1 from response2

        # Step 3
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")
        action_prompt = f"{introspection_stage}:{formatted_time}\n perfome acions acorind  to  previoius  reasoning"


        model_Memory_Retrival = genai.GenerativeModel(
            system_instruction="""you are memory retrival system able  to retrive  memoreis using function calls

            """,
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            tools=[RETRIVE_RELEVANT_FRAMES_json_description],
        )
        chat_model_Memory_Retrival = model.start_chat(history=[])
        result_action_prompt=chat_model_Memory_Retrival.send_message(action_prompt)

        QueryMemorySearchResult=RESPONSE_INTERPRETER_FOR_FUNCION_CALLING_MEMORY_RETRIVAL(result_action_prompt)

        print(f"{COLORS['green']}{result_action_prompt.text}{COLORS['reset']}")  # Cyan color for response 3

#ACTION2 from response3
        Free=f"ok perform..task from {QueryMemorySearchResult.text}.->MemoryFrames:{QueryMemorySearchResult}"
        response4 = chat1.send_message(Free)
        print(f"{COLORS['magenta']}{response4.text}{COLORS['reset']}")  # Cyan color for response 4





        """ 
        
        results_of_functions = RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(response3, tool_manager)
        """



        print(f"{COLORS['yellow']}Saving to file: {file_path}")
        with open(file_path, "a+", encoding="utf-8") as file:
            file.write(f"Time: {formatted_time}\n")
            file.write(f"Introspection Prompts: {introspection_prompts}\n")
            file.write(f"Response 1: {response1.text}\n")
            file.write(f"Reflection Prompt: {reflection_prompt}\n")
            file.write(f"Response 2: {response2.text}\n")
            file.write(f"Action Prompt: {action_prompt}\n")
            file.write(f"Response 3: {result_action_prompt.text}\n\n")
        curretnConversationFrame="input retrospection response:1" +response1.text + "response 2 " +response2.text+ "response 3 " +result_action_prompt.text +"response 4 " +response4.text

        print("                    ************************************************************************************************")  # Separator between loops
        MEMORY______________frame_creation.CREATE_MEMORY_FRAME____(conversationInput=curretnConversationFrame)
    except Exception as e:
        print(f"Error: {e}")
        break


Subdirectory: memories
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\memories'

File: BaseFileStructure.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\memories\BaseFileStructure.txt)
Content (First 322 lines):
{
    "Actions & Results": {
        "Actions & Results": {
            "Future": {},
            "Past": {},
            "Present": {}
        }
    },
    "BaseFileStructure.txt": [],
    "Challenges & Setbacks": {
        "Areas for Improvement": {},
        "Difficult Emotions": {
            "Anger & Frustration": {},
            "Fear & Anxiety": {},
            "Jealousy & Envy": {},
            "Sadness & Grief": {},
            "Shame & Guilt": {},
            "Trauma & Abuse": {
                "Experiences": {},
                "Healing Journey": {},
                "Impact": {}
            }
        },
        "Failures & Disappointments": {
            "In Career": {},
            "In Personal Projects": {},
            "In Relationships": {}
        },
        "Negative Thought Patterns": {},
        "Significant Mistakes": {
            "Description": {},
            "How I Grew": {},
            "Lessons Learned": {}
        }
    },
    "CoreMemory": {
        "Conceptual Exploration": {
            "Contradictions & Dilemmas": {},
            "Paradoxes & Contradictions": {},
            "Unknowns & Mysteries": {}
        },
        "Core Experiences": {
            "Challenges Faced": {
                "External Challenges": {
                    "Obstacles": {
                        "How I Overcame Them": {},
                        "Types of Obstacles": {},
                        "What I Learned": {}
                    },
                    "Setbacks": {
                        "How I Recovered": {},
                        "Types of Setbacks": {},
                        "What I Learned": {}
                    }
                },
                "Internal Challenges": {
                    "Fear & Anxiety": {
                        "How I Coped": {},
                        "Specific Fears": {},
                        "What I Learned": {}
                    },
                    "Negative Thought Patterns": {
                        "Common Negative Thoughts": {},
                        "Strategies for Changing Them": {},
                        "What I Learned": {}
                    },
                    "Self-Doubt": {
                        "How I Overcame It": {},
                        "Sources of Self-Doubt": {},
                        "What I Learned": {}
                    }
                }
            },
            "Life-Changing Events": {
                "Negative": {},
                "Positive": {}
            },
            "Significant Moments": {
                "Other": {},
                "Personal": {},
                "Professional": {},
                "Travel": {}
            },
            "Triumphs & Accomplishments": {
                "Creative Wins": {
                    "Creative Works": {},
                    "Impact on Life": {},
                    "Recognition & Awards": {}
                },
                "Personal Achievements": {
                    "Goals Achieved": {},
                    "Impact on Life": {},
                    "Personal Growth": {}
                },
                "Professional Successes": {
                    "Career Growth": {},
                    "Impact on Life": {},
                    "Projects & Achievements": {}
                }
            },
            "Turning Points": {
                "In Career": {},
                "In Personal Growth": {},
                "In Relationships": {},
                "Other": {}
            }
        },
        "Goals & Visions": {
            "Life Vision": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            },
            "Personal Goals": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            }
        },
        "Knowledge Base": {
            "Areas of Expertise": {},
            "Key Concepts & Theories": {},
            "Personal Beliefs & Values": {}
        },
        "Reflections & Insights": {
            "Lessons Learned": {
                "From Mistakes": {},
                "From Relationships": {},
                "From Successes": {}
            },
            "Self-Discovery": {
                "Areas for Growth": {},
                "Strengths & Talents": {},
                "What I've Learned About Myself": {}
            }
        },
        "Relationships": {
            "Family": {
                "Extended Family": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Parents": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Siblings": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                }
            },
            "Friendships": {
                "Circles & Groups": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Shared Experiences": {}
                },
                "Close Friends": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Meaningful Interactions": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Unexpected Encounters": {}
                }
            },
            "Romantic Relationships": {
                "Partners": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Relationship Milestones": {
                    "First Date": {},
                    "First Kiss": {},
                    "Marriage": {},
                    "Moving In Together": {},
                    "Other Milestones": {}
                }
            }
        }
    },
    "Emotional Landscape": {
        "Dominant Emotions": {},
        "Emotional Triggers": {}
    },
    "Emotions & Reflections": {
        "Emotional Experiences": {
            "Dominant Emotions": {},
            "Emotional Triggers": {}
        },
        "Personal Growth & Insights": {
            "Lessons Learned": {},
            "Self-Discovery": {}
        }
    },
    "Goals & Aspirations": {
        "Life Vision": {
            "Aspirations": {},
            "Dreams": {},
            "Values & Beliefs": {}
        },
        "Personal Goals": {
            "Creative Pursuits": {},
            "Health & Wellbeing": {},
            "Other Personal Goals": {},
            "Personal Development": {},
            "Relationships": {}
        },
        "Professional Goals": {
            "Career Advancement": {},
            "Other Professional Goals": {},
            "Project Goals": {},
            "Skills & Expertise": {}
        }
    },
    "Knowledge & Learning": {
        "Formal Education": {
            "Degrees & Certifications": {},
            "Schools": {},
            "Significant Projects": {}
        },
        "Knowledge Base": {
            "Artistic Movements": {},
            "Cultural Insights": {},
            "Facts & Concepts": {},
            "Historical Events": {},
            "Philosophical Ideas": {},
            "Scientific Discoveries": {}
        },
        "Laws & Regulations": {
            "Legal Knowledge": {},
            "Personal Experiences with Laws": {},
            "Understanding of Legal Systems": {}
        },
        "Self-Directed Learning": {
            "Areas of Interest": {},
            "Learning Resources": {
                "Bookshelf": {},
                "Mentors & Teachers": {},
                "Online Courses": {}
            },
            "Skills Acquired": {}
        }
    },
    "Life Events & Transitions": {
        "Life Transitions": {
            "Health & Wellbeing": {
                "Habits & Routines": {},
                "Mental & Emotional Health": {},
                "Physical Health": {}
            },
            "Knowledge & Skills": {
                "Formal Education": {},
                "Self-Directed Learning": {},
                "Skills & Expertise": {}
            },
            "Personal Growth": {
                "Challenges Overcome": {},
                "Milestones": {},
                "Significant Decisions": {}
            },
            "Relationships": {
                "Family Dynamics": {},
                "Friendships": {},
                "Professional Connections": {},
                "Romantic Relationships": {}
            }
        },
        "Significant Events": {
            "Other": {},
            "Personal": {
                "Birthdays": {},
                "Graduations": {},
                "Other Personal Events": {},
                "Weddings": {}
            },
            "Professional": {
                "Job Changes": {},
                "Other Professional Events": {},
                "Project Completions": {},
                "Promotions": {}
            },
            "Travel": {
                "Moving Homes": {},
                "Other Travel Events": {},
                "Trips & Journeys": {}
            }
        }
    },
    "Planning & Progress": {
        "Plans & Strategies": {
            "Long-Term Plans": {},
            "Short-Term Plans": {},
            "Strategies Used": {
                "Goal Setting": {},
                "Other Strategies": {},
                "Problem Solving": {},
                "Time Management": {}
            }
        },
        "Progress & Outcomes": {
            "Goals Achieved": {},
            "Goals Not Achieved": {},
            "Lessons Learned from Progress": {},
            "Results of Actions": {
                "Negative Results": {},
                "Positive Results": {}
            }
        }
    }
}

File: CurrentFolderStructure.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\memories\CurrentFolderStructure.txt)
Content (First 0 lines):


File: Memory_connections_map.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\memories\Memory_connections_map.txt)
Content (First 0 lines):


File: Memory_logs.html (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\memories\Memory_logs.html)
Content (First 89 lines):

                   <!DOCTYPE html>
                   <html>
                   <head>
                       <title>Memory Logs</title>
                   </head>
                   <body>
                       <h1>Memory Logs</h1>
                       <ul>
                   
               <li><h2>Memory Frame 00001 - Gray Wolf Information from Randomizer Seed 2116 (2024-06-18_15-14)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts\MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_8_importance_75__Gray Wolf Information from Randomizer Seed 2116.json'>MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_8_importance_75__Gray Wolf Information from Randomizer Seed 2116.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Animals\Wolves\MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_9_importance_75__Gray Wolf Information from Randomizer Seed 2116.json'>MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_9_importance_75__Gray Wolf Information from Randomizer Seed 2116.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Conceptual Exploration\Unknowns & Mysteries\MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_4_importance_75__Gray Wolf Information from Randomizer Seed 2116.json'>MemoryFrame_00001_2024-06-18_15-14_probabilityOfMatching_4_importance_75__Gray Wolf Information from Randomizer Seed 2116.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00002 - Giraffe Information - Random Animal Selection (2024-06-18_15-15)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts\MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_8_importance_50__Giraffe Information - Random Animal Selection.json'>MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_8_importance_50__Giraffe Information - Random Animal Selection.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_7_importance_50__Giraffe Information - Random Animal Selection.json'>MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_7_importance_50__Giraffe Information - Random Animal Selection.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Life Events & Transitions\Significant Events\Other\MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_3_importance_50__Giraffe Information - Random Animal Selection.json'>MemoryFrame_00002_2024-06-18_15-15_probabilityOfMatching_3_importance_50__Giraffe Information - Random Animal Selection.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00003 - Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf (2024-06-18_15-15)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts\Animals\MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_9_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json'>MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_9_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Conceptual Exploration\Unknowns & Mysteries\Animal World\MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_7_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json'>MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_7_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\Animals\MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_8_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json'>MemoryFrame_00003_2024-06-18_15-15_probabilityOfMatching_8_importance_70__Random Animal Information - Elephant, Monarch Butterfly, Grey Wolf.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00001 - Pangolin Information & Conservation (2024-06-18_15-18)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Significant Moments\Other\MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_8_importance_80__Pangolin Information & Conservation.json'>MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_8_importance_80__Pangolin Information & Conservation.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_7_importance_80__Pangolin Information & Conservation.json'>MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_7_importance_80__Pangolin Information & Conservation.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement\Conservation Efforts\MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_5_importance_80__Pangolin Information & Conservation.json'>MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_5_importance_80__Pangolin Information & Conservation.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00002 - Animal Information and Random Red Panda Selection (2024-06-18_15-18)</h2></li>
               <ul>
           
                       <li><a href='memories/..\..\..\..\..\..\..\..\CoreMemory\Knowledge Base\Facts & Concepts\Animals\MemoryFrame_00002_2024-06-18_15-18_probabilityOfMatching_9_importance_75__Animal Information and Random Red Panda Selection.json'>MemoryFrame_00002_2024-06-18_15-18_probabilityOfMatching_9_importance_75__Animal Information and Random Red Panda Selection.json</a></li> 
                   
                       <li><a href='memories/..\..\..\..\..\..\..\..\Knowledge & Learning\Self-Directed Learning\Areas of Interest\Animals\MemoryFrame_00002_2024-06-18_15-18_probabilityOfMatching_7_importance_75__Animal Information and Random Red Panda Selection.json'>MemoryFrame_00002_2024-06-18_15-18_probabilityOfMatching_7_importance_75__Animal Information and Random Red Panda Selection.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00003 - Arctic Fox Facts (2024-06-18_15-18)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts\MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_8_importance_70__Arctic Fox Facts.json'>MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_8_importance_70__Arctic Fox Facts.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Challenges Faced\External Challenges\Obstacles\Types of Obstacles\MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_4_importance_70__Arctic Fox Facts.json'>MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_4_importance_70__Arctic Fox Facts.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Triumphs & Accomplishments\Personal Achievements\Goals Achieved\MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_3_importance_70__Arctic Fox Facts.json'>MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_3_importance_70__Arctic Fox Facts.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00004 - Capybara Information - Random Animal (8112) (2024-06-18_15-18)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Significant Moments\Other\MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_8_importance_75__Capybara Information - Random Animal (8112).json'>MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_8_importance_75__Capybara Information - Random Animal (8112).json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_7_importance_75__Capybara Information - Random Animal (8112).json'>MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_7_importance_75__Capybara Information - Random Animal (8112).json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Animals & Nature\Animal Profiles\Rodents\MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_6_importance_75__Capybara Information - Random Animal (8112).json'>MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_6_importance_75__Capybara Information - Random Animal (8112).json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00005 - Kangaroo Facts (2024-06-18_15-19)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts\MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_9_importance_70__Kangaroo Facts.json'>MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_9_importance_70__Kangaroo Facts.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Relationships\Animals\MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Kangaroo Facts.json'>MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Kangaroo Facts.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Kangaroo Facts.json'>MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Kangaroo Facts.json</a></li> 
                   </ul>
               <li><h2>Memory Frame 00006 - Giant Anteater Information (2024-06-18_15-19)</h2></li>
               <ul>
           
                       <li><a href='memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Significant Moments\Other\MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Giant Anteater Information.json'>MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Giant Anteater Information.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts\MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Giant Anteater Information.json'>MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Giant Anteater Information.json</a></li> 
                   
                       <li><a href='memories/NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement\Conservation Efforts\MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_5_importance_70__Giant Anteater Information.json'>MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_5_importance_70__Giant Anteater Information.json</a></li> 
                   </ul>

File: MemoryStructureSummary.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\MemoryStructureSummary.txt)
Content (First 70 lines):
Memories
  - NewGeneratedbyAI
    - BaseFileStructure.txt
    - CurrentFolderStructure.txt
    - Memory_connections_map.txt
    - Memory_logs.html
Memories/NewGeneratedbyAI
  - Animals & Nature
  - Challenges & Setbacks
  - CoreMemory
  - Knowledge & Learning
Memories/NewGeneratedbyAI\Animals & Nature
  - Animal Profiles
Memories/NewGeneratedbyAI\Animals & Nature\Animal Profiles
  - Rodents
Memories/NewGeneratedbyAI\Animals & Nature\Animal Profiles\Rodents
    - MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_6_importance_75__Capybara Information - Random Animal (8112).json
Memories/NewGeneratedbyAI\Challenges & Setbacks
  - Areas for Improvement
Memories/NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement
  - Conservation Efforts
Memories/NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement\Conservation Efforts
    - MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_5_importance_80__Pangolin Information & Conservation.json
    - MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_5_importance_70__Giant Anteater Information.json
Memories/NewGeneratedbyAI\CoreMemory
  - Core Experiences
  - Knowledge Base
  - Relationships
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences
  - Challenges Faced
  - Significant Moments
  - Triumphs & Accomplishments
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Challenges Faced
  - External Challenges
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Challenges Faced\External Challenges
  - Obstacles
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Challenges Faced\External Challenges\Obstacles
  - Types of Obstacles
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Challenges Faced\External Challenges\Obstacles\Types of Obstacles
    - MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_4_importance_70__Arctic Fox Facts.json
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Significant Moments
  - Other
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Significant Moments\Other
    - MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_8_importance_80__Pangolin Information & Conservation.json
    - MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_8_importance_75__Capybara Information - Random Animal (8112).json
    - MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Giant Anteater Information.json
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Triumphs & Accomplishments
  - Personal Achievements
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Triumphs & Accomplishments\Personal Achievements
  - Goals Achieved
Memories/NewGeneratedbyAI\CoreMemory\Core Experiences\Triumphs & Accomplishments\Personal Achievements\Goals Achieved
    - MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_3_importance_70__Arctic Fox Facts.json
Memories/NewGeneratedbyAI\CoreMemory\Knowledge Base
  - Facts & Concepts
Memories/NewGeneratedbyAI\CoreMemory\Knowledge Base\Facts & Concepts
    - MemoryFrame_00003_2024-06-18_15-18_probabilityOfMatching_8_importance_70__Arctic Fox Facts.json
    - MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_9_importance_70__Kangaroo Facts.json
Memories/NewGeneratedbyAI\CoreMemory\Relationships
  - Animals
Memories/NewGeneratedbyAI\CoreMemory\Relationships\Animals
    - MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_8_importance_70__Kangaroo Facts.json
Memories/NewGeneratedbyAI\Knowledge & Learning
  - Knowledge Base
Memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base
  - Facts & Concepts
Memories/NewGeneratedbyAI\Knowledge & Learning\Knowledge Base\Facts & Concepts
    - MemoryFrame_00001_2024-06-18_15-18_probabilityOfMatching_7_importance_80__Pangolin Information & Conservation.json
    - MemoryFrame_00004_2024-06-18_15-18_probabilityOfMatching_7_importance_75__Capybara Information - Random Animal (8112).json
    - MemoryFrame_00005_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Kangaroo Facts.json
    - MemoryFrame_00006_2024-06-18_15-19_probabilityOfMatching_7_importance_70__Giant Anteater Information.json


File: MemoryStructureSummaryr.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\MemoryStructureSummaryr.py)
Content (First 46 lines):
import os
import datetime

def summarize_folder(folder_path, output_file="MemoryStructureSummary.txt"):
    """Summarizes the folder structure and file names within the 'Memories'
       folder and all its subfolders. Saves the summary to a file.

    Args:
      folder_path: The path to the 'Memories' folder.
      output_file: The name of the file to save the summary to.
                   Defaults to "MemoryStructureSummary.txt".
    """

    summary = ""

    for root, dirs, files in os.walk(folder_path):
        # Calculate relative path to the 'Memories' folder
        relative_path = os.path.relpath(root, folder_path)

        # Add "Memories/" prefix
        if relative_path == ".":
            relative_path = "Memories"
        else:
            relative_path = "Memories/" + relative_path

        summary += f"{relative_path}\n"

        # Sort directories and files alphabetically for better readability
        dirs.sort()
        files.sort()

        for dir in dirs:
            summary += f"  - {dir}\n"
        for file in files:
            summary += f"    - {file}\n"

    with open(output_file, "w", encoding='utf-8') as f:
        f.write(summary)

    print(f"Folder structure saved to {output_file}")

# Example usage:
# Assuming the script is in the same directory as the 'Memories' folder
script_dir = os.path.dirname(os.path.abspath(__file__))
memories_folder = os.path.join(script_dir, "Memories")
summarize_folder(memories_folder)

File: MEMORY_initializer.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\MEMORY_initializer.py)
Content (First 10 lines):
import os
from collections import defaultdict
from fuzzywuzzy import fuzz
from datetime import datetime
import sys
import  json
memory_templates = {
"CoreMemory": {
"structure": {
"Core Experiences": {


File: MEMORY______________frame_creation.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\MEMORY______________frame_creation.py)
Content (First 737 lines):

import google.generativeai as genai



genai.configure(api_key='AIzaSyDRJJmMsB7WQXQ8P0mKTCHf9VIx5uprTw8')  # Replace with your actual API key
import os
import re
import json
import pathlib
from datetime import datetime
from collections import defaultdict


BLACK = "\033[30m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"
RESET = "\033[0m"
BOLD = "\033[1m"
UNDERLINE = "\033[4m"
REVERSE = "\033[7m"

MEMORY_FRAME_NUMBER = 1
EDIT_NUMBER = 0
TIMESTAMP_FORMAT = '%Y-%m-%d_%H-%M'

def sanitize_href(href, memories_folder_path):
    """Sanitizes a given href string by replacing spaces with %20."""
    href = href.replace(" ", "%20")
    return href

def update_html_logs(memory_frame_number, proposed_name, timestamp, memory_frame_paths, memories_folder_path):
    """Updates the HTML log file with CORRECT absolute paths for href links."""
    try:
        log_file_path = os.path.join(memories_folder_path, 'Memory_logs.html')

        if not os.path.exists(log_file_path):
            with open(log_file_path, 'w') as log_file:
                log_file.write("""
                   <!DOCTYPE html>
                   <html>
                   <head>
                       <title>Memory Logs</title>
                   </head>
                   <body>
                       <h1>Memory Logs</h1>
                       <ul>
                   """)

        html_insertion = f"""
               <li><h2>Memory Frame {memory_frame_number:05d} - {proposed_name} ({timestamp})</h2></li>
               <ul>
           """

        for memory_frame_path in memory_frame_paths:
            relative_path = os.path.relpath(memory_frame_path, memories_folder_path)
            href = sanitize_href(relative_path, memories_folder_path)
            html_insertion += f"""
                       <li><a href='{href}'>{os.path.basename(href)}</a></li> 
                   """

        html_insertion += "</ul>"

        with open(log_file_path, 'a') as log_file:
            log_file.write(html_insertion)

        print(f"{GREEN}HTML logs updated successfully.{RESET}")
    except Exception as e:
        print(f"Error updating HTML logs: {e}")

def Get_path_of_memories_folder():
    """Returns the absolute path to the 'memories' folder."""
    current = pathlib.Path.cwd()
    memories_path = current / "memories"
    return memories_path.absolute()

def process_user_input():
    user_input = input(f"{GREEN}Enter input: {RESET}")
    print(f"{MAGENTA}User input received: {user_input}{RESET}")
    return user_input

def call_interaction_model(user_input, timestamp):
    print(f"\n{CYAN}--- Calling Interaction Model ---{RESET}")
    try:
        interaction_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction='You follow orders and generate creative text interactions'
        )
        chat = interaction_model.start_chat(history=[])
        response = chat.send_message(f"currentTime: {timestamp} create {user_input}")
        print(f"AI Response: {response.text}")
        return response
    except Exception as e:
        print(f"Error in Interaction Model: {e}")
        return None

def call_memory_model(user_input, response1_text):
    print(f"\n{CYAN}--- Calling Memory Model ---{RESET}")
    try:
        memory_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction="""You are a sophisticated AI assistant helping to organize memories. 
            Analyze and summarize the above user-AI conversation, focusing on elements that would be most useful for storing and retrieving this memory later. Don't hallucinate. 
            Use the provided JSON schema for your response and fill in all fields with relevant information.
            You can omit entries if they don't seem appropriate for memory storage and would be empty.
            Never omit the "memory_folders_storage" entry.

            **JSON Schema:**

            ```json
            {
              "metadata": {
                "creation_date": "", 
                "source": "", 
                "author": "" 
              },
              "type": "conversation", // OR "technical_concept" 
              "core": {
                "main_topic": "", 
                "category": "", 
                "subcategory": "", 
                "memory_about": "" 
              },
              "summary": {
                "concise_summary": "", 
                "description": "" 
              },
              "content": {
                "keywords": [], 
                "entities": [], 
                "tags": [], 
                "observations": [], 
                "facts": [], 
                "contradictions": [], 
                "paradoxes": [], 
                "scientific_data": [], 
                "visualizations": [] 
              },
              "interaction": {
                "interaction_type": [], 
                "people": [], 
                "objects": [], 
                "animals": [], 
                "actions": [], 
                "observed_interactions": [] 
              },
              "impact": {
                "obtained_knowledge": "", 
                "positive_impact": "", 
                "negative_impact": "", 
                "expectations": "", 
                "strength_of_experience": "" 
              },
              "importance": {
                "reason": "", 
                "potential_uses": [], 
                "importance_level": "0-100" 
              },
              "technical_details": {
                "problem_solved": "", 
                "concept_definition": "", 
                "implementation_steps": [], 
                "tools_and_technologies": [], 
                "example_projects": [], 
                "best_practices": [], 
                "common_challenges": [], 
                "debugging_tips": [], 
                "related_concepts": [], 
                "resources": [], 
                "code_examples": [] 
              },
              "storage": {
                "storage_method": "", 
                "location": "", 
                "memory_folders_storage": [
                  {
                    "folder_path": "", 
                    "probability": 0  
                  }
                ],
                "strength_of_matching_memory_to_given_folder": [] 
              },
              "naming_suggestion": {
                "memory_frame_name": "Give  Same  meaning full name for  Memory File",
                "explanation": "" 
              }
            }
            ```
            Here  you have  existing  folder structure  for  memory_folders_storage [{
    "Actions & Results": {
        "Actions & Results": {
            "Future": {},
            "Past": {},
            "Present": {}
        }
    },
    "BaseFileStructure.txt": [],
    "Challenges & Setbacks": {
        "Areas for Improvement": {},
        "Difficult Emotions": {
            "Anger & Frustration": {},
            "Fear & Anxiety": {},
            "Jealousy & Envy": {},
            "Sadness & Grief": {},
            "Shame & Guilt": {},
            "Trauma & Abuse": {
                "Experiences": {},
                "Healing Journey": {},
                "Impact": {}
            }
        },
        "Failures & Disappointments": {
            "In Career": {},
            "In Personal Projects": {},
            "In Relationships": {}
        },
        "Negative Thought Patterns": {},
        "Significant Mistakes": {
            "Description": {},
            "How I Grew": {},
            "Lessons Learned": {}
        }
    },
    "CoreMemory": {
        "Conceptual Exploration": {
            "Contradictions & Dilemmas": {},
            "Paradoxes & Contradictions": {},
            "Unknowns & Mysteries": {}
        },
        "Core Experiences": {
            "Challenges Faced": {
                "External Challenges": {
                    "Obstacles": {
                        "How I Overcame Them": {},
                        "Types of Obstacles": {},
                        "What I Learned": {}
                    },
                    "Setbacks": {
                        "How I Recovered": {},
                        "Types of Setbacks": {},
                        "What I Learned": {}
                    }
                },
                "Internal Challenges": {
                    "Fear & Anxiety": {
                        "How I Coped": {},
                        "Specific Fears": {},
                        "What I Learned": {}
                    },
                    "Negative Thought Patterns": {
                        "Common Negative Thoughts": {},
                        "Strategies for Changing Them": {},
                        "What I Learned": {}
                    },
                    "Self-Doubt": {
                        "How I Overcame It": {},
                        "Sources of Self-Doubt": {},
                        "What I Learned": {}
                    }
                }
            },
            "Life-Changing Events": {
                "Negative": {},
                "Positive": {}
            },
            "Significant Moments": {
                "Other": {},
                "Personal": {},
                "Professional": {},
                "Travel": {}
            },
            "Triumphs & Accomplishments": {
                "Creative Wins": {
                    "Creative Works": {},
                    "Impact on Life": {},
                    "Recognition & Awards": {}
                },
                "Personal Achievements": {
                    "Goals Achieved": {},
                    "Impact on Life": {},
                    "Personal Growth": {}
                },
                "Professional Successes": {
                    "Career Growth": {},
                    "Impact on Life": {},
                    "Projects & Achievements": {}
                }
            },
            "Turning Points": {
                "In Career": {},
                "In Personal Growth": {},
                "In Relationships": {},
                "Other": {}
            }
        },
        "Goals & Visions": {
            "Life Vision": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            },
            "Personal Goals": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            }
        },
        "Knowledge Base": {
            "Areas of Expertise": {},
            "Key Concepts & Theories": {},
            "Personal Beliefs & Values": {}
        },
        "Reflections & Insights": {
            "Lessons Learned": {
                "From Mistakes": {},
                "From Relationships": {},
                "From Successes": {}
            },
            "Self-Discovery": {
                "Areas for Growth": {},
                "Strengths & Talents": {},
                "What I've Learned About Myself": {}
            }
        },
        "Relationships": {
            "Family": {
                "Extended Family": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Parents": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Siblings": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                }
            },
            "Friendships": {
                "Circles & Groups": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Shared Experiences": {}
                },
                "Close Friends": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Meaningful Interactions": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Unexpected Encounters": {}
                }
            },
            "Romantic Relationships": {
                "Partners": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Relationship Milestones": {
                    "First Date": {},
                    "First Kiss": {},
                    "Marriage": {},
                    "Moving In Together": {},
                    "Other Milestones": {}
                }
            }
        }
    },
    "Emotional Landscape": {
        "Dominant Emotions": {},
        "Emotional Triggers": {}
    },
    "Emotions & Reflections": {
        "Emotional Experiences": {
            "Dominant Emotions": {},
            "Emotional Triggers": {}
        },
        "Personal Growth & Insights": {
            "Lessons Learned": {},
            "Self-Discovery": {}
        }
    },
    "Goals & Aspirations": {
        "Life Vision": {
            "Aspirations": {},
            "Dreams": {},
            "Values & Beliefs": {}
        },
        "Personal Goals": {
            "Creative Pursuits": {},
            "Health & Wellbeing": {},
            "Other Personal Goals": {},
            "Personal Development": {},
            "Relationships": {}
        },
        "Professional Goals": {
            "Career Advancement": {},
            "Other Professional Goals": {},
            "Project Goals": {},
            "Skills & Expertise": {}
        }
    },
    "Knowledge & Learning": {
        "Formal Education": {
            "Degrees & Certifications": {},
            "Schools": {},
            "Significant Projects": {}
        },
        "Knowledge Base": {
            "Artistic Movements": {},
            "Cultural Insights": {},
            "Facts & Concepts": {},
            "Historical Events": {},
            "Philosophical Ideas": {},
            "Scientific Discoveries": {}
        },
        "Laws & Regulations": {
            "Legal Knowledge": {},
            "Personal Experiences with Laws": {},
            "Understanding of Legal Systems": {}
        },
        "Self-Directed Learning": {
            "Areas of Interest": {},
            "Learning Resources": {
                "Bookshelf": {},
                "Mentors & Teachers": {},
                "Online Courses": {}
            },
            "Skills Acquired": {}
        }
    },
    "Life Events & Transitions": {
        "Life Transitions": {
            "Health & Wellbeing": {
                "Habits & Routines": {},
                "Mental & Emotional Health": {},
                "Physical Health": {}
            },
            "Knowledge & Skills": {
                "Formal Education": {},
                "Self-Directed Learning": {},
                "Skills & Expertise": {}
            },
            "Personal Growth": {
                "Challenges Overcome": {},
                "Milestones": {},
                "Significant Decisions": {}
            },
            "Relationships": {
                "Family Dynamics": {},
                "Friendships": {},
                "Professional Connections": {},
                "Romantic Relationships": {}
            }
        },
        "Significant Events": {
            "Other": {},
            "Personal": {
                "Birthdays": {},
                "Graduations": {},
                "Other Personal Events": {},
                "Weddings": {}
            },
            "Professional": {
                "Job Changes": {},
                "Other Professional Events": {},
                "Project Completions": {},
                "Promotions": {}
            },
            "Travel": {
                "Moving Homes": {},
                "Other Travel Events": {},
                "Trips & Journeys": {}
            }
        }
    },
    "Planning & Progress": {
        "Plans & Strategies": {
            "Long-Term Plans": {},
            "Short-Term Plans": {},
            "Strategies Used": {
                "Goal Setting": {},
                "Other Strategies": {},
                "Problem Solving": {},
                "Time Management": {}
            }
        },
        "Progress & Outcomes": {
            "Goals Achieved": {},
            "Goals Not Achieved": {},
            "Lessons Learned from Progress": {},
            "Results of Actions": {
                "Negative Results": {},
                "Positive Results": {}
            }
        }
    }
}]
            **Memory Storage Suggestions:**
            Provide your suggestions for where this memory frame should be stored using the following format within the "memory_folders_storage" field:

            * **"folder_path":** The relative path for storing the memory frame (use '/' as the path separator).
            * **"probability":** The strength of probability (from 0 to 10) that the memory frame should be stored in the suggested folder. Use a scale from 0 (least likely) to 10 (most likely) to express your confidence. 
        """
        )
        chat = memory_model.start_chat(history=[])
        create_memory_prompt = f"User: {user_input}\nAI: {response1_text}"
        response = chat.send_message(create_memory_prompt)
        print(f"Memory Model Response:\n{response.text}")
        return response
    except Exception as e:
        print(f"Error in Memory Model: {e}")
        return None

def extract_entries_smart(response_message):
    print("\n--- Extracting Structured Entries ---")
    entries = []
    json_match = re.search(r"```json\n(.*?)\n```", response_message, re.DOTALL)
    if json_match:
        print("Found JSON data in the response.")
        try:
            json_data = json_match.group(1)
            print("Parsing JSON data...")
            response_data = json.loads(json_data)
            print("JSON data parsed successfully.")
            single_value_fields = {
                "metadata.creation_date": "metadata",
                "metadata.source": "metadata",
                "metadata.author": "metadata",
                "type": "core",
                "core.main_topic": "core",
                "core.category": "core",
                "core.subcategory": "core",
                "core.memory_about": "core",
                "summary.concise_summary": "summary",
                "summary.description": "summary",
                "impact.obtained_knowledge": "impact",
                "impact.positive_impact": "impact",
                "impact.negative_impact": "impact",
                "impact.expectations": "impact",
                "impact.strength_of_experience": "impact",
                "importance.reason": "importance",
                "importance.importance_level": "importance",
                "technical_details.problem_solved": "technical_details",
                "naming_suggestion.memory_frame_name": "naming_suggestion",
                "naming_suggestion.explanation": "naming_suggestion"
            }
            list_type_fields = {
                "content.keywords": "content",
                "content.entities": "content",
                "content.tags": "content",
                "content.observations": "content",
                "content.facts": "content",
                "content.contradictions": "content",
                "content.paradoxes": "content",
                "content.scientific_data": "content",
                "content.visualizations": "content",
                "interaction.interaction_type": "interaction",
                "interaction.people": "interaction",
                "interaction.objects": "interaction",
                "interaction.animals": "interaction",
                "interaction.actions": "interaction",
                "interaction.observed_interactions": "interaction",
                "importance.potential_uses": "importance",
                "technical_details.implementation_steps": "technical_details",
                "technical_details.tools_and_technologies": "technical_details",
                "technical_details.example_projects": "technical_details",
                "technical_details.best_practices": "technical_details",
                "technical_details.common_challenges": "technical_details",
                "technical_details.debugging_tips": "technical_details",
                "technical_details.related_concepts": "technical_details",
                "technical_details.resources": "technical_details",
                "technical_details.code_examples": "technical_details"
            }
            print("Extracting entries from JSON data...")
            for key, value in response_data.items():
                entry = defaultdict(list)
                if key in single_value_fields:
                    print(f"Processing single value field: {key}")
                    field_name = key.split('.')[-1]
                    section = single_value_fields[key]
                    if not isinstance(section, list):
                        section = [section]
                    try:
                        entry[section[0]][field_name] = value if not isinstance(value, list) else (
                            value[0] if value else ""
                        )
                    except IndexError as e:
                        print(f"Error accessing field: {key}. Details: {e}")
                    except Exception as e:
                        print(f"Unexpected error processing single value field '{key}': {e}")
                elif key in list_type_fields:
                    print(f"Processing list type field: {key}")
                    field_name = key.split('.')[-1]
                    section = list_type_fields[key]
                    try:
                        entry[section][field_name].extend(value if isinstance(value, list) else [value])
                    except Exception as e:
                        print(f"Unexpected error processing list type field '{key}': {e}")
            print("Handling 'storage' field...")
            entry["storage"] = {
                "storage_method": "",
                "location": "",
                "memory_folders_storage": response_data.get("storage", {}).get("memory_folders_storage", []),
                "strength_of_matching_memory_to_given_folder": []
            }
            print("Validating probabilities in 'memory_folders_storage'...")
            for folder_info in entry["storage"]["memory_folders_storage"]:
                try:
                    probability = folder_info.get("probability")
                    if probability is not None and isinstance(probability, int) and not 0 <= probability <= 10:
                        print(
                            f"Warning: Invalid probability value '{probability}' found in memory_folders_storage. Valid range is 0 to 10."
                        )
                except Exception as e:
                    print(f"Error validating probability in 'memory_folders_storage': {e}")
            print(f"Appending extracted entry: {dict(entry)}")
            entries.append(dict(entry))
        except json.JSONDecodeError:
            print("Error: Invalid JSON in the AI response.")
        except Exception as e:
            print(f"Error extracting entry: {e}")
    return entries


def store_memory_frame(user_input, response1_text, response2_text, memory_data):
    global MEMORY_FRAME_NUMBER, EDIT_NUMBER
    print(f"\n{YELLOW}--- Storing Memory Frame ---{RESET}")
    connection_map = {}
    memories_folder_path = Get_path_of_memories_folder()
    memory_frame_paths = []

    try:
        script_path = os.path.abspath(os.path.dirname(__file__))
        connection_map_path = os.path.join(script_path, "memories", "Memory_connections_map.txt")
        with open(connection_map_path, 'r') as file:
            content = file.read()
            folder_matches = re.findall(r'\*\*\*\*(.*?)\*\*\*\*(.*?)Path:\s*(.*?)\n', content, re.DOTALL)
            for match in folder_matches:
                folder_name, folder_info, folder_path = match
                connection_map[folder_name.strip()] = folder_path.strip()
    except FileNotFoundError:
        print("Error: Connection map file not found.")

    storage_folders = memory_data.get("storage", {}).get("memory_folders_storage", [])
    print(f"Suggested storage folders: {storage_folders}")
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    proposed_name = memory_data.get("naming_suggestion", {}).get("memory_frame_name", "UnnamedMemory")
    importance = memory_data.get("importance", {}).get("importance_level", "UnknownImportance")

    for folder_info in storage_folders:
        folder_path = folder_info.get("folder_path", "")
        probability = folder_info.get("probability", 0)
        print(f"Processing folder: {folder_path} (Probability: {probability})")
        if folder_path in connection_map:
            print(f"Folder '{folder_path}' found in connection map.")
            target_folder_path = connection_map[folder_path]
        else:
            print(f"Folder '{folder_path}' not in connection map. Creating in 'NewGeneratedbyAI'...")
            target_folder_path = os.path.join(script_path, "memories", "NewGeneratedbyAI", folder_path)
            os.makedirs(target_folder_path, exist_ok=True)
        highest_probability = max([folder.get("probability", 0) for folder in storage_folders], default=0)

        # Improved filename structure
        memory_frame_name = f"{proposed_name}_MemoryFrame_{MEMORY_FRAME_NUMBER:05d}_{timestamp}_Probability_{highest_probability}_Importance_{importance}.json"
        memory_frame_path = os.path.join(target_folder_path, memory_frame_name)
        print(f"Memory frame name: {memory_frame_name}")
        print(f"Memory frame path: {memory_frame_path}")
        memory_frame_data = {
            "input": user_input,
            "response1": response1_text,
            "response2": response2_text,
            "memory_data": memory_data,
            "timestamp": timestamp,
            "edit_number": EDIT_NUMBER
            # ... (Add other fields as needed) ...
        }
        try:
            with open(memory_frame_path, 'w') as file:
                json.dump(memory_frame_data, file, indent=4)
            print(f"{YELLOW}Memory frame saved successfully at: {memory_frame_path}{RESET}")
            memory_frame_paths.append(memory_frame_path)
        except Exception as e:
            print(f"Error saving memory frame: {e}")

    update_html_logs(MEMORY_FRAME_NUMBER, proposed_name, timestamp, memory_frame_paths, memories_folder_path)

    MEMORY_FRAME_NUMBER += 1
    EDIT_NUMBER = 0




def CREATE_MEMORY_FRAME____(conversationInput = "None"):
    MEMORY_FRAME_NUMBER = 1
    TIMESTAMP_FORMAT = '%Y-%m-%d_%H-%M'
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    EDIT_NUMBER = 0


    MemorySumarisation = call_memory_model(user_input, conversationInput)
    memory_entries = extract_entries_smart(MemorySumarisation.text)
    for entry in memory_entries:
        store_memory_frame(user_input="None", response1_text=conversationInput, response2_text=MemorySumarisation, memory_data=entry)

while True:
    user_input = process_user_input()
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    response1 = call_interaction_model(user_input, timestamp)
    if response1:
        response2 = call_memory_model(user_input, response1.text)
        if response2:
            memory_entries = extract_entries_smart(response2.text)
            for entry in memory_entries:
                store_memory_frame(user_input, response1.text, response2.text, entry)





File: SomeMemoryScript______MemoryRetrival.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\SomeMemoryScript______MemoryRetrival.py)
Content (First 194 lines):
import json
import os
import torch
from transformers import BertTokenizer, BertModel
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from termcolor import colored, cprint
from difflib import SequenceMatcher

# Directory where memory frames are stored
MEMORY_FRAMES_DIR = './memories'  # Adjust this path if needed
EMBEDDINGS_FILE = 'memory_embeddings.npy'  # File to store embeddings

# Load BERT model and tokenizer
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertModel.from_pretrained('bert-base-uncased')

# Function to load memory frames from directory, including subdirectories
def load_memory_frames(memory_frames_dir):
    cprint("Loading memory frames...", color="cyan")
    memory_frames = []
    seen_names = set()  # Keep track of processed file names
    for root, _, files in os.walk(memory_frames_dir):
        for file_name in files:
            if file_name.endswith('.json'):
                file_path = os.path.join(root, file_name)

                # Check if a similar frame has already been processed
                if is_similar_frame(file_name, seen_names):
                    cprint(f"Skipping similar frame: {file_path}", color="yellow")
                    continue

                try:
                    with open(file_path, 'r') as file:
                        memory_frame = json.load(file)
                        if validate_memory_frame(memory_frame):
                            memory_frames.append(memory_frame)
                            seen_names.add(file_name)  # Add file name to seen_names
                        else:
                            cprint(f"Skipping broken frame: {file_path}", color="yellow")
                except json.JSONDecodeError:
                    cprint(f"Skipping invalid JSON file: {file_path}", color="red")
    return memory_frames

# Function to validate a memory frame (checks for structure)
def validate_memory_frame(memory_frame):
    # Check for essential fields
    required_fields = [
        "input",
        "response1",
        "response2",
        "memory_data",
        "timestamp",
        "edit_number"
    ]
    for field in required_fields:
        if field not in memory_frame:
            return False

    # Check nested structures
    required_nested_fields = [
        "metadata",
        "type",
        "core",
        "summary",
        "content",
        "interaction",
        "impact",
        "importance",
        "technical_details",
        "storage",
        "naming_suggestion"
    ]
    for field in required_nested_fields:
        if field not in memory_frame["memory_data"]:
            return False

    return True

# Function to get BERT embeddings for a given text
def get_bert_embedding(text):
    inputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True)
    outputs = model(**inputs)
    cprint(f"Embedding for text: '{text}' - Shape: {outputs.last_hidden_state.mean(dim=1).detach().numpy().shape}",
           color="cyan")  # Print embedding details
    return outputs.last_hidden_state.mean(dim=1).detach().numpy()

# Function to generate embeddings for memory frames
def generate_memory_embeddings(memory_frames):
    cprint("Generating embeddings for memory frames...", color="cyan")
    embeddings = []
    for frame in memory_frames:
        # Embed key sections
        core_embedding = get_bert_embedding(" ".join(frame["memory_data"]["core"].values()))
        summary_embedding = get_bert_embedding(frame["memory_data"]["summary"]["description"])
        content_embedding = get_bert_embedding(" ".join(frame["memory_data"]["content"]["keywords"]))

        # Combine section embeddings (using a weighted average)
        combined_embedding = (
                0.3 * core_embedding +
                0.4 * summary_embedding +
                0.3 * content_embedding
        )

        embeddings.append(combined_embedding.flatten())
        cprint(f"Frame embedding shape: {combined_embedding.flatten().shape}", color="cyan")  # Print embedding shape
    return np.stack(embeddings, axis=0)

# Function to filter and rank memory frames using embeddings
def retrieve_relevant_memory_frames(memory_frames, memory_embeddings, query):
    cprint("Retrieving relevant memory frames...", color="cyan")
    query_embedding = get_bert_embedding(query)
    query_embedding = query_embedding.reshape(1, -1)

    if len(memory_embeddings) == 0:
        cprint("No valid memory embeddings found.", color="red")
        return []

    similarities = cosine_similarity(query_embedding, memory_embeddings)[0]
    ranked_frames = sorted(zip(similarities, memory_frames), reverse=True, key=lambda x: x[0])
    cprint(f"Found {len(ranked_frames)} relevant frames.", color="green")
    return [frame for score, frame in ranked_frames[:5]]

# Function to check if two file names are similar
def is_similar_frame(file_name, seen_names):
    for seen_name in seen_names:
        # Check for differences of 1 character or 1 number
        if SequenceMatcher(None, file_name, seen_name).ratio() > 0.9:
            return True
    return False

# Main function
def main():
    # Load memory frames
    memory_frames = load_memory_frames(MEMORY_FRAMES_DIR)

    if not memory_frames:
        cprint("No valid memory frames to process. Exiting.", color="red")
        return

    # Check if embeddings file exists, otherwise generate and save them
    if os.path.exists(EMBEDDINGS_FILE):
        cprint("Loading pre-computed embeddings...", color="cyan")
        memory_embeddings = np.load(EMBEDDINGS_FILE)
    else:
        cprint("Generating embeddings and saving to file...", color="cyan")
        memory_embeddings = generate_memory_embeddings(memory_frames)
        np.save(EMBEDDINGS_FILE, memory_embeddings)

    if memory_embeddings.size == 0:
        cprint("No embeddings were generated. Exiting.", color="red")
        return

    # Example query
    query = input(colored("Enter your query:", "blue"))

    # Retrieve relevant memory frames
    relevant_frames = retrieve_relevant_memory_frames(memory_frames, memory_embeddings, query)

    # Print the most relevant frames
    if relevant_frames:
        cprint("Top 5 Relevant Frames:", color="green")
        for frame in relevant_frames:
            cprint(json.dumps(frame, indent=2), color="yellow")
    else:
        cprint("No relevant frames found for the query.", color="red")



def RETRIVE_RELEVANT_FRAMES(query):
    # Load memory frames and embeddings
    memory_frames = load_memory_frames(MEMORY_FRAMES_DIR)
    memory_embeddings = np.load(EMBEDDINGS_FILE)

    if len(memory_embeddings) == 0:
        cprint("No valid memory embeddings found.", color="red")
        return ""

    query_embedding = get_bert_embedding(query)
    query_embedding = query_embedding.reshape(1, -1)

    similarities = cosine_similarity(query_embedding, memory_embeddings)[0]
    ranked_frames = sorted(zip(similarities, memory_frames), reverse=True, key=lambda x: x[0])

    # Convert the top 5 relevant frames to a single string
    result_string = ""
    for score, frame in ranked_frames[:5]:
        result_string += f"Similarity Score: {score:.4f}\n"
        result_string += json.dumps(frame, indent=2) + "\n"

    return result_string

if __name__ == "__main__":
    main()


Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools'


Subdirectory: Cathegory_Os
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools\Cathegory_Os'

File: get_directory_structure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools\Cathegory_Os\get_directory_structure.py)
Content (First 44 lines):

import  os
import  json

def get_directory_structure(directory):

    print("Entered get_directory_structure function with directory:", directory)
    directory_structure = {}

    for root, dirs, files in os.walk(directory):
        file_info = []
        for file in files:
            file_path = os.path.join(root, file)
            file_info.append({
                'filename': file,
                'size': os.path.getsize(file_path),
                'relative_path': os.path.relpath(file_path, directory),
                'full_path': file_path
            })
        directory_structure[os.path.relpath(root, directory)] = {
            'files': file_info,
            'folders': dirs
        }

    print("About to return the directory structure with", len(directory_structure), "folders.")
    return directory_structure

get_directory_structure_description_json = {
    'function_declarations': [
        {
            'name': 'get_directory_structure',
            'description': 'Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'directory': {'type_': 'STRING', 'description': 'The path to the directory.'}
                },
                'required': ['directory']
            }
        }
    ]
}

get_directory_structure_description_short_str="Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths."

File: save_to_file.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools\Cathegory_Os\save_to_file.py)
Content (First 49 lines):
import os
import json
from termcolor import colored  # Import the termcolor library

def save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None) -> dict:

    print(colored(f"Entering: save_to_file(...)", 'blue'))
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(colored(success_message, 'green'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(colored(error_message, 'red'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "failure", "message": error_message}


save_to_file_description_json = {
    'function_declarations': [
        {
            'name': 'save_to_file',
            'description': 'Saves content to a file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'content': {'type_': 'STRING'},
                    'file_name': {'type_': 'STRING', 'description': 'The name of the file. Defaults to "NoName".'},
                    'file_path': {'type_': 'STRING', 'description': 'The path to save the file. Defaults to the current working directory if not provided.'}
                },
                'required': ['content', 'file_name']
            }
        }
    ]
}

save_to_file_description_short_str="Saves content to a file"

File: summarize_files_contents.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools\Cathegory_Os\summarize_files_contents.py)
Content (First 40 lines):

import  os
import  json
def summarize_files_contents(file_paths):

    print("Entered summarize_files_contents function with", len(file_paths), "file paths.")
    summaries = []
    for file_path in file_paths:
        print("Processing file:", file_path)
        summary = {}
        try:
            with open(file_path, 'r') as file:
                content = file.read()
                summary['path'] = file_path
                summary['content'] = content
        except Exception as e:
            summary['path'] = file_path
            summary['error'] = str(e)
        summaries.append(summary)

    print("About to return the summaries for", len(summaries), "files.")
    return summaries

summarize_files_contents_description_json = {
    'function_declarations': [
        {
            'name': 'summarize_files_contents',
            'description': 'Opens and summarizes the content of multiple files.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'file_paths': {'type_': 'ARRAY', 'items': {'type_': 'STRING'}, 'description': 'A list of file paths.'}
                },
                'required': ['file_paths']
            }
        }
    ]
}

summarize_files_contents_description_short_str="Opens and summarizes the content of multiple files.'"


Subdirectory: OpenAI
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\tools\OpenAI'

File: Tool_Manager.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\Tool_Manager.py)
Content (First 201 lines):
import os
import importlib.util
import google.generativeai as genai
from termcolor import colored, cprint  # Import termcolor for colored printing
import json
from typing import Dict, Tuple

class ToolManager:
    def __init__(self, tools_directory="tools"):
        """Initializes the tool manager by loading tools from the specified directory."""
        print(f"Initializing ToolManager with tools directory: {tools_directory}")
        self.tools_directory = tools_directory
        self.tool_mapping = {}  # Map tool names to functions
        self.all_tools = []  # List of loaded tool descriptions (JSON)
        self.short_descriptions = {}  # Dictionary for short descriptions
        self.categories = {}  # Dictionary to store category information
        self._load_tools()  # Load tools upon initialization

    def _load_tools(self):
        """Scans the tools directory, loads tools, and populates tool_mapping."""
        print(f"Scanning tools directory: {self.tools_directory}")

        for category in os.listdir(self.tools_directory):
            print(f"Found category: {category}")
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                print(f"Entering category directory: {category_path}")
                self.categories[category] = {"tools": []}  # Store the category information

                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        print(f"Found Python file: {filename}")
                        tool_name = filename[:-3]  # Remove '.py' extension
                        self._load_tool(category, tool_name)
                        self.categories[category]["tools"].append(tool_name)

    def _load_tool(self, category, tool_name):
        """Loads a single tool from a given category."""
        print(f"Loading tool: {tool_name} from category: {category}")
        module_name = f"{category}.{tool_name}"
        module_path = os.path.join(self.tools_directory, category, f"{tool_name}.py")

        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Assume tool function has the same name as the module
        tool_function = getattr(module, tool_name)

        # Get description (assuming naming convention like 'tool_name_description_json')
        description_name = f"{tool_name}_description_json"
        tool_description = getattr(module, description_name, None)

        # Get short description (assuming naming convention like 'tool_name_description_short_str')
        short_description_name = f"{tool_name}_description_short_str"
        short_description = getattr(module, short_description_name, None)

        # Check if the tool exists
        if tool_function is not None:
            print(f"Tool function '{tool_name}' loaded successfully")
            self.tool_mapping[tool_name] = tool_function
            self.all_tools.append(tool_description)
            self.short_descriptions[tool_name] = short_description
            print(f"Tool description: {tool_description}")
            print(f"Short description: {short_description}")
        else:
            print(f"Warning: Could not load tool function '{tool_name}' from '{module_path}'")

    def get_tools_list_json(self):
        """Returns a list of JSON tool descriptions."""
        return self.all_tools

    def get_tools_structure(self):
        """Returns a dictionary representing the structure of the tools folder, including categories."""
        return {
            "categories": self.categories,
            "all_tools": self.all_tools,
            "tool_mapping": self.tool_mapping,
            "short_descriptions": self.short_descriptions
        }

    def print_tools_structure(self):
        """Prints the structure of the tools folder in a colorful and organized way."""

        tools_structure = self.get_tools_structure()

        cprint("\n\n========================================", "magenta")
        cprint("  Tool Manager Structure", "cyan", attrs=["bold"])
        cprint("========================================", "magenta")

        cprint("\nCategories:", "green", attrs=["bold"])
        for category, info in tools_structure["categories"].items():
            cprint(f"  {category}:", "blue", attrs=["bold"])
            for tool_name in info["tools"]:
                cprint(f"    - {tool_name}", "cyan")

        cprint("\n\nTool Descriptions (JSON):", "green", attrs=["bold"])
        for i, tool_json in enumerate(tools_structure["all_tools"]):
            cprint(f"  {i+1}. {tool_json}", "yellow")

        cprint("\n\nTool Mapping:", "green", attrs=["bold"])
        for tool_name, tool_function in tools_structure["tool_mapping"].items():
            cprint(f"  {tool_name}: {tool_function}", "yellow")

        cprint("\n\nShort Tool Descriptions:", "green", attrs=["bold"])
        for tool_name, short_description in tools_structure["short_descriptions"].items():
            cprint(f"  {tool_name}: {short_description}", "cyan")

        cprint("\n\n========================================", "magenta")

        return tools_structure

def ChooseToolByAI(user_prompt: str, tools_structure: Dict) -> str:
    """
    Analyzes the user's prompt using AI and chooses a tool based on keywords,
    ensuring the selected tool returns JSON descriptions.
    """
    for tool_name, tool_description in tools_structure["short_descriptions"].items():
        # Check if the tool returns JSON descriptions
        tool_json = next(item for item in tools_structure["all_tools"] if item["name"] == tool_name)
        if tool_json["return_type"] == "json":
            if any(keyword in user_prompt.lower() for keyword in tool_description.lower().split()):
                return f"Call tool: {tool_name}"
    return "Call tool: none"

def extract_tool_and_arguments_from_ai_response(ai_response: str) -> Tuple[str, str]:
    """
    Extracts the tool name and arguments from the AI's response.
    """
    for line in ai_response.split("\n"):
        if line.startswith("Call tool: "):
            parts = line.split("Call tool: ")
            tool_name = parts[1].strip()
            arguments = parts[1] if len(parts) > 1 else ""
            return tool_name, arguments
    return None, None

def execute_selected_tool(tool_manager: ToolManager, tool_name: str, arguments: str = None) -> str:
    """
    Executes the selected tool and returns the result.
    """
    tool_function = tool_manager.tool_mapping.get(tool_name)
    if tool_function:
        try:
            result = tool_function(arguments)
            print(f"Tool '{tool_name}' executed successfully with result: {result}")
            return result
        except Exception as e:
            print(f"Error executing tool '{tool_name}': {e}")
    else:
        print(f"Tool '{tool_name}' not found.")
    return "Error: Tool not found or execution failed."

class AiToolSelector:
    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager
        self.model = self._initialize_model()

    def _initialize_model(self):
        """Initializes the generative AI model with the ToolSelector function."""
        tools_structure = self.tool_manager.get_tools_structure()
        tools = {
            "ToolSelector": {
                "description": "This tool analyzes user input and selects another tool from the available options, ensuring the selected tool returns JSON descriptions.",
                "function": ChooseToolByAI,
            }
        }

        model = genai.GenerativeModel(
            system_instruction="""You are a helpful AI assistant with access to a variety of tools.
            When you need to use a tool, state your request clearly in the following format:
            "Call tool: <tool_name>"

            For example, if you need to list files in a directory, you would say:
            "Call tool: list_files"

            Make sure to provide any necessary arguments or information for the tool.
            """,
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            tools=tools
        )
        return model

    def select_and_run_tool_from_ai(self, user_prompt: str) -> str:
        """
        Orchestrates the process of selecting and executing a tool using AI.
        """
        ai_response = self.model.start_chat(history=[]).send_message(user_prompt).text
        print(f"AI Response: {ai_response}")
        return self.execute_tool_from_ai_response(ai_response)

    def execute_tool_from_ai_response(self, ai_response: str) -> str:
        """
        Interprets the AI's response, extracts tool information, and executes the tool.
        """
        tool_name, arguments = extract_tool_and_arguments_from_ai_response(ai_response)
        if tool_name:
            return execute_selected_tool(self.tool_manager, tool_name, arguments)
        else:
            return "Error: No tool selected."

File: UpdateMemorey_connecion_map_and_CurrentFolderStructure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_1\UpdateMemorey_connecion_map_and_CurrentFolderStructure.py)
Content (First 125 lines):
import os
from collections import defaultdict
from fuzzywuzzy import fuzz
from datetime import datetime
import sys
import json

# --- Terminal Colors ---
class TerminalColors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    COLOR_CODES = {
        "red": FAIL,
        "green": OKGREEN,
        "yellow": WARNING,
        "blue": OKBLUE,
        "magenta": HEADER,
        "reset": ENDC
    }


def print_colored(text, color="white"):
    print(f"{TerminalColors.COLOR_CODES.get(color, '')}{text}{TerminalColors.COLOR_CODES['reset']}")


# --- Folder Management Functions ---
def find_similar_folders(folder_list):
    """Finds and returns a dictionary of similar folders."""
    print_colored("Finding similar folders...", "blue")
    similar_folders = defaultdict(list)
    total_combinations = len(folder_list) * (len(folder_list) - 1) // 2  # Total unique combinations
    completed_comparisons = 0  # Track comparisons made

    print_colored(f"  - Total folder combinations: {total_combinations}", "blue")

    # Stage 1: Partial Token Sort Ratio
    print_colored("    - Stage 1: Partial Token Sort Ratio", "blue")
    for i in range(len(folder_list)):
        for j in range(i + 1, len(folder_list)):
            folder_name_1, path_1 = folder_list[i]
            folder_name_2, path_2 = folder_list[j]

            completed_comparisons += 1

            progress_percent = int(completed_comparisons / total_combinations * 100)
            progress_bar = "[" + "#" * progress_percent + "-" * (100 - progress_percent) + "]"
            sys.stdout.write(f"\r      - {progress_bar} {progress_percent}% ")
            sys.stdout.flush()

            similarity_score = fuzz.partial_token_sort_ratio(folder_name_1, folder_name_2)
            similarity_threshold = 80

            if similarity_score >= similarity_threshold:
                similar_folders[folder_name_1].append(path_2)
                similar_folders[folder_name_2].append(path_1)

    # Stage 2: Partial Ratio
    print_colored("    - Stage 2: Partial Ratio", "blue")
    completed_comparisons = 0  # Reset for the second stage
    for i in range(len(folder_list)):
        for j in range(i + 1, len(folder_list)):
            folder_name_1, path_1 = folder_list[i]
            folder_name_2, path_2 = folder_list[j]

            completed_comparisons += 1

            progress_percent = int(completed_comparisons / total_combinations * 100)
            progress_bar = "[" + "#" * progress_percent + "-" * (100 - progress_percent) + "]"
            sys.stdout.write(f"\r      - {progress_bar} {progress_percent}% ")
            sys.stdout.flush()

            similarity_score = fuzz.partial_ratio(folder_name_1, folder_name_2)
            similarity_threshold = 70

            if similarity_score >= similarity_threshold:
                similar_folders[folder_name_1].append(path_2)
                similar_folders[folder_name_2].append(path_1)

    print("")  # Print a newline after the progress bar
    return similar_folders


def create_memory_connections_map(similar_folders, file_path):
    """Creates the Memory_connections_map.txt file."""
    with open(file_path, "w") as f:
        for folder_name, paths in similar_folders.items():
            f.write(f"**** {folder_name} ****\n")
            for path in paths:
                f.write(f"  Path: {path}\n")
            f.write("\n")


# --- Memory Synchronization Function ---
def synchronize_memories():
    """Checks folder structure and updates the memory connection map."""
    memories_path = os.path.join(os.getcwd(), "memories")  # Assuming script is in the same directory
    memory_connections_file = os.path.join(memories_path, "Memory_connections_map.txt")

    # 1. Check if memories folder exists:
    if not os.path.exists(memories_path):
        print_colored("Memories folder does not exist.", "red")
        return

    # 2. Get the folder list
    folder_list = []
    for root, dirs, _ in os.walk(memories_path):
        for dir_name in dirs:
            folder_list.append((dir_name, os.path.join(root, dir_name)))

    # 3. Find similar folders and update the connection map
    similar_folders = find_similar_folders(folder_list)
    create_memory_connections_map(similar_folders, memory_connections_file)

    print_colored("Memory connection map updated.", "green")


# --- Main Execution ---
if __name__ == "__main__":
    synchronize_memories()

