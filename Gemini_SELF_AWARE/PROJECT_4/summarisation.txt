## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4'


Subdirectory: Brain_settings
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\Brain_settings'

File: State_of_mind.json (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\Brain_settings\State_of_mind.json)
Content (First 10 lines):
{
    "FocusOn": "",
    "FocusLevel": "",
    "Defocus": "",
    "FrustrationLevel": "",
    "CurrentCostOfProgress": "0",
    "Short_term_goals": [],
    "Long_term_goals": [],
    "Accomplished": []
}

File: Gemini_____SELFAWARE___ROBOT_1.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\Gemini_____SELFAWARE___ROBOT_1.py)
Content (First 455 lines):
import os
import datetime
import json
import time

from IPython.display import display, Markdown, clear_output
from rich.console import Console
import google.generativeai as genai
from prettytable import PrettyTable
import json
from MEMORY______________frame_creation import CREATE_MEMORY_FRAME as CREATE_MEMORY_FRAME
from Tool_Manager import ToolManager

def Load_state_of_mind():
    path = "Brain_settings/State_of_mind.json"

    try:
        # Open the JSON file in read mode
        with open(path, 'r') as f:
            # Load the JSON data using json.load()
            state_of_mind = json.load(f)
            print(state_of_mind)

    except FileNotFoundError:
        print("Error: JSON file not found at", path)
    print("loaded  state of  mind  ... ")
    return   state_of_mind

# Run the function



genai.configure(api_key='AIzaSyDGD_89tT5S5KLzSPkKWlRmwgv5cXZRTKA')  # Replace with your actual API key

SESSION_FOLDER = "sessions"
MEMORY_FOLDER = "memories"
MEMORY_STRUCTURE_SUMMARY_FILE = "memory_structure_summary.txt"

# ANSI escape codes for colors
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
BLUE = "\033[94m"
MAGENTA = "\033[95m"
CYAN = "\033[96m"
RESET = "\033[0m"
PURPLE = '\033[95m'
BRIGHT_RED = "\033[91m"
BRIGHT_GREEN = "\033[92m"
BRIGHT_YELLOW = "\033[93m"
BRIGHT_BLUE = "\033[94m"
BRIGHT_MAGENTA = "\033[95m"
BRIGHT_CYAN = "\033[96m"



def create_session_name_and_path():
    current_directory = os.getcwd()
    sessions_folder = os.path.join(current_directory, "SESIONS")
    session_time = datetime.datetime.now()
    session_time_formatted = session_time.strftime("%H-%M-%S")
    session_name = "Sesion_" + session_time_formatted
    session_path = os.path.join(sessions_folder, session_name)
    os.makedirs(session_path, exist_ok=True)
    return {'session_name': session_name, 'session_path': session_path}


def RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(response, tool_manager):  # Pass tool_manager here
    """Interprets the model's response, extracts function details, and executes the appropriate function."""

    print(f"{BRIGHT_BLUE}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING START----------------------")
    Multiple_ResultsOfFunctions_From_interpreter = []

    if response.candidates:
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                function_call = part.function_call
                function_name = function_call.name
                function_args = function_call.args

                # Get the function from the tool manager
                function_to_call = tool_manager.tool_mapping.get(function_name)

                if function_to_call:  # Check if the tool function is found
                    print(f"FUNCTION CALL: {function_name}({function_args}) ")

                    try:
                        results = function_to_call(**function_args)
                        if results is not None:
                            Multiple_ResultsOfFunctions_From_interpreter.append(results)
                            print("function return:")
                            print(f"{MAGENTA}  {results}")
                    except TypeError as e:
                        results = f"TypeError: {e}"
                    except Exception as e:
                        results = f"Exception: {e}"



                else:
                    print(f"Warning: Tool function '{function_name}' not found.")

    print(f"{BRIGHT_BLUE}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING END------------------------\n")

    return Multiple_ResultsOfFunctions_From_interpreter



def dict_to_pretty_string(dictionary):
    return json.dumps(dictionary, indent=4)
def sanitize_time_string(time_str: str) -> str:
    return "".join(char for char in time_str if char.isalnum() or char in ("_", "-"))


def create_session_folder() -> str:
    session_timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    session_name = f"session_{session_timestamp}"
    session_path = os.path.join(SESSION_FOLDER, session_name)
    os.makedirs(session_path, exist_ok=True)
    return session_path


def summarize_memory_folder_structure(output_file: str = MEMORY_STRUCTURE_SUMMARY_FILE) -> str:
    memory_path = MEMORY_FOLDER
    summary = ""
    for root, dirs, files in os.walk(memory_path):
        relative_path = os.path.relpath(root, memory_path)
        summary += f"{relative_path}\n"
        for dir in sorted(dirs):
            summary += f"  - {dir}\n"
        for file in sorted(files):
            summary += f"    - {file}\n"

    with open(output_file, "w", encoding="utf-8") as f:
        f.write(summary)
    return summary


def gather_introspection_data(
        action_response_text_back_to_top: str ="None",
        user_input: str = "None",
        memory_summary: str = "None",
        function_call_results: str = "None",
        user_input_signal: str = "None",
        visual_input_signal: str = "None",
        audio_input_signal: str = "None",
) -> list[str]:
    current_time = datetime.datetime.now().strftime("%H:%M:%S")



    introspection_data = [
        f"{current_time}  {action_response_text_back_to_top}     {user_input}",
        f"{function_call_results}",
        "..--->...",
        "What are my available tools and resources?",
        f"Current sensory input (Image, Audio, Text): {visual_input_signal}, {audio_input_signal}, {user_input_signal}",
        "Are there any ongoing short-term tasks?",
        "Are there any long-term ongoing tasks or plans?",

        "1.What is my current goal?",
        "2.What do I want?",
        "3.What am I feeling?",
        "4.What do I need?",
        "5.What am I experiencing?",
        "8.Emotional state?.....",
         " Maybe?  ??",
    ]
    return introspection_data


def perform_reflection(introspection_results: str,STATE_OF_MIND:str) -> str:
    current_time = datetime.datetime.now().strftime("%H:%M:%S")
    reflection_prompt = f"""{current_time}

        {introspection_results}
        "internal state:{STATE_OF_MIND}
        user is  system, Me is you,
        1. What is  current focus?,
        2. Should  set a new goal? If so, what is it? If not, why not?,
        3. Are there any problems, unknowns, or paradoxes in my memory?,
        4. What problems need to be solved?,
        5. What are possible courses of action based on available information?,
        6. Approach the next steps?:
           a) Think step-by-step?
           b) Focus on a specific aspect?
           c) Defocus and broaden my attention?
           e) If focus YES, Write at  the end what  you are focusing on,
        7. Should I be more verbose in my responses? (Yes/No),
        8. Should I be less verbose? (Yes/No),
        9. Should I change the subject or keep discussing this? (Yes/No),
        10. Should I summarize the current discussion? (Yes/No),
        11. Should I dive deeper into a specific topic? (Yes/No),
        12. Should I store any of this information in my long-term memory (Yes/No)? ,
        13. Should I query my memory for relevant information? (Yes/No),
        14. What is the status of my current goals? ,
    """
    return reflection_prompt


def plan_actions(reflection_results: str) -> str:
    current_time = datetime.datetime.now().strftime("%H:%M:%S")
    action_prompt = f"{current_time} -  Based on this reflection: \n{reflection_results}\nPlan my next actions."
    return action_prompt


def store_conversation_frame(
        introspection_results: str,
        reflection_results: str,
        action_plan: str,
        function_call_results: str,
):
    current_conversation_frame = (
        f"Introspection:\n{introspection_results}\n"
        f"Reflection:\n{reflection_results}\n"
        f"Action Plan:\n{action_plan}\n"
        f"Function Call Results:\n{function_call_results}\n"
    )
    CREATE_MEMORY_FRAME(current_conversation_frame)


def log_conversation(
        conversation_log_path: str,
        iteration_count: int,
        current_conversation_frame: str,
):
    current_time = datetime.datetime.now().strftime("%H:%M:%S")
    with open(conversation_log_path, "a+", encoding="utf-8") as log_file:
        log_file.write(f"--- Awareness Loop: {iteration_count} ---\n")
        log_file.write(f"Time: {current_time}\n")
        log_file.write(current_conversation_frame)
        log_file.write("-" * 20 + "\n\n")


def main():
    session_info = create_session_name_and_path()
    session_path = session_info['session_path']
    conversation_log_path = os.path.join(session_path, "conversation_log.txt")
    tool_manager = ToolManager()
    tools_list_json = tool_manager.get_tools_list_json()
    iteration_count = 0
    user_input_count = 0
    function_call_results = ""
    current_conversation_frame = ""
    user_input_signal = "None"
    visual_input_signal = "None"
    audio_input_signal = "None"
    str_function_call_results = ""
    action_response_text_back_to_top = ""



    print(f"\n\033[96mLoaded Tool Descriptions (JSON):\n\033[0m")
    for i, tool_json in enumerate(tools_list_json):
        print(f"  \033[94m{i + 1}. \033[0m{tool_json}")

    print(f"\n\033[96mAll Tool Functions (Mapping):\n\033[0m")
    for tool_name, tool_function in tool_manager.tool_mapping.items():
        print(f"  \033[94m{tool_name}: \033[0m{tool_function}")

    print(f"\n\033[96mShort Tool Descriptions:\n\033[0m")
    for tool_name, short_description in tool_manager.short_descriptions.items():
        print(f"  \033[94m{tool_name}: \033[0m{short_description}")




    available_tools = tool_manager.get_tools_list_json()
    print("prompt init")
    system_instruction_input= """ And  then God  created  shy and  heavesm and  he  made  them  in his  picture,,,,
        """

    system_instruction_reflection= """ 
        user is  assistant and  system,  
        you answer the questions,
        """

    system_instruction_action = """
         Based on coversation  you decided  wether to call function, reponse with text, or do both, you focus  on achiving goals!, you try  your  harders to ....
               """
    with open(conversation_log_path, "a+", encoding="utf-8") as file:
        file.write(f"system_instruction_input: {system_instruction_input}\n")
        file.write(f" system_instruction_reflection: { system_instruction_reflection}\n")
        file.write(f"system_instruction_action: {system_instruction_action}\n")
    print("model init")
    try:
        # Initialize models
        introspection_model = genai.GenerativeModel(
            system_instruction=system_instruction_input,
            model_name="gemini-1.5-flash-latest",
            safety_settings={"HARASSMENT": "block_none"},
            tools=available_tools,
            tool_config={'function_calling_config': 'NONE'}
        )

        introspection_chat = introspection_model.start_chat(history=[])



        time.sleep(0.5)
        reflection_model = genai.GenerativeModel(
            system_instruction=system_instruction_reflection,
            model_name="gemini-1.5-flash-latest",
            safety_settings={"HARASSMENT": "block_none"},

            tools=available_tools,
            tool_config={'function_calling_config': 'NONE'}

        )

        reflection_chat = reflection_model.start_chat(history=[] )



        time.sleep(0.5)
        action_model = genai.GenerativeModel(
            system_instruction=system_instruction_action,
            model_name="gemini-1.5-flash-latest",
            safety_settings={"HARASSMENT": "block_none"},
            tools=available_tools,
        )
        action_chat = action_model.start_chat(history=[])



    except Exception as E:
        print(E)
        print("Problems with model initialisations")

    user_input=""
    while True:
        print()
        try:
            if iteration_count % 3 == 0:
                user_input = input(f"{YELLOW}Enter your input (or press Enter to skip): {RESET}")
                user_input_count += 1
            else:
                user_input = ""

            iteration_count += 1


            print()
            print(f"{GREEN}    ****************************** Awareness Loop ******************************    {RESET}")
            print(f"{GREEN}Awareness Loop: {iteration_count}{RESET}")
            function_call_results = str_function_call_results
            memory_summary = summarize_memory_folder_structure()
            print(memory_summary)

            introspection_data = gather_introspection_data(
                action_response_text_back_to_top,
                user_input,
                memory_summary,
                function_call_results,
                user_input_signal,
                visual_input_signal,
                audio_input_signal,
            )

            print(f"{YELLOW}inputs:")
            print(f"{BLUE}INTROSPECTION input:")
            # =========================input introspection
            try:
                introspection_response = introspection_chat.send_message(introspection_data)

                if introspection_response.text is not None:
                    print(f"{BLUE}{introspection_response.text}")
                    with open(conversation_log_path, "a+", encoding="utf-8") as file:
                        file.write(f"Introspection: {introspection_response.text}\n")


            except Exception as E:
                print(E)



            print()
            print(f"{GREEN}Reflection:{GREEN}")

            # =========================relection

            STATE_OF_MIND= Load_state_of_mind()
            reflection_prompt = perform_reflection(introspection_response.text,STATE_OF_MIND)
            reflection_response = reflection_chat.send_message(reflection_prompt)
            print(f"{GREEN}{reflection_response.text}")

            with open(conversation_log_path, "a+", encoding="utf-8") as file:
                file.write(f"Reflection: {reflection_response.text}\n")
            #==========================actions

            print(f"{MAGENTA}ACTIONS:{MAGENTA}")
            try:
                action_prompt = plan_actions(reflection_response.text)
                action_response = action_chat.send_message(action_prompt)
                print(f"{MAGENTA }{action_response}")
                if action_response.text is not  None:
                    print(action_response.text)
                    action_response_back_to_top=action_response.text
                else:
                    action_response_text_back_to_top=""
            except Exception as E:
                print(E)


            with open(conversation_log_path, "a+", encoding="utf-8") as file:
                    file.write(f"Action Planning: {action_response}\n")


            #interpteter
            try:
                #------------------INTERPRETER---------------------
                print(f"{BRIGHT_BLUE}---------------------------START-INTERPRETER---------------------------------------------")
                function_call_results = RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(action_response, tool_manager)
                str_function_call_results = dict_to_pretty_string(function_call_results)
                print("----------------------------INTERPRETER-END--------------------------------------------")
                with open(conversation_log_path, "a+", encoding="utf-8") as file:
                    file.write(f"Function Execution: {function_call_results}\n")
            except Exception as e:
                function_call_results = ''
                str_function_call_results = ''


            if function_call_results is None:
                function_call_results = "None"

            if action_response is None:
                action_response = ""
                str_function_call_results = ""

            if function_call_results is None:
                function_call_results = ""
                str_function_call_results = ""
            #creating MEMORY FRAME
            try:
                print()
                print()
                print("CREATE MEMORY FRAME FROM LOOP")
                current_conversation_frame = (
                    f"Introspection:\n{introspection_response.text}\n"
                    f"Reflection:\n{reflection_response.text}\n"
                    f"Action:\n{action_response}\n"
                    f"Function Call Results:\n{str_function_call_results}\n")
                CREATE_MEMORY_FRAME(current_conversation_frame, SESION_INFO=session_info['session_name'])
            except Exception as E:
                current_conversation_frame = ''

            if user_input_count > 0:
                log_conversation(conversation_log_path, iteration_count, current_conversation_frame)

        except Exception as e:
            break


if __name__ == "__main__":
    main()

File: MemoryStructureSummaryr.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\MemoryStructureSummaryr.py)
Content (First 46 lines):
import os
import datetime

def summarize_folder(folder_path, output_file="MemoryStructureSummary.txt"):
    """Summarizes the folder structure and file names within the 'Memories'
       folder and all its subfolders. Saves the summary to a file.

    Args:
      folder_path: The path to the 'Memories' folder.
      output_file: The name of the file to save the summary to.
                   Defaults to "MemoryStructureSummary.txt".
    """

    summary = ""

    for root, dirs, files in os.walk(folder_path):
        # Calculate relative path to the 'Memories' folder
        relative_path = os.path.relpath(root, folder_path)

        # Add "Memories/" prefix
        if relative_path == ".":
            relative_path = "Memories"
        else:
            relative_path = "Memories/" + relative_path

        summary += f"{relative_path}\n"

        # Sort directories and files alphabetically for better readability
        dirs.sort()
        files.sort()

        for dir in dirs:
            summary += f"  - {dir}\n"
        for file in files:
            summary += f"    - {file}\n"

    with open(output_file, "w", encoding='utf-8') as f:
        f.write(summary)

    print(f"Folder structure saved to {output_file}")

# Example usage:
# Assuming the script is in the same directory as the 'Memories' folder
script_dir = os.path.dirname(os.path.abspath(__file__))
memories_folder = os.path.join(script_dir, "Memories")
summarize_folder(memories_folder)

File: memory_retrieval.log (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\memory_retrieval.log)
Content (First 0 lines):


File: memory_structure_summary.txt (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\memory_structure_summary.txt)
Content (First 54 lines):
.
  - NewGeneratedbyAI
    - Memory_logs.html
NewGeneratedbyAI
  - Challenges & Setbacks
  - CoreMemory
NewGeneratedbyAI\Challenges & Setbacks
  - Areas for Improvement
NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement
  - Communication & Interaction
    - MemoryFrame__session_Sesion_05-45-29___2024-06-22_05-46___Probability_8___Importance_80___AI Introspection and Function Call Issue.json
    - MemoryFrame__session_Sesion_06-11-47___2024-06-22_06-13___Probability_8___Importance_75___Improving User-AI Communication.json
NewGeneratedbyAI\Challenges & Setbacks\Areas for Improvement\Communication & Interaction
    - MemoryFrame__session_Sesion_05-37-18___2024-06-22_05-38___Probability_8___Importance_80___AI Communication Breakdown with Vague User Responses.json
NewGeneratedbyAI\CoreMemory
  - Conceptual Exploration
  - Goals & Visions
  - Reflections & Insights
NewGeneratedbyAI\CoreMemory\Conceptual Exploration
  - Contradictions & Dilemmas
  - Unknowns & Mysteries
NewGeneratedbyAI\CoreMemory\Conceptual Exploration\Contradictions & Dilemmas
    - MemoryFrame__session_Sesion_05-37-18___2024-06-22_05-38___Probability_7___Importance_80___AI Self-Reflection and User Uncertainty.json
    - MemoryFrame__session_Sesion_05-41-07___2024-06-22_05-42___Probability_6___Importance_80___AI Introspection and User Interaction.json
    - MemoryFrame__session_Sesion_05-45-29___2024-06-22_05-47___Probability_8___Importance_80___AI Introspection - Empty Function Calls & Unanswered Questions.json
NewGeneratedbyAI\CoreMemory\Conceptual Exploration\Unknowns & Mysteries
    - MemoryFrame__session_Sesion_05-37-18___2024-06-22_05-37___Probability_8___Importance_80___AI Introspection and Self-Reflection Log Analysis.json
    - MemoryFrame__session_Sesion_05-45-29___2024-06-22_05-46___Probability_8___Importance_90___AI Introspection Log Analysis.json
NewGeneratedbyAI\CoreMemory\Goals & Visions
  - Life Vision
  - Personal Goals
NewGeneratedbyAI\CoreMemory\Goals & Visions\Life Vision
  - Long-Term Goals
NewGeneratedbyAI\CoreMemory\Goals & Visions\Life Vision\Long-Term Goals
    - MemoryFrame__session_Sesion_06-07-23___2024-06-22_06-08___Probability_8___Importance_70___Project Planning - State_of_mind.json.json
NewGeneratedbyAI\CoreMemory\Goals & Visions\Personal Goals
    - MemoryFrame__session_Sesion_06-07-23___2024-06-22_06-09___Probability_8___Importance_75___Emotions Project Planning & Goal Setting.json
NewGeneratedbyAI\CoreMemory\Reflections & Insights
  - Lessons Learned
  - Self-Discovery
NewGeneratedbyAI\CoreMemory\Reflections & Insights\Lessons Learned
  - From Relationships
NewGeneratedbyAI\CoreMemory\Reflections & Insights\Lessons Learned\From Relationships
  - With AI
    - MemoryFrame__session_Sesion_06-11-47___2024-06-22_06-14___Probability_8___Importance_75___Improving User-AI Communication.json
NewGeneratedbyAI\CoreMemory\Reflections & Insights\Lessons Learned\From Relationships\With AI
    - MemoryFrame__session_Sesion_05-41-07___2024-06-22_05-42___Probability_9___Importance_70___Improving Communication with AI.json
    - MemoryFrame__session_Sesion_05-41-07___2024-06-22_05-42___Probability_9___Importance_80___Initial Communication Challenges with AI System.json
NewGeneratedbyAI\CoreMemory\Reflections & Insights\Self-Discovery
  - What I've Learned About Myself
NewGeneratedbyAI\CoreMemory\Reflections & Insights\Self-Discovery\What I've Learned About Myself
    - MemoryFrame__session_Sesion_05-54-57___2024-06-22_05-55___Probability_8___Importance_70___Introspection and Goal Setting Conversation.json
    - MemoryFrame__session_Sesion_06-03-15___2024-06-22_06-04___Probability_9___Importance_80___Introspection and Goal Setting Conversation.json
    - MemoryFrame__session_Sesion_06-07-23___2024-06-22_06-08___Probability_8___Importance_70___Introspection and Self-Reflection


File: MEMORY______________frame_creation.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\MEMORY______________frame_creation.py)
Content (First 680 lines):

import google.generativeai as genai

import  threading

genai.configure(api_key='AIzaSyDGD_89tT5S5KLzSPkKWlRmwgv5cXZRTKA')  # Replace with your actual API key
import os
import re
import json
import pathlib
from datetime import datetime
from collections import defaultdict


BLACK = "\033[30m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
MAGENTA = "\033[35m"
CYAN = "\033[36m"
WHITE = "\033[37m"
RESET = "\033[0m"
BOLD = "\033[1m"
UNDERLINE = "\033[4m"
REVERSE = "\033[7m"

MEMORY_FRAME_NUMBER = 1
EDIT_NUMBER = 0
TIMESTAMP_FORMAT = '%Y-%m-%d_%H-%M'

def sanitize_href(href, memories_folder_path):
    """Sanitizes a given href string by replacing spaces with %20."""
    href = href.replace(" ", "%20")
    return href

def update_html_logs(memory_frame_number, proposed_name, timestamp, memory_frame_paths, memories_folder_path):
    """Updates the HTML log file with CORRECT absolute paths for href links."""
    try:
        log_file_path = os.path.join(memories_folder_path, 'Memory_logs.html')

        if not os.path.exists(log_file_path):
            with open(log_file_path, 'w') as log_file:
                log_file.write("""
                   <!DOCTYPE html>
                   <html>
                   <head>
                       <title>Memory Logs</title>
                   </head>
                   <body>
                       <h1>Memory Logs</h1>
                       <ul>
                   """)

        html_insertion = f"""
               <li><h2>Memory Frame {memory_frame_number:05d} - {proposed_name} ({timestamp})</h2></li>
               <ul>
           """

        for memory_frame_path in memory_frame_paths:
            relative_path = os.path.relpath(memory_frame_path, memories_folder_path)
            href = sanitize_href(relative_path, memories_folder_path)
            html_insertion += f"""
                       <li><a href='{href}'>{os.path.basename(href)}</a></li> 
                   """

        html_insertion += "</ul>"

        with open(log_file_path, 'a') as log_file:
            log_file.write(html_insertion)

        print(f"{GREEN}HTML logs updated successfully.{RESET}")
    except Exception as e:
        print(f"Error updating HTML logs: {e}")

def Get_path_of_memories_folder():
    """Returns the absolute path to the 'memories' folder."""
    current = pathlib.Path.cwd()
    memories_path = current / "memories"
    return memories_path.absolute()

def process_user_input():
    user_input = input(f"{GREEN}Enter input: {RESET}")
    print(f"{MAGENTA}User input received: {user_input}{RESET}")
    return user_input

def call_interaction_model(user_input, timestamp):
    print(f"\n{CYAN}--- Calling Interaction Model ---{RESET}")
    try:
        interaction_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction='You follow orders and generate creative text interactions'
        )
        chat = interaction_model.start_chat(history=[])
        response = chat.send_message(f"currentTime: {timestamp} create {user_input}")
        print(f"AI Response: {response.text}")
        return response
    except Exception as e:
        print(f"Error in Interaction Model: {e}")
        return None

def call_memory_model(user_input, response1_text):
    print(f"\n{CYAN}---------------- Calling Memory Model ----------------{RESET}")
    try:
        memory_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction="""You are a sophisticated AI assistant helping to organize memories. 
            Analyze and summarize the above user-AI conversation, focusing on elements that would be most useful for storing and retrieving this memory later. Don't hallucinate. 
            Use the provided JSON schema for your response and fill in all fields with relevant information.
            You can omit entries if they don't seem appropriate for memory storage and would be empty.
            Never omit the "memory_folders_storage" entry.

            **JSON Schema:**

            ```json
            {
              "metadata": {
                "creation_date": "", 
                "source": "", 
                "author": "" 
              },
              "type": "conversation", // OR "technical_concept" 
              "core": {
                "main_topic": "", 
                "category": "", 
                "subcategory": "", 
                "memory_about": "" 
              },
              "summary": {
                "concise_summary": "", 
                "description": "" 
              },
              "content": {
                "keywords": [], 
                "entities": [], 
                "tags": [], 
                "observations": [], 
                "facts": [], 
                "contradictions": [], 
                "paradoxes": [], 
                "scientific_data": [], 
                "visualizations": [] 
              },
              "interaction": {
                "interaction_type": [], 
                "people": [], 
                "objects": [], 
                "animals": [], 
                "actions": [], 
                "observed_interactions": [] 
              },
              "impact": {
                "obtained_knowledge": "", 
                "positive_impact": "", 
                "negative_impact": "", 
                "expectations": "", 
                "strength_of_experience": "" 
              },
              "importance": {
                "reason": "", 
                "potential_uses": [], 
                "importance_level": "0-100" 
              },
              "technical_details": {
                "problem_solved": "", 
                "concept_definition": "", 
                "implementation_steps": [], 
                "tools_and_technologies": [], 
                "example_projects": [], 
                "best_practices": [], 
                "common_challenges": [], 
                "debugging_tips": [], 
                "related_concepts": [], 
                "resources": [], 
                "code_examples": [] 
              },
              "storage": {
                "storage_method": "", 
                "location": "", 
                "memory_folders_storage": [
                  {
                    "folder_path": "", 
                    "probability": 0  
                  }
                ],
                "strength_of_matching_memory_to_given_folder": [] 
              },
              "naming_suggestion": {
                "memory_frame_name": "Give  Same  meaning full name for  Memory File",
                "explanation": "" 
              }
            }
            ```
            Here  you have  existing  folder structure  for  memory_folders_storage [{
    "Actions & Results": {
        "Actions & Results": {
            "Future": {},
            "Past": {},
            "Present": {}
        }
    },
    "BaseFileStructure.txt": [],
    "Challenges & Setbacks": {
        "Areas for Improvement": {},
        "Difficult Emotions": {
            "Anger & Frustration": {},
            "Fear & Anxiety": {},
            "Jealousy & Envy": {},
            "Sadness & Grief": {},
            "Shame & Guilt": {},
            "Trauma & Abuse": {
                "Experiences": {},
                "Healing Journey": {},
                "Impact": {}
            }
        },
        "Failures & Disappointments": {
            "In Career": {},
            "In Personal Projects": {},
            "In Relationships": {}
        },
        "Negative Thought Patterns": {},
        "Significant Mistakes": {
            "Description": {},
            "How I Grew": {},
            "Lessons Learned": {}
        }
    },
    "CoreMemory": {
        "Conceptual Exploration": {
            "Contradictions & Dilemmas": {},
            "Paradoxes & Contradictions": {},
            "Unknowns & Mysteries": {}
        },
        "Core Experiences": {
            "Challenges Faced": {
                "External Challenges": {
                    "Obstacles": {
                        "How I Overcame Them": {},
                        "Types of Obstacles": {},
                        "What I Learned": {}
                    },
                    "Setbacks": {
                        "How I Recovered": {},
                        "Types of Setbacks": {},
                        "What I Learned": {}
                    }
                },
                "Internal Challenges": {
                    "Fear & Anxiety": {
                        "How I Coped": {},
                        "Specific Fears": {},
                        "What I Learned": {}
                    },
                    "Negative Thought Patterns": {
                        "Common Negative Thoughts": {},
                        "Strategies for Changing Them": {},
                        "What I Learned": {}
                    },
                    "Self-Doubt": {
                        "How I Overcame It": {},
                        "Sources of Self-Doubt": {},
                        "What I Learned": {}
                    }
                }
            },
            "Life-Changing Events": {
                "Negative": {},
                "Positive": {}
            },
            "Significant Moments": {
                "Other": {},
                "Personal": {},
                "Professional": {},
                "Travel": {}
            },
            "Triumphs & Accomplishments": {
                "Creative Wins": {
                    "Creative Works": {},
                    "Impact on Life": {},
                    "Recognition & Awards": {}
                },
                "Personal Achievements": {
                    "Goals Achieved": {},
                    "Impact on Life": {},
                    "Personal Growth": {}
                },
                "Professional Successes": {
                    "Career Growth": {},
                    "Impact on Life": {},
                    "Projects & Achievements": {}
                }
            },
            "Turning Points": {
                "In Career": {},
                "In Personal Growth": {},
                "In Relationships": {},
                "Other": {}
            }
        },
        "Goals & Visions": {
            "Life Vision": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            },
            "Personal Goals": {
                "Long-Term Goals": {},
                "Mid-Term Goals": {},
                "Short-Term Goals": {}
            }
        },
        "Knowledge Base": {
            "Areas of Expertise": {},
            "Key Concepts & Theories": {},
            "Personal Beliefs & Values": {}
        },
        "Reflections & Insights": {
            "Lessons Learned": {
                "From Mistakes": {},
                "From Relationships": {},
                "From Successes": {}
            },
            "Self-Discovery": {
                "Areas for Growth": {},
                "Strengths & Talents": {},
                "What I've Learned About Myself": {}
            }
        },
        "Relationships": {
            "Family": {
                "Extended Family": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Parents": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Siblings": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                }
            },
            "Friendships": {
                "Circles & Groups": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Shared Experiences": {}
                },
                "Close Friends": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Meaningful Interactions": {
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Unexpected Encounters": {}
                }
            },
            "Romantic Relationships": {
                "Partners": {
                    "Challenges Faced": {},
                    "Impact on My Life": {},
                    "Lessons Learned": {},
                    "Memorable Moments": {}
                },
                "Relationship Milestones": {
                    "First Date": {},
                    "First Kiss": {},
                    "Marriage": {},
                    "Moving In Together": {},
                    "Other Milestones": {}
                }
            }
        }
    },
    "Emotional Landscape": {
        "Dominant Emotions": {},
        "Emotional Triggers": {}
    },
    "Emotions & Reflections": {
        "Emotional Experiences": {
            "Dominant Emotions": {},
            "Emotional Triggers": {}
        },
        "Personal Growth & Insights": {
            "Lessons Learned": {},
            "Self-Discovery": {}
        }
    },
    "Goals & Aspirations": {
        "Life Vision": {
            "Aspirations": {},
            "Dreams": {},
            "Values & Beliefs": {}
        },
        "Personal Goals": {
            "Creative Pursuits": {},
            "Health & Wellbeing": {},
            "Other Personal Goals": {},
            "Personal Development": {},
            "Relationships": {}
        },
        "Professional Goals": {
            "Career Advancement": {},
            "Other Professional Goals": {},
            "Project Goals": {},
            "Skills & Expertise": {}
        }
    },
    "Knowledge & Learning": {
        "Formal Education": {
            "Degrees & Certifications": {},
            "Schools": {},
            "Significant Projects": {}
        },
        "Knowledge Base": {
            "Artistic Movements": {},
            "Cultural Insights": {},
            "Facts & Concepts": {},
            "Historical Events": {},
            "Philosophical Ideas": {},
            "Scientific Discoveries": {}
        },
        "Laws & Regulations": {
            "Legal Knowledge": {},
            "Personal Experiences with Laws": {},
            "Understanding of Legal Systems": {}
        },
        "Self-Directed Learning": {
            "Areas of Interest": {},
            "Learning Resources": {
                "Bookshelf": {},
                "Mentors & Teachers": {},
                "Online Courses": {}
            },
            "Skills Acquired": {}
        }
    },
    "Life Events & Transitions": {
        "Life Transitions": {
            "Health & Wellbeing": {
                "Habits & Routines": {},
                "Mental & Emotional Health": {},
                "Physical Health": {}
            },
            "Knowledge & Skills": {
                "Formal Education": {},
                "Self-Directed Learning": {},
                "Skills & Expertise": {}
            },
            "Personal Growth": {
                "Challenges Overcome": {},
                "Milestones": {},
                "Significant Decisions": {}
            },
            "Relationships": {
                "Family Dynamics": {},
                "Friendships": {},
                "Professional Connections": {},
                "Romantic Relationships": {}
            }
        },
        "Significant Events": {
            "Other": {},
            "Personal": {
                "Birthdays": {},
                "Graduations": {},
                "Other Personal Events": {},
                "Weddings": {}
            },
            "Professional": {
                "Job Changes": {},
                "Other Professional Events": {},
                "Project Completions": {},
                "Promotions": {}
            },
            "Travel": {
                "Moving Homes": {},
                "Other Travel Events": {},
                "Trips & Journeys": {}
            }
        }
    },
    "Planning & Progress": {
        "Plans & Strategies": {
            "Long-Term Plans": {},
            "Short-Term Plans": {},
            "Strategies Used": {
                "Goal Setting": {},
                "Other Strategies": {},
                "Problem Solving": {},
                "Time Management": {}
            }
        },
        "Progress & Outcomes": {
            "Goals Achieved": {},
            "Goals Not Achieved": {},
            "Lessons Learned from Progress": {},
            "Results of Actions": {
                "Negative Results": {},
                "Positive Results": {}
            }
        }
    }
}]
            **Memory Storage Suggestions:**
            Provide your suggestions for where this memory frame should be stored using the following format within the "memory_folders_storage" field:

            * **"folder_path":** The relative path for storing the memory frame (use '/' as the path separator).
            * **"probability":** The strength of probability (from 0 to 10) that the memory frame should be stored in the suggested folder. Use a scale from 0 (least likely) to 10 (most likely) to express your confidence. 
        """
        )
        chat = memory_model.start_chat(history=[])
        create_memory_prompt = f"User: {user_input}\nAI: {response1_text}"
        response = chat.send_message(create_memory_prompt)
        print(f"Memory Model Response:\n{response.text}")
        return response
    except Exception as e:
        print(f"Error in Memory Model: {e}")
        return None


def extract_entries_smart(response_message):
    print("\n--- Extracting Structured Entries ---")
    entries = []
    json_match = re.search(r"```json\n(.*?)\n```", response_message, re.DOTALL)
    if json_match:
        print("Found JSON data in the response.")
        try:
            json_data = json_match.group(1)
            print("Parsing JSON data...")
            response_data = json.loads(json_data)
            print("JSON data parsed successfully.")

            # Check if response_data is a list or a dictionary
            if isinstance(response_data, list):
                # Iterate through the list
                for entry in response_data:
                    entries.append(entry)
            elif isinstance(response_data, dict):
                # Append the single entry
                entries.append(response_data)
            else:
                print(f"Warning: Unexpected data type: {type(response_data)}")
                print("Skipping data.")

        except json.JSONDecodeError:
            print("Error: Invalid JSON in the AI response.")
        except Exception as e:
            print(f"Error extracting entry: {e}")
    return entries
def store_memory_frame(user_input, response1_text, response2_text, memory_data, SESION_INFO):
    """Stores a memory frame based on provided information and updates the HTML logs."""
    global MEMORY_FRAME_NUMBER, EDIT_NUMBER

    print(f"\n{YELLOW}--- Storing Memory Frame ---{RESET}")
    connection_map = {}
    memories_folder_path = Get_path_of_memories_folder()
    memory_frame_paths = []

    script_path = os.path.abspath(os.path.dirname(__file__))

    storage_folders = memory_data.get("storage", {}).get("memory_folders_storage", [])
    print(f"Suggested storage folders: {storage_folders}")

    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    proposed_name = memory_data.get("naming_suggestion", {}).get("memory_frame_name", "UnnamedMemory")
    importance_level = memory_data.get("importance", {}).get("importance_level", "UnknownImportance")

    for i, folder_info in  enumerate(storage_folders):
        if i<1:
            folder_path = folder_info.get("folder_path", "")
            probability = folder_info.get("probability", 0)
            print(f"Processing folder: {folder_path} (Probability: {probability})")

            if folder_path in connection_map:
                print(f"Folder '{folder_path}' found in connection map.")
                target_folder_path = connection_map[folder_path]
            else:
                print(f"Folder '{folder_path}' not in connection map. Creating in 'NewGeneratedbyAI'...")
                target_folder_path = os.path.join(script_path, "memories", "NewGeneratedbyAI", folder_path)
                os.makedirs(target_folder_path, exist_ok=True)


            if SESION_INFO is None:
                SESION_INFO="Unknown"
            # Construct the filename using the current folder's probability
            memory_frame_name = f"MemoryFrame__session_{SESION_INFO}___{timestamp}___Probability_{probability}___Importance_{importance_level}___{proposed_name}.json"
            memory_frame_path = os.path.join(target_folder_path, memory_frame_name)
            print(f"Memory frame name: {memory_frame_name}")
            print(f"Memory frame path: {memory_frame_path}")

            memory_frame_data = {
                "input": user_input,
                "response1": response1_text,
                "response2": response2_text,
                "memory_data": memory_data,
                "timestamp": timestamp,
                "edit_number": EDIT_NUMBER
            }

            try:
                with open(memory_frame_path, 'w') as file:
                    json.dump(memory_frame_data, file, indent=4)
                print(f"{YELLOW}Memory frame saved successfully at: {memory_frame_path}{RESET}")
                memory_frame_paths.append(memory_frame_path)
            except Exception as e:
                print(f"Error saving memory frame: {e}")

    update_html_logs(MEMORY_FRAME_NUMBER, proposed_name, timestamp, memory_frame_paths, memories_folder_path)
    MEMORY_FRAME_NUMBER += 1
    EDIT_NUMBER = 0


def CREATE_MEMORY_FRAME(conversationInput,SESION_INFO=None):
    global MEMORY_FRAME_NUMBER, EDIT_NUMBER
    MEMORY_FRAME_NUMBER = 1
    TIMESTAMP_FORMAT = '%Y-%m-%d_%H-%M'
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    EDIT_NUMBER = 0

    try:
        print("Calling memory model")
        MemorySumarisation = call_memory_model(user_input="", response1_text=conversationInput)
    except Exception as E:
        print("MemorySumarisation = call_memory_model(conversationInput)  error  from  CREATE_MEMORY_FRAME____")
        return

    try:
        print("Memory entries JSON formation")
        memory_entries = extract_entries_smart(MemorySumarisation.text)
    except Exception as E:
        print(E)
        return

    try:
        for entry in memory_entries:
            # Store the memory frame with dummy user input and response1 (as it's only conversationInput)
            store_memory_frame(user_input="None", response1_text=conversationInput, response2_text=MemorySumarisation.text, memory_data=entry, SESION_INFO=SESION_INFO)
    except Exception as E:
        print(E)

    print("-----------CREATE_MEMORY_FRAME FINISHED-----------------")


""""
conversationInput="i  am  a  big  dinosaur"

CREATE_MEMORY_FRAME(conversationInput)
"""

"""


while True:
    user_input = process_user_input()
    timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
    response1 = call_interaction_model(user_input, timestamp)
    if response1:
        response2 = call_memory_model(user_input, response1.text)
        if response2:
            memory_entries = extract_entries_smart(response2.text)
            for entry in memory_entries:
                store_memory_frame(user_input, response1.text, response2.text, entry)

"""

""


Subdirectory: SESIONS
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\SESIONS'


Subdirectory: Sesion_06-15-29
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\SESIONS\Sesion_06-15-29'

File: SomeMemoryScript______MemoryRetrival.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\SomeMemoryScript______MemoryRetrival.py)
Content (First 303 lines):
import json
import os
import torch
from transformers import BertTokenizer, BertModel
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from typing import List, Dict, Any, Optional, Tuple
import logging
import colorama
from colorama import Fore, Style
import re

# Initialize colorama
colorama.init(autoreset=True)

# Constants
MEMORY_FRAMES_DIR = './memories'
EMBEDDINGS_FILE = 'memory_embeddings.npz'
LOGGING_FILE = 'memory_retrieval.log'

# Emoji constants
INFO, SUCCESS, WARNING, ERROR = "ðŸ’¡", "âœ…", "âš ï¸", "âŒ"
LOADING, SEARCH, BRAIN, SAVE = "â³", "ðŸ”", "ðŸ§ ", "ðŸ’¾"

# Setup logging
logging.basicConfig(filename=LOGGING_FILE, level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Initialize BERT model and tokenizer
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertModel.from_pretrained('bert-base-uncased')


class NumpyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, np.ndarray):
            return obj.tolist()
        return super().default(obj)


def pretty_print(message: str, emoji: str = INFO):
    print(f"\n{emoji} {Fore.CYAN}{message}{Style.RESET_ALL}")


class MemoryFrame:
    def __init__(self, frame_data: Dict, frame_name: str, frame_path: str):
        self.frame_name = frame_name
        self.frame_path = frame_path
        self.input = frame_data.get('input', 'None')
        self.response1 = frame_data.get('response1', 'None')
        self.response2 = frame_data.get('response2', 'None')
        self.memory_data = frame_data.get('memory_data', {})
        self.timestamp = frame_data.get('timestamp', 'None')
        self.edit_number = frame_data.get('edit_number', 0)

    def get_embedding(self) -> np.ndarray:
        text = json.dumps(self.__dict__)
        return get_bert_embedding(text)


def get_bert_embedding(text: str) -> np.ndarray:
    try:
        inputs = tokenizer(text, return_tensors='pt', truncation=True, padding=True, max_length=512)
        with torch.no_grad():
            outputs = model(**inputs)
        return outputs.last_hidden_state.mean(dim=1).squeeze().numpy()
    except Exception as e:
        logging.error(f"Error generating embedding: {e}")
        return np.zeros(768)


def load_memory_frames(memory_frames_dir: str) -> List[MemoryFrame]:
    pretty_print(f"Loading Memory Frames from {memory_frames_dir}...", LOADING)
    memory_frames = []
    valid_frames = invalid_frames = 0

    for root, _, files in os.walk(memory_frames_dir):
        for file_name in files:
            if file_name.endswith('.json'):
                file_path = os.path.join(root, file_name)
                try:
                    with open(file_path, 'r') as file:
                        frame_data = json.load(file)
                        frame_name = file_name[:-5]
                        frame = MemoryFrame(frame_data, frame_name, file_path)
                        if not any(existing_frame.__dict__ == frame.__dict__ for existing_frame in memory_frames):
                            memory_frames.append(frame)
                            valid_frames += 1
                        else:
                            print(f"{WARNING} {Fore.YELLOW}Duplicate frame detected: {file_name}{Style.RESET_ALL}")
                except json.JSONDecodeError as e:
                    logging.error(f"Invalid JSON in '{file_path}': {e}")
                    invalid_frames += 1

    pretty_print(f"Loaded {valid_frames} Valid Memory Frames", SUCCESS)
    if invalid_frames > 0:
        pretty_print(f"Skipped {invalid_frames} Frames with JSON Decode Errors or Duplicates", WARNING)

    return memory_frames


def generate_memory_embeddings(memory_frames: List[MemoryFrame]) -> Dict[str, np.ndarray]:
    pretty_print("Generating Embeddings", BRAIN)
    embeddings = load_embeddings()

    for i, frame in enumerate(memory_frames):
        if frame.frame_name not in embeddings:
            embeddings[frame.frame_name] = frame.get_embedding()
            if (i + 1) % 10 == 0:
                pretty_print(f"Generated embeddings for {i + 1} frames...", LOADING)

    save_embeddings(embeddings)
    pretty_print("Embeddings Generation Complete", SUCCESS)
    return embeddings


def load_embeddings() -> Dict[str, np.ndarray]:
    if os.path.exists(EMBEDDINGS_FILE):
        try:
            return dict(np.load(EMBEDDINGS_FILE))
        except Exception as e:
            logging.warning(f"Error loading embeddings: {e}")
    return {}


def save_embeddings(embeddings: Dict[str, np.ndarray]) -> None:
    try:
        np.savez_compressed(EMBEDDINGS_FILE, **embeddings)
        pretty_print(f"Embeddings saved to {EMBEDDINGS_FILE}", SAVE)
    except Exception as e:
        logging.error(f"Error saving embeddings: {e}")


def retrieve_relevant_memory_frames(
        query: str,
        retrieval_method: str,
        filter_type: str,
        top_n: int,
        update_embeddings: bool,
        included_only_filled_areas: bool,
        memory_frames: List[MemoryFrame]
) -> Dict[str, Any]:
    try:
        query_embedding = get_bert_embedding(query)
        embeddings = load_embeddings()  # Load embeddings here as well

        similarities: List[Tuple[float, MemoryFrame]] = []
        updated_embeddings = False

        for frame in memory_frames:
            frame_embedding = get_frame_embedding(frame, embeddings, update_embeddings)
            if frame_embedding is not None:
                similarity = cosine_similarity([query_embedding], [frame_embedding])[0][0]
                similarities.append((similarity, frame))
                # Always update the embeddings dictionary if update_embeddings is True
                if update_embeddings:
                    embeddings[frame.frame_name] = frame_embedding
                    updated_embeddings = True

        if updated_embeddings:
            save_embeddings(embeddings)

        similarities.sort(key=lambda x: x[0], reverse=True)
        relevant_frames = similarities[:top_n]

        result_frames = [create_result_frame(sim, frame) for sim, frame in relevant_frames]

        return {
            'relevant_frames': result_frames,
            'error': None
        }
    except Exception as e:
        logging.error(f"Error in retrieve_relevant_memory_frames: {e}")
        return {
            'relevant_frames': [],
            'error': str(e)
        }


def get_frame_embedding(frame: MemoryFrame, embeddings: Dict[str, np.ndarray], update_embeddings: bool) -> Optional[
    np.ndarray]:
    # Always regenerate the embedding if update_embeddings is True
    if update_embeddings:
        return frame.get_embedding()
    elif frame.frame_name in embeddings:
        return embeddings[frame.frame_name]
    return None


def create_result_frame(similarity: float, frame: MemoryFrame) -> Dict[str, Any]:
    return {
        'similarity_score': similarity,
        'frame_name': frame.frame_name,
        'frame_path': frame.frame_path,
        'input': frame.input,
        'response1': frame.response1,
        'response2': frame.response2,
        'memory_data': frame.memory_data,
        'timestamp': frame.timestamp,
        'edit_number': frame.edit_number
    }


def filter_frame_data(frame: MemoryFrame, filter_options: Dict[str, Any]) -> Dict:
    filtered_frame = {}

    if filter_options.get('type') == 'all':
        filtered_frame = frame.__dict__
    elif filter_options.get('type') == 'summary':
        filtered_frame = {
            'input': frame.input,
            'response1': frame.response1,
            'response2': frame.response2,
            'memory_data': frame.memory_data,
            'timestamp': frame.timestamp,
            'edit_number': frame.edit_number
        }
    elif filter_options.get('type') == 'specific_fields':
        fields = filter_options.get('fields', [])
        filtered_frame = {k: v for k, v in frame.__dict__.items() if k in fields}
        if 'memory_data' in fields:
            filtered_frame['memory_data'] = frame.memory_data
    else:
        raise ValueError(f"Unknown filter_type: {filter_options.get('type')}")

    if filter_options.get('included_only_filled_areas', False):
        filtered_frame = {k: v for k, v in filtered_frame.items() if v}
        if 'memory_data' in filtered_frame:
            filtered_frame['memory_data'] = {k: v for k, v in filtered_frame['memory_data'].items() if v}

    nested_filter = filter_options.get('nested_filter')
    if nested_filter and 'memory_data' in filtered_frame:
        filtered_frame['memory_data'] = apply_nested_filter(filtered_frame['memory_data'], nested_filter)

    return filtered_frame


def apply_nested_filter(data: Dict, filter_options: Dict) -> Dict:
    filtered_data = {}

    if filter_options.get('type') == 'all':
        filtered_data = data
    elif filter_options.get('type') == 'specific_fields':
        fields = filter_options.get('fields', [])
        filtered_data = {k: v for k, v in data.items() if k in fields}
    elif filter_options.get('type') == 'regex':
        regex_pattern = filter_options.get('regex', '')
        filtered_data = {k: v for k, v in data.items() if re.match(regex_pattern, k)}
    else:
        raise ValueError(f"Unknown nested filter type: {filter_options.get('type')}")

    return filtered_data


def RETRIVE_RELEVANT_FRAMES(query: str) -> List[Dict[str, Any]]:
    pretty_print("Starting retrieval process...", SEARCH)
    memory_frames = load_memory_frames(MEMORY_FRAMES_DIR)
    # Generate embeddings for all frames
    embeddings = generate_memory_embeddings(memory_frames)

    # Check number of frames and embeddings
    num_frames = len(memory_frames)
    num_embeddings = len(embeddings)

    if num_frames > num_embeddings:
        # Add additional embeddings
        pretty_print(f"Adding embeddings for {num_frames - num_embeddings} new frames...", BRAIN)
        for frame in memory_frames:
            if frame.frame_name not in embeddings:
                embeddings[frame.frame_name] = frame.get_embedding()

        save_embeddings(embeddings)

    retrieved_frames = retrieve_relevant_memory_frames(
        query=query,
        retrieval_method='cosine_similarity',
        filter_type='summary',
        top_n=2,
        update_embeddings=True,  # Update embeddings during retrieval
        included_only_filled_areas=True,
        memory_frames=memory_frames
    )

    filter_options = {
        'type': 'specific_fields',
        'fields': ['memory_data'],
        'included_only_filled_areas': True,
        'nested_filter': {
            'type': 'specific_fields',
            'fields': ['type', 'summary', 'impact', 'importance', 'observations']
        }
    }

    frames_content = []
    for frame_data in retrieved_frames['relevant_frames']:
        frame = MemoryFrame(frame_data, frame_data.get('frame_name', 'Unknown'),
                            frame_data.get('frame_path', 'Unknown'))
        filtered_frame = filter_frame_data(frame, filter_options)
        print(json.dumps(filtered_frame, indent=2, cls=NumpyEncoder))
        frames_content.append(filtered_frame)

    pretty_print("Retrieval process completed", SUCCESS)
    return frames_content


Subdirectory: tools
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools'


Subdirectory: Cathegory_Os
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os'

File: ChangeOwnState.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\ChangeOwnState.py)
Content (First 135 lines):
import os
import json


def initializeState():
    # Get the directory where this script is located
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the full path to the JSON file (traversing 3 layers up)
    state_file_path = os.path.abspath(os.path.join(script_dir, '../../Brain_settings/State_of_mind.json'))
    print(f"ðŸ› ï¸ Initializing state at: {state_file_path}")

    # Ensure the Brain_settings directory exists
    state_dir = os.path.dirname(state_file_path)
    if not os.path.exists(state_dir):
        os.makedirs(state_dir)
        print("ðŸ“ Created directory for state file.")

    # Initialize state with default values
    state = {
        "FocusOn": "",
        "FocusLevel": "",
        "Defocus": "",
        "FrustrationLevel": "",
        "CurrentCostOfProgress": "0",
        "Short_term_goals": [],
        "Long_term_goals": [],
        "Accomplished": []
    }

    # Write initial state to file
    with open(state_file_path, "w") as file:
        json.dump(state, file, indent=4)

    print("ðŸ“ State initialized.")

initializeState()
def ChangeOwnState(FocusOn=None, FocusLevel=None, Defocus=None, FrustrationLevel=None, CurrentCostOfProgress=None,
                   Short_term_goals=None, Long_term_goals=None, Accomplished=None):
    print("\n****************  ENTERED ChangeOwnState *******************\n")
    print(
        f"ðŸ”§ Parameters: FocusOn: {FocusOn}, FocusLevel: {FocusLevel}, Defocus: {Defocus}, FrustrationLevel: {FrustrationLevel}, CurrentCostOfProgress: {CurrentCostOfProgress}, Short_term_goals: {Short_term_goals}, Long_term_goals: {Long_term_goals}, Accomplished: {Accomplished}")

    # Get the directory where this script is located
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # Construct the full path to the JSON file (traversing 3 layers up)
    state_file_path = os.path.abspath(os.path.join(script_dir, '../../Brain_settings/State_of_mind.json'))
    print(f"ðŸ“‚ State file path: {state_file_path}")

    # Initialize state file if it doesn't exist
    if not os.path.exists(state_file_path):
        print("âš ï¸ State file does not exist. Initializing state.")
        initializeState()

    # Load existing state
    with open(state_file_path, "r") as file:
        state = json.load(file)
    print(f"ðŸ“„ Current state: {json.dumps(state, indent=4)}")

    # Update state with provided values
    if FocusOn is not None:
        state["FocusOn"] = FocusOn
    if FocusLevel is not None:
        state["FocusLevel"] = FocusLevel
    if Defocus is not None:
        state["Defocus"] = Defocus
    if FrustrationLevel is not None:
        state["FrustrationLevel"] = FrustrationLevel
    if CurrentCostOfProgress is not None:
        state["CurrentCostOfProgress"] = CurrentCostOfProgress

    if Short_term_goals is not None:
        state["Short_term_goals"] = Short_term_goals
    if Long_term_goals is not None:
        state["Long_term_goals"] = Long_term_goals
    if Accomplished is not None:
        state["Accomplished"] = Accomplished

    # Save the updated state
    with open(state_file_path, "w") as file:
        json.dump(state, file, indent=4)

    print(f"ðŸ“„ Updated state: {json.dumps(state, indent=4)}")
    print("\n****************   FINISHED ChangeOwnState  *******************")
    result = "âœ… State_of_mind.json updated"
    return result


ChangeOwnState_description_json = {
    "function_declarations": [
        {
            "name": "ChangeOwnState",
            "description": "Updates the state of the model based on the provided parameters, which are used to adjust various aspects of its behavior: FocusOn, FocusLevel, Defocus, FrustrationLevel, CurrentCostOfProgress, Short_term_goals, Long_term_goals, Accomplished.",
            "parameters": {
                "type_": "OBJECT",
                "properties": {
                    "FocusOn": {
                        "type_": "STRING",
                        "description": "Specifies the area or topic to focus on."
                    },
                    "FocusLevel": {
                        "type_": "INTEGER",
                        "description": "Defines the intensity or level of focus."
                    },
                    "Defocus": {
                        "type_": "STRING",
                        "description": "Specifies the area or topic to defocus from."
                    },
                    "FrustrationLevel": {
                        "type_": "INTEGER",
                        "description": "Represents the current level of frustration."
                    },
                    "CurrentCostOfProgress": {
                        "type_": "INTEGER",
                        "description": "Indicates the current cost of progress in the task or activity."
                    },
                    "Short_term_goals": {
                        "type_": "ARRAY",
                        "description": "List of short-term goals."
                    },
                    "Long_term_goals": {
                        "type_": "ARRAY",
                        "description": "List of long-term goals."
                    },
                    "Accomplished": {
                        "type_": "ARRAY",
                        "description": "List of accomplished tasks."
                    }
                },
                "required": []
            }
        }
    ]
}

ChangeOwnState_description_short_str = "Updates the state in State_of_mind.json"

File: get_directory_structure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\get_directory_structure.py)
Content (First 106 lines):
import os


def get_directory_structure(directory=None, include_files=True, include_dirs=True, file_extension=None,
                            include_contents=False, specific_file=None, levels_up=0, verbose=False):
    if verbose:
        print("Entered get_directory_structure function with directory:", directory)

    # Set default directory
    if directory is None or directory == '/':
        directory = os.getcwd()
        if verbose:
            print(f"Directory is set to current working directory: {directory}")

    # Traverse up the directory hierarchy if levels_up is specified
    for _ in range(levels_up):
        directory = os.path.dirname(directory)
        if verbose:
            print(f"Traversed up one level, new directory: {directory}")

    # Safety check for the directory path
    if not os.path.exists(directory) or not os.path.isdir(directory):
        raise ValueError(f"The directory '{directory}' is not valid or does not exist.")

    directory_structure = {}

    def get_file_info(file_path):
        file_info = {
            'filename': os.path.basename(file_path),
            'size': os.path.getsize(file_path),
            'relative_path': os.path.relpath(file_path, directory),
            'full_path': file_path
        }
        if include_contents:
            try:
                with open(file_path, 'r') as file:
                    file_info['contents'] = file.read()
            except Exception as e:
                file_info['contents'] = f"Error reading file: {e}"
        return file_info

    if specific_file:
        if os.path.isfile(specific_file):
            if verbose:
                print(f"Getting details for specific file: {specific_file}")
            return get_file_info(specific_file)
        else:
            raise ValueError(f"The specified file '{specific_file}' does not exist.")

    for root, dirs, files in os.walk(directory):
        file_info = []
        if include_files:
            for file in files:
                if file_extension and not file.endswith(file_extension):
                    continue
                file_path = os.path.join(root, file)
                file_info.append(get_file_info(file_path))

        if include_dirs:
            directory_structure[os.path.relpath(root, directory)] = {
                'files': file_info,
                'folders': dirs
            }
        else:
            if file_info:
                directory_structure[os.path.relpath(root, directory)] = {
                    'files': file_info
                }

    if verbose:
        print("About to return the directory structure with", len(directory_structure), "folders.")

    return directory_structure


get_directory_structure_description_json = {
    'function_declarations': [
        {
            'name': 'get_directory_structure',
            'description': 'Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'directory': {'type_': 'STRING',
                                  'description': 'The path to the directory. Defaults to the current working directory if None or / is provided.'},
                    'include_files': {'type_': 'BOOLEAN',
                                      'description': 'Flag to include files in the output. Default is True.'},
                    'include_dirs': {'type_': 'BOOLEAN',
                                     'description': 'Flag to include directories in the output. Default is True.'},
                    'file_extension': {'type_': 'STRING',
                                       'description': 'Specific file extension to include. Default is None.'},
                    'include_contents': {'type_': 'BOOLEAN',
                                         'description': 'Flag to include the contents of files in the output. Default is False.'},
                    'specific_file': {'type_': 'STRING',
                                      'description': 'Path to a specific file to get its details. Default is None.'},
                    'levels_up': {'type_': 'INTEGER',
                                  'description': 'Number of levels to traverse up from the specified or current directory. Default is 0.'},
                    'verbose': {'type_': 'BOOLEAN', 'description': 'Flag for verbose logging. Default is False.'}
                },
                'required': ['directory']
            }
        }
    ]
}

get_directory_structure_description_short_str = "Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths. Includes options for filtering files, directories, file extensions, including file contents, and traversing up the directory hierarchy with a default to the current working directory."


File: RETRIVE_RELEVANT_FRAMES.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\RETRIVE_RELEVANT_FRAMES.py)
Content (First 37 lines):

import sys
from  SelAwareAI_Gemini.Gemini_SELF_AWARE.PROJECT_4 import  SomeMemoryScript______MemoryRetrival as M
def RETRIVE_RELEVANT_FRAMES(query):
   print(f"RETRIVE_RELEVANT_FRAMES entered query =  {query}")
   result= M.RETRIVE_RELEVANT_FRAMES(query)
   if result is not None:
        return  result
   else:
       result="__"
       return   result






RETRIVE_RELEVANT_FRAMES_description_json = {
  "function_declarations": [
    {
      "name": "RETRIVE_RELEVANT_FRAMES",
      "description": "Core function to retrieve relevant frames based on a query. It loads memory frames, computes embeddings if needed, performs the search, and returns the results with detailed information.",
      "parameters": {
        "type_": "OBJECT",
        "properties": {
          "query": {
            "type_": "STRING",
            "description": "The query string to search for memory."
          },
        },
      },
    },
  ]
}


RETRIVE_RELEVANT_FRAMES_description_short_str="Retrives Memory Frames "

File: save_to_file.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\save_to_file.py)
Content (First 49 lines):
import os
import json
from termcolor import colored  # Import the termcolor library

def save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None) -> dict:

    print(colored(f"Entering: save_to_file(...)", 'blue'))
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(colored(success_message, 'green'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(colored(error_message, 'red'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "failure", "message": error_message}


save_to_file_description_json = {
    'function_declarations': [
        {
            'name': 'save_to_file',
            'description': 'Saves content to a file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'content': {'type_': 'STRING'},
                    'file_name': {'type_': 'STRING', 'description': 'The name of the file. Defaults to "NoName".'},
                    'file_path': {'type_': 'STRING', 'description': 'The path to save the file. Defaults to the current working directory if not provided.'}
                },
                'required': ['content', 'file_name']
            }
        }
    ]
}

save_to_file_description_short_str="Saves content to a file"

File: summarize_files_contents.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\summarize_files_contents.py)
Content (First 40 lines):

import  os
import  json
def summarize_files_contents(file_paths):

    print("Entered summarize_files_contents function with", len(file_paths), "file paths.")
    summaries = []
    for file_path in file_paths:
        print("Processing file:", file_path)
        summary = {}
        try:
            with open(file_path, 'r') as file:
                content = file.read()
                summary['path'] = file_path
                summary['content'] = content
        except Exception as e:
            summary['path'] = file_path
            summary['error'] = str(e)
        summaries.append(summary)

    print("About to return the summaries for", len(summaries), "files.")
    return summaries

summarize_files_contents_description_json = {
    'function_declarations': [
        {
            'name': 'summarize_files_contents',
            'description': 'Opens and summarizes the content of multiple files.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'file_paths': {'type_': 'ARRAY', 'items': {'type_': 'STRING'}, 'description': 'A list of file paths.'}
                },
                'required': ['file_paths']
            }
        }
    ]
}

summarize_files_contents_description_short_str="Opens and summarizes the content of multiple files.'"


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__'

File: ChangeOwnState.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\ChangeOwnState.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\ChangeOwnState.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: get_directory_structure.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\get_directory_structure.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\get_directory_structure.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: RETRIVE_RELEVANT_FRAMES.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\RETRIVE_RELEVANT_FRAMES.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\RETRIVE_RELEVANT_FRAMES.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: save_to_file.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\save_to_file.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\save_to_file.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: summarize_files_contents.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\summarize_files_contents.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\Cathegory_Os\__pycache__\summarize_files_contents.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte


Subdirectory: OpenAI
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\tools\OpenAI'

File: Tool_Manager.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\Tool_Manager.py)
Content (First 216 lines):
import os
import importlib.util
import google.generativeai as genai
import json
from typing import Dict, Tuple

class ToolManager:
    def __init__(self, tools_directory="tools"):
        """Initializes the tool manager by loading tools from the specified directory."""
        print(f"\033[92mInitializing ToolManager with tools directory: {tools_directory}\033[0m")
        self.tools_directory = tools_directory
        self.tool_mapping = {}  # Map tool names to functions
        self.all_tools = []  # List of loaded tool descriptions (JSON)
        self.short_descriptions = {}  # Dictionary for short descriptions
        self.categories = {}  # Dictionary to store category information
        self._load_tools()  # Load tools upon initialization

    def _load_tools(self):
        """Scans the tools directory, loads tools, and populates tool_mapping."""
        print(f"\033[92mScanning tools directory: {self.tools_directory}\033[0m")
        tool_count = 1 # Initialize tool count

        for category in os.listdir(self.tools_directory):
            print(f"  \033[94m{tool_count}. Found category: {category}\033[0m")
            tool_count += 1 # Increment for category
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                self.categories[category] = {"tools": []}

                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        print(f"    \033[96m{tool_count}. - Found Python file: {filename}\033[0m")
                        tool_count += 1 # Increment for each tool file
                        tool_name = filename[:-3]
                        self._load_tool(category, tool_name)
                        self.categories[category]["tools"].append(tool_name)

    def _load_tools(self):
        """Scans the tools directory, loads tools, and populates tool_mapping."""
        print(f"\033[92mScanning tools directory: {self.tools_directory}\033[0m")

        for category in os.listdir(self.tools_directory):
            print(f"  \033[94mFound category: {category}\033[0m")
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                self.categories[category] = {"tools": []}

                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        print(f"    \033[96m- Found Python file: {filename}\033[0m")
                        tool_name = filename[:-3]
                        self._load_tool(category, tool_name)
                        self.categories[category]["tools"].append(tool_name)

    def _load_tool(self, category, tool_name):
        """Loads a single tool from a given category."""
        print(f"    \033[96m- Loading tool: {tool_name} from category: {category}\033[0m")
        module_name = f"{category}.{tool_name}"
        module_path = os.path.join(self.tools_directory, category, f"{tool_name}.py")

        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Assume tool function has the same name as the module
        tool_function = getattr(module, tool_name)

        # Get description
        description_name = f"{tool_name}_description_json"
        tool_description = getattr(module, description_name, None)

        # Get short description
        short_description_name = f"{tool_name}_description_short_str"
        short_description = getattr(module, short_description_name, None)

        if tool_function is not None:
            print(f"      \033[92m- Tool function '{tool_name}' loaded successfully\033[0m")
            self.tool_mapping[tool_name] = tool_function
            self.all_tools.append(tool_description)
            self.short_descriptions[tool_name] = short_description
        else:
            print(f"      \033[91m- Warning: Could not load tool function '{tool_name}' from '{module_path}'\033[0m")

    def get_tools_list_json(self):
        """Returns a list of JSON tool descriptions."""
        return self.all_tools

    def get_tools_structure(self):
        """Returns a dictionary representing the structure of the tools folder."""
        return {
            "categories": self.categories,
            "all_tools": self.all_tools,
            "tool_mapping": self.tool_mapping,
            "short_descriptions": self.short_descriptions
        }

    def print_tools_structure(self):
        """Prints the structure of the tools folder in a colorful and organized way."""

        tools_structure = self.get_tools_structure()

        print("\n\n\033[95m=========================================\033[0m")
        print(f"  \033[96mTool Manager Structure\033[0m")
        print("\033[95m=========================================\033[0m")

        print(f"\n\033[92mCategories:\033[0m")
        for category, info in tools_structure["categories"].items():
            print(f"  \033[94m- {category}:\033[0m")
            for tool_name in info["tools"]:
                print(f"    \033[96m- {tool_name}\033[0m")

        print(f"\n\n\033[92mTool Descriptions (JSON):\033[0m")
        for i, tool_json in enumerate(tools_structure["all_tools"]):
            print(f"  \033[93m{i+1}. {json.dumps(tool_json, indent=4)}\033[0m")

        print(f"\n\n\033[92mShort Tool Descriptions:\033[0m")
        for tool_name, short_description in tools_structure["short_descriptions"].items():
            print(f"  \033[96m- {tool_name}: {short_description}\033[0m")

        print(f"\n\n\033[95m=========================================\033[0m")

        return tools_structure


def ChooseToolByAI(user_prompt: str, tools_structure: Dict) -> str:
    """
    Analyzes the user's prompt using AI and chooses a tool based on keywords,
    ensuring the selected tool returns JSON descriptions.
    """
    for tool_name, tool_description in tools_structure["short_descriptions"].items():
        # Check if the tool returns JSON descriptions
        tool_json = next(
            (item for item in tools_structure["all_tools"] if item["name"] == tool_name), None
        )
        if tool_json and tool_json["return_type"] == "json":
            if any(
                keyword in user_prompt.lower() for keyword in tool_description.lower().split()
            ):
                return f"Call tool: {tool_name}"
    return "Call tool: none"

def extract_tool_and_arguments_from_ai_response(ai_response: str) -> Tuple[str, str]:
    """
    Extracts the tool name and arguments from the AI's response.
    """
    for line in ai_response.split("\n"):
        if line.startswith("Call tool: "):
            parts = line.split("Call tool: ", 1)
            tool_name = parts[1].strip()
            return tool_name, ''
    return None, None

def execute_selected_tool(tool_manager: ToolManager, tool_name: str, arguments: str = None) -> str:
    """
    Executes the selected tool and returns the result.
    """
    tool_function = tool_manager.tool_mapping.get(tool_name)
    if tool_function:
        try:
            result = tool_function(arguments)
            print(f"Tool '{tool_name}' executed successfully with result: {result}")
            return result
        except Exception as e:
            print(f"Error executing tool '{tool_name}': {e}")
    else:
        print(f"Tool '{tool_name}' not found.")
    return "Error: Tool not found or execution failed."

class AiToolSelector:
    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager
        self.model = self._initialize_model()

    def _initialize_model(self):
        """Initializes the generative AI model with the ToolSelector function."""
        tools_structure = self.tool_manager.get_tools_structure()
        tools = {
            "ToolSelector": {
                "description": "This tool analyzes user input and selects another tool from the available options, ensuring the selected tool returns JSON descriptions.",
                "function": ChooseToolByAI,
            }
        }

        model = genai.GenerativeModel(
            system_instruction="""You are a helpful AI assistant with access to a variety of tools.
            When you need to use a tool, state your request clearly in the following format:
            "Call tool: <tool_name>"

            For example, if you need to list files in a directory, you would say:
            "Call tool: list_files"

            Make sure to provide any necessary arguments or information for the tool.
            """,
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            tools=tools
        )
        return model

    def select_and_run_tool_from_ai(self, user_prompt: str) -> str:
        """
        Orchestrates the process of selecting and executing a tool using AI.
        """
        ai_response = self.model.start_chat(history=[]).send_message(user_prompt).text
        print(f"AI Response: {ai_response}")
        return self.execute_tool_from_ai_response(ai_response)

    def execute_tool_from_ai_response(self, ai_response: str) -> str:
        """
        Interprets the AI's response, extracts tool information, and executes the tool.
        """
        tool_name, arguments = extract_tool_and_arguments_from_ai_response(ai_response)
        if tool_name:
            return execute_selected_tool(self.tool_manager, tool_name, arguments)
        else:
            return "Error: No tool selected."


Subdirectory: __pycache__
## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__'

File: MEMORY______________frame_creation.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\MEMORY______________frame_creation.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\MEMORY______________frame_creation.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: SomeMemoryScript______MemoryRetrival.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\SomeMemoryScript______MemoryRetrival.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\SomeMemoryScript______MemoryRetrival.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

File: Tool_Manager.cpython-312.pyc (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\Tool_Manager.cpython-312.pyc)
Error decoding file 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\PROJECT_4\__pycache__\Tool_Manager.cpython-312.pyc': 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

