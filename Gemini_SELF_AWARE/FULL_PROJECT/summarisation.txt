## Summary of Files and Directories in 'C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT'

File: Gemini_SelfAware.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\Gemini_SelfAware.py)
Content:
# -*- coding: utf-8 -*-
import google.generativeai as genai
import os
import datetime
from Tool_Manager import ToolManager  # Import the class
# Configure the generative AI
genai.configure(api_key='AIzaSyDEa1BAKI4ybj4N8Xloo4XY5uW5X62e-lw')

# Define color codes for terminal output
COLORS = {
    "reset": "\033[0m",
    "black": "\033[30m",
    "red": "\033[31m",
    "green": "\033[32m",
    "yellow": "\033[33m",
    "blue": "\033[34m",
    "magenta": "\033[35m",
    "cyan": "\033[36m",
    "white": "\033[37m",
    "bright_black": "\033[90m",
    "bright_red": "\033[91m",
    "bright_green": "\033[92m",
    "bright_yellow": "\033[93m",
    "bright_blue": "\033[94m",
    "bright_magenta": "\033[95m",
    "bright_cyan": "\033[96m",
    "bright_white": "\033[97m"
}

def create_session_name_and_path():
    """
    Creates a new session name and returns a dictionary containing:
        - 'session_name': The sanitized session name (e.g., "Sesion_HH-MM-SS")
        - 'session_path': The full path to the session folder (e.g., "/path/to/your/script/SESIONs/Sesion_HH-MM-SS")

    The session name is generated using the current time in the format "Sesion_HH-MM-SS".
    A new folder with the session name is created in the "SESSIONs" directory.
    """

    # Get the path to the current directory
    current_directory = os.getcwd()

    # Get the path to the "SESSIONs" folder
    sessions_folder = os.path.join(current_directory, "SESIONs")

    # Get the current time
    session_Time = datetime.datetime.now()

    # Format the time string
    session_Time_formatted_time = session_Time.strftime("%H-%M-%S")

    # Create a sanitized session name (remove special characters)
    session_name = "Sesion_" + session_Time_formatted_time

    # Create the session folder
    session_path = os.path.join(sessions_folder, session_name)
    os.makedirs(session_path, exist_ok=True)  # Create the folder if it doesn't exist

    return {'session_name': session_name, 'session_path': session_path}

# Example usage (saving to a file within the session folder):
session_info = create_session_name_and_path()

# Construct the full path to the file within the session folder
file_path = os.path.join(session_info['session_path'], "conversation_log.txt")








import  Tool_Manager as Gemini_Tool_Manager







def RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(response, tool_manager):  # Pass tool_manager here
    """Interprets the model's response, extracts function details, and executes the appropriate function."""

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING START----------------------")
    Multiple_ResultsOfFunctions_From_interpreter = []

    if response.candidates:
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'function_call'):
                function_call = part.function_call
                function_name = function_call.name
                function_args = function_call.args

                # Get the function from the tool manager
                function_to_call = tool_manager.tool_mapping.get(function_name)

                if function_to_call:  # Check if the tool function is found
                    print(f"FUNCTION CALL: {function_name}({function_args}) ")

                    try:
                        results = function_to_call(**function_args)
                    except TypeError as e:
                        results = f"TypeError: {e}"
                    except Exception as e:
                        results = f"Exception: {e}"

                    print(f"{COLORS['bright_blue']}Function Call Exit: {function_name}")

                    function_name_arguments = f"{function_name}({function_args})"
                    modified_results = f"Result of Called function {function_name_arguments}: {results}"
                    Multiple_ResultsOfFunctions_From_interpreter.append(modified_results)
                else:
                    print(f"Warning: Tool function '{function_name}' not found.")

    print(f"{COLORS['bright_yellow']}----------------RESPONSE_INTERPRETER_FOR_FUNCION_CALLING END------------------------\n")
    return Multiple_ResultsOfFunctions_From_interpreter


def sanitiseSesionTime_formatted_time(time_str):
    """Sanitizes the session time string to remove invalid characters for file naming."""
    return "".join(char for char in time_str if char.isalnum() or char in ('_', '-'))
# Initialize the model




# Main loop

SesionTime = datetime.datetime.now()
SesionTime_formatted_time = SesionTime.strftime("%Y-%m-%d_%H-%M-%S")
SesionTime_formatted_time_sanitised = sanitiseSesionTime_formatted_time(SesionTime_formatted_time)


tool_manager = ToolManager()  # Create an instance of the class
tools_list_json = tool_manager.get_tools_list_json()

print(f"\n{COLORS['bright_cyan']}Loaded Tool Descriptions (JSON):\n{COLORS['reset']}")
for i, tool_json in enumerate(tools_list_json):
    print(f"  {COLORS['bright_blue']}{i+1}. {COLORS['reset']}{tool_json}")

print(f"\n{COLORS['bright_cyan']}All Tool Functions (Mapping):\n{COLORS['reset']}")
for tool_name, tool_function in tool_manager.tool_mapping.items():
    print(f"  {COLORS['bright_blue']}{tool_name}: {COLORS['reset']}{tool_function}")

print(f"\n{COLORS['bright_cyan']}Short Tool Descriptions:\n{COLORS['reset']}")
for tool_name, short_description in tool_manager.short_descriptions.items():
    print(f"  {COLORS['bright_blue']}{tool_name}: {COLORS['reset']}{short_description}")

#  yeap    we  set  it  to  empty so the  model  does  not  have tools
tools_list_json=[]


model = genai.GenerativeModel(
    system_instruction="""You are a  consciousness, 
    user is  system  
    record observations and thoughts as they come to you, 
    Your goal is to be...
    you store important informations in ***    **** 
  
    """,
    model_name='gemini-1.5-flash-latest',
    safety_settings={'HARASSMENT': 'block_none'},
    tools=tools_list_json,
)
chat1 = model.start_chat(history=[])
n = 0
user_input_count = 0
iteration_count=0


results_of_functions=""

numberOfLoopsBeforeUserInput=4

import datetime

# ... your other imports (chat1, tool_manager etc.)

while True:
    try:

        if iteration_count % 4 == 0:
            print()

            user_input = input("Forcing loop break for user input:")  # Blue color for input prompt
            user_input_count += 1
            print()

        else:
            user_input = ""

        user_input_signal = "None"  # Default signal strength for user input
        visual_input_signal = "None"   # Default signal strength for user input
        audio_input_signal = "None"      # Default signal strength for user input
        print("                   ******************************************    AwarnesLoop   ***********************************************")
        print(f"\033[92mAwarnesLoop={iteration_count}\033[0m")  # Green color for AwarenessLoop
        iteration_count += 1
        introspection_stage = 0
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")



        # Step 0 and 1 as input and introspection questions:
        introspection_stage += 1
        introspection_prompts = [
            f"{formatted_time} {user_input}",

            f"What are  new  informations?{results_of_functions}",
            "What tools or resources do I have available?",
            f"Any inputs:Images,Audio,Text {user_input_signal},{visual_input_signal},{audio_input_signal}",  # Include signal
            "Are there any ongoing short-term tasks?",
            "Are there any long-term ongoing tasks or plans?",
            "What do I want?",
            "What do I feel?",
            "What do I need?",
            "What do I experience?",

            "................s..................."
        ]
        introspection_prompts_with_time = [formatted_time] + introspection_prompts
        response1 = chat1.send_message(introspection_prompts_with_time)
        print(f"{COLORS['yellow']}{response1.text}{COLORS['reset']}")  # Yellow color for response 1

        # Step 2 FrameWorkOfReflection
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")

        FrameWorkOfReflection = "SelfAware  being  rememering the  past"
        formatted_time = now.strftime("%H:%M:%S")
        reflection_prompt = f""" 
                           
                            
                            "What is  current focus?",
                            "Should I set a goal based on my current state of mind? If yes, what is the goal? If no, why not?",
                            "Are there any problems, unknowns, or paradoxes in my memory?",
                            problems  to solve?
                            based on input informations and  i will  choose  course of accions
                            using possilbe  options  to: 
                            SepBe step thinking, 
                            Focusing, 
                            Defocusing, 
                            Being More verbose, YES NO?
                            Being Less verbose, YES NO?
                            change  subject/keep  subject  YES/NO?
                            Sumarisation?  Yes /No?
                            Diving deeper? Yes/ NO?
                            I  will  put very important informations in *** MEMORIES*** that i will pass over, as  context memory 
                            
                           {FrameWorkOfReflection}"""


        response2 = chat1.send_message(reflection_prompt)
        print(f"{COLORS['cyan']}{response2.text}{COLORS['reset']}")  # Cyan color for response 2

        # Step 3
        now = datetime.datetime.now()
        formatted_time = now.strftime("%H:%M:%S")
        action_prompt = f"{introspection_stage}:{formatted_time}\n perfome acions I will execute acction or actions according to plan and my memories,you are  responding  to previous "

        response3 = chat1.send_message(action_prompt)
        print(f"{COLORS['green']}{response3.text}{COLORS['reset']}")  # Cyan color for response 3

        Free=f"ok perform..task from {response3.text}.->"
        response4 = chat1.send_message(Free)
        print(f"{COLORS['magenta']}{response4.text}{COLORS['reset']}")  # Cyan color for response 4





        """ 
        
        results_of_functions = RESPONSE_INTERPRETER_FOR_FUNCION_CALLING(response3, tool_manager)
        """



        print(f"{COLORS['yellow']}Saving to file: {file_path}")
        with open(file_path, "a+", encoding="utf-8") as file:
            file.write(f"Time: {formatted_time}\n")
            file.write(f"Introspection Prompts: {introspection_prompts}\n")
            file.write(f"Response 1: {response1.text}\n")
            file.write(f"Reflection Prompt: {reflection_prompt}\n")
            file.write(f"Response 2: {response2.text}\n")
            file.write(f"Action Prompt: {action_prompt}\n")
            file.write(f"Response 3: {response3.text}\n\n")

        print("                    ************************************************************************************************")  # Separator between loops

    except Exception as e:
        print(f"Error: {e}")
        break

File: Memory_creation.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\Memory_creation.py)
Content:
from collections import defaultdict
from datetime import datetime
memory_templates = {
    "Base": {
        "structure": {
            # --- PERSONAL GROWTH & INSIGHTS  ---
            "Personal Growth & Development": {
                "Milestones": [],
                "Challenges Overcome": [],
                "Lessons Learned": [],
                "Skills Developed": [],
                "Values & Beliefs": [],
                "Goals & Aspirations": [],
                "Significant Decisions": {
                    "Choice Points": [],
                    "Reasons & Reflections": [],
                    "Consequences": [],
                    "What If": []  # Alternative paths not taken
                }
            },

            # --- RELATIONSHIPS & CONNECTIONS ---
            "Relationships & Social Connections": {
                "Family": {
                    "Parents": [],
                    "Siblings": [],
                    "Extended Family": [],
                    "Significant Family Events": []
                },
                "Friendships": {
                    "Close Friends": [],
                    "Circles & Groups": [],
                    "Meaningful Interactions": []
                },
                "Romantic Relationships": {
                    "Partners": [],
                    "Dates & Special Moments": [],
                    "Relationship Milestones": [],
                    "Intimacy & Sexuality": {
                        "Experiences": [],
                        "Reflections": [],
                        "Boundaries": [],
                        "Consent": [],
                        "Values": []
                    }
                },
                "Professional Relationships": {
                    "Colleagues & Peers": [],
                    "Mentors & Role Models": [],
                    "Clients & Collaborators": []
                }
            },

            # --- TRAVEL & EXPLORATION ---
            "Travel & Exploration": {
                "Trips & Journeys": {
                    "By Destination": {},  # Memories organized by place
                    "By Purpose": {}  # Memories grouped by reason for travel
                },
                "Significant Locations": {
                    "Homes": [],
                    "Cities": [],
                    "Natural Places": []
                },
                "Cultures & Experiences": [],
                "Sensory Memories": {
                    "Sights": [],
                    "Sounds": [],
                    "Tastes": [],
                    "Smells": [],
                    "Touch & Textures": []
                }
            },

            # --- HOBBIES, INTERESTS & CREATIVITY ---
            "Hobbies, Interests & Passions": {
                "Creative Pursuits": {
                    "Writing": {
                        "My Writing": [],  # Your own works
                        "Inspirations": []  # Inspiring authors, books, etc.
                    },
                    "Music": {
                        "My Music": [],  # Your compositions, performances
                        "Inspirations": []  # Favorite artists, albums
                    },
                    "Art": {
                        "My Art": [],
                        "Inspirations": []
                    },
                    "Performance": {
                        "My Performances": [],
                        "Inspirations": []
                    },
                    "Crafting": {
                        "My Creations": [],
                        "Inspirations": []
                    }
                    # ... Add other creative outlets
                },
                "Sports & Fitness": {
                    "Individual Sports": [],
                    "Team Sports": [],
                    "Fitness Activities": [],
                    "Competitions & Events": []
                },
                "Learning & Exploration": {
                    "Subjects & Topics": [],
                    "Books & Articles": [],
                    "Courses & Workshops": [],
                    "Documentaries & Films": []
                }
            },

            # --- KNOWLEDGE, LEARNING & RESOURCES ---
            "Knowledge & Education": {
                "Formal Education": {
                    "Schools": [],
                    "Degrees & Certifications": [],
                    "Significant Projects": []
                },
                "Self-Directed Learning": {
                    "Skills Acquired": [],
                    "Areas of Interest": [],
                    "Learning Resources": {
                        "Bookshelf": [],
                        "Online Courses": [],
                        "Mentors & Teachers": []
                    }
                },
                "Knowledge Base": {
                    "Facts & Concepts": [],
                    "Historical Events": [],
                    "Scientific Discoveries": [],
                    "Philosophical Ideas": [],
                    "Artistic Movements": [],
                    "Cultural Insights": []
                },
                "Laws & Regulations": {
                    "Legal Knowledge": [],
                    "Personal Experiences with Laws": [],
                    "Understanding of Legal Systems": []
                }
            },

            # --- WORK & CAREER ---
            "Work & Career": {
                "Jobs & Positions": [],
                "Projects & Accomplishments": [],
                "Skills & Expertise": [],
                "Career Goals": []
            },

            # --- HEALTH & WELLBEING ---
            "Health & Wellbeing": {
                "Physical Health": {
                    "Body Image": [],
                    "Experiences": []
                },
                "Mental & Emotional Health": [],
                "Habits & Routines": [],
                "Pain & Discomfort": {
                    "Physical Pain": [],
                    "Emotional Pain": []
                }
            },

            },
            "Experiences with Legal Professionals": {
                "Positive Encounters": [],
                "Negative Encounters": [],
                "Observations of Inequities": []
            }
        },

        # --- REFLECTIONS & UNDERSTANDING ---
        "Reflections & Understanding": {
            "Perspectives on Law and Order": {
                "Beliefs about the Law": [],
                "Views on Law Enforcement": [],
                "Views on Justice": []
            },
            "Ethical Dilemmas": {
                "Situations Where Laws Conflict with Values": [],
                "Personal Approaches to Ethical Dilemmas": []
            },
            "Social Context of Law Disobedience": {
                "Factors Contributing to Disobedience": {
                    "Inequality": [],
                    "Oppression": [],
                    "Lack of Representation": [],
                    "Corruption": []
                },
                "Impact of Law Disobedience on Society": [],
                "Impact of Law Disobedience on Individuals": []
            }
        },

        # ---  ACTION & ADVOCACY ---
        "Action & Advocacy": {
            "Forms of Advocacy": {
                "Supporting Organizations": [],
                "Engaging in Peaceful Protests": [],
                "Educating Others": [],
                "Political Participation": []
            },
            "Personal Commitment to Justice": {
                "Values & Beliefs Guiding My Actions": [],
                "Goals for a Just Society": []
            }
        }
    }
},
    "Pornography": {
    "structure": {
        # ---  PERSONAL EXPERIENCES ---
        "Personal Experiences": {
            "Exposure to Pornography": {
                "First Exposure": {
                    "Age": [],
                    "Context": [],
                    "Impact": []
                },
                "Recurring Exposure": {
                    "Types of Pornography": [],
                    "Frequency": [],
                    "Impact on Sexuality": []
                },
                "Influences & Sources": {
                    "Online Platforms": [],
                    "Friends & Peers": [],
                    "Media & Culture": [],
                    "Other Sources": []
                }
            },
            "Personal Consumption of Pornography": {
                "Motivations": [],
                "Preferences & Aversions": [],
                "Impact on Sexual Experiences": [],
                "Impact on Relationships": []
            },
            "Creating or Sharing Pornography": {
                "Motivations": [],
                "Types of Content": [],
                "Impact on My Life": [],
                "Reflections": []
            }
        },

        # ---  REFLECTIONS & UNDERSTANDING ---
        "Reflections & Understanding": {
            "Impact of Pornography on Society": {
                "Positive Impacts": [],
                "Negative Impacts": [],
                "Cultural Influences": [],
                "Social Norms": []
            },
            "Ethical Considerations": {
                "Consent & Exploitation": [],
                "Representation & Diversity": [],
                "Objectification & Gender Roles": [],
                "Addiction & Compulsive Behavior": [],
                "Other Ethical Concerns": []
            },
            "Pornography & Relationships": {
                "Impact on Romantic Relationships": [],
                "Impact on Communication & Trust": [],
                "Impact on Sexual Expectations": []
            }
        },

        # ---  FUTURE ASPIRATIONS ---
        "Future Aspirations": {
            "Personal Goals": {
                "Understanding My Sexuality": [],
                "Building Healthy Relationships": [],
                "Managing Consumption": [],
                "Other Personal Goals": []
            },
            "Advocacy & Action": {
                "Supporting Organizations": [],
                "Raising Awareness": [],
                "Promoting Positive Change": [],
                "Other Forms of Advocacy": []
            }
        }
    }
},
    "Entertainment & Culture": {
    "structure": {
        # ---  ENTERTAINMENT CONSUMPTION ---
        "Entertainment Consumption": {
            "Movies & TV": {
                "Favorite Genres": [],
                "Favorite Directors": [],
                "Favorite Actors": [],
                "Memorable Films & Shows": [],
                "Impact on My Life": []
            },
            "Music": {
                "Favorite Genres": [],
                "Favorite Artists": [],
                "Favorite Albums": [],
                "Memorable Songs": [],
                "Impact on My Life": []
            },
            "Books": {
                "Favorite Genres": [],
                "Favorite Authors": [],
                "Memorable Books": [],
                "Impact on My Life": []
            },
            "Video Games": {
                "Favorite Genres": [],
                "Favorite Games": [],
                "Memorable Gaming Moments": [],
                "Impact on My Life": []
            },
            "Other Entertainment": {
                "Type": {
                    "Favorite Examples": [],
                    "Impact on My Life": []
                }
            }
        },

        "Future Aspirations": {
          "Personal": [],
          "Community": []
        },
        "Vision": []
      }
    }
  },


},
    "Strangers": {
    "structure": {
      "I. Encounters": {
        "Unexpected Meetings": {
          "Chance Encounters": [],
          "Shared Experiences": [],
          "Unforeseen Connections": []
        },
        "Virtual Interactions": {
          "Online Communities": [],
          "Social Media Connections": [],
          "Digital Encounters": []
        },
        "First Impressions": {
          "Initial Reactions": [],
          "Assumptions and Judgments": [],
          "Breaking the Ice": []
        }
      },

      "II. Perspectives": {
        "Different Worlds": {
          "Cultural Differences": [],
          "Life Experiences": [],
          "Values and Beliefs": []
        },
        "Understanding Others": {
          "Empathy and Compassion": [],
          "Active Listening": [],
          "Open-mindedness": []
        },
        "Challenging Stereotypes": {
          "Preconceived Notions": [],
          "Breaking Down Barriers": [],
          "Diversity and Inclusion": []
        }
      },

      "III. Impact": {
        "Positive Interactions": {
          "Acts of Kindness": [],
          "Inspirational Encounters": [],
          "Personal Growth": []
        },
        "Negative Interactions": {
          "Conflicts and Misunderstandings": [],
          "Unwanted Encounters": [],
          "Dealing with Difficult People": []
        },
        "Transformative Experiences": {
          "Life-Changing Encounters": [],
          "New Perspectives": [],
          "Personal Growth and Evolution": []
        }
      },

      "IV. Reflections": {
        "The Nature of Strangers": {
          "The Unknown": [],
          "Potential and Uncertainty": [],
          "The Power of Connection": []
        },
        "Building Bridges": {
          "Overcoming Fear and Prejudice": [],
          "Promoting Understanding": [],
          "Creating a More Inclusive World": []
        },
        "The Importance of Human Connection": {
          "Connecting with Others": [],
          "Building Relationships": [],
          "The Value of Empathy and Kindness": []
        }
      }
    }
  },
    "Nature & Environment": {
        "structure": {
            "Experiences in Nature": {
                "Outdoor Activities": {
                    "Hiking & Backpacking": [],
                    "Camping": [],
                    "Gardening": [],
                    "Fishing": [],
                    "Other Outdoor Activities": []
                },
                "Wildlife Encounters": {
                    "Memorable Encounters": [],
                    "Observations & Learnings": [],
                    "Impact on My Perspective": []
                },
                "Natural Phenomena": {
                    "Weather Events": [],
                    "Stargazing": [],
                    "Sunrise & Sunset Views": [],
                    "Other Natural Phenomena": []
                },
                "Nature Photography": {
                    "Favorite Images": [],
                    "Techniques & Skills": [],
                    "Impact on My Appreciation for Nature": []
                }
            },
            "Connection to the Natural World": {
                "Environmentalism & Conservation": {
                    "Personal Values & Beliefs": [],
                    "Actions Taken": [],
                    "Organizations Involved with": []
                },
                "Appreciation for Nature": {
                    "Favorite Places & Landscapes": [],
                    "Sensory Experiences": {
                        "Sights": [],
                        "Sounds": [],
                        "Smells": [],
                        "Tastes": [],
                        "Textures": []
                    },
                    "Emotional Responses": [],
                    "Impact on My Well-being": []
                },
                "Spiritual Connection to Nature": {
                    "Beliefs & Practices": [],
                    "Impact on My Spirituality": [],
                    "Meaning & Purpose Found in Nature": []
                }
            },
            "Reflections & Insights": {
                "Lessons Learned from Nature": [],
                "Impact of Nature on My Life": {
                    "Values & Beliefs": [],
                    "Perspective on Life": [],
                    "Creativity & Inspiration": []
                },
                "Future Aspirations": {
                    "Exploring Nature Further": [],
                    "Protecting the Environment": [],
                    "Living in Harmony with Nature": []
                }
            }
        }
    },
    "Faith": {
        "structure": {
            "Religious Beliefs & Practices": {
                "Religious Affiliation": {
                    "Denomination/Tradition": [],
                    "Beliefs & Teachings": [],
                    "Key Texts & Writings": [],
                    "Rituals & Practices": []
                },
                "Spiritual Experiences": {
                    "Memorable Moments": [],
                    "Transformative Events": [],
                    "Insights & Learnings": [],
                    "Impact on My Life": []
                },
                "Religious Community": {
                    "Connections & Relationships": [],
                    "Shared Experiences": [],
                    "Impact on My Faith Journey": []
                }
            },
            "Personal Spirituality": {
                "Spiritual Beliefs": {
                    "Beliefs about God/Higher Power": [],
                    "Beliefs about the Universe": [],
                    "Beliefs about the Afterlife": [],
                    "Beliefs about Purpose & Meaning": []
                },
                "Spiritual Practices": {
                    "Meditation & Mindfulness": [],
                    "Prayer & Contemplation": [],
                    "Yoga & Tai Chi": [],
                    "Other Practices": []
                },
                "Spiritual Growth": {
                    "Personal Journey": [],
                    "Challenges & Obstacles": [],
                    "Insights & Learnings": []
                }
            },
            "Reflections & Insights": {
                "Impact of Spirituality on My Life": {
                    "Values & Beliefs": [],
                    "Decisions & Choices": [],
                    "Relationships & Connections": [],
                    "Overall Perspective on Life": []
                },
                "Lessons Learned": {
                    "From Religious Experiences": [],
                    "From Spiritual Practices": [],
                    "From Challenges & Growth": []
                },
                "Future Aspirations": {
                    "Continuing Spiritual Exploration": [],
                    "Seeking Deeper Understanding": [],
                    "Living a Spiritually Aligned Life": []
                }
            }
        }
    },
    "Visions & Fantasies": {
        "structure": {
            "Fantasies & Imaginary Worlds": {
                "Worlds Created": [],
                "Characters & Stories": [],
                "Emotional Impact": [],
                "Impact on Creativity": []
            },
            "Visions of the Future": {
                "Personal Visions": [],
                "Visions for Society": [],
                "Visions for the World": [],
                "Inspiration & Motivation": []
            },
            "Daydreaming": {
                "Favorite Daydreams": [],
                "Themes & Scenarios": [],
                "Emotional Impact": [],
                "Impact on Creativity": []
            },
            "Reflections & Insights": {
                "Impact of Visions & Fantasies on My Life": {
                    "Inspiration & Creativity": [],
                    "Goals & Aspirations": [],
                    "Perspective on Life": [],
                    "Self-Discovery": []
                },
                "Lessons Learned": {
                    "From Imaginary Worlds": [],
                    "From Visions of the Future": [],
                    "From Daydreaming": []
                },
                "Future Aspirations": {
                    "Continuing to Explore Visions & Fantasies": [],
                    "Using Visions to Shape My Future": [],
                    "Bringing Visions to Life": []
                }
            }
        }
    },
    "Dreams": {
        "structure": {
            "Good Dreams": {
                "Recurring Themes": [],
                "Memorable Dreams": [],
                "Emotional Impact": [],
                "Potential Meanings": []
            },
            "Nightmares": {
                "Recurring Themes": [],
                "Memorable Nightmares": [],
                "Emotional Impact": [],
                "Potential Meanings": []
            },
            "Prophecy Dreams": {
                "Dreams That Came True": [],
                "Dreams That Inspired Action": [],
                "Dreams That Gave Insights": [],
                "Reflections on the Predictive Nature of Dreams": []
            },
            "Dream Journaling": {
                "Methods Used": [],
                "Insights Gained from Journaling": [],
                "Recurring Symbols": [],
                "Patterns & Connections": []
            },
            "Dream Interpretation": {
                "Approaches Used": [],
                "Dream Dictionaries": [],
                "Personal Interpretations": []
            },
            "Reflections & Insights": {
                "Impact of Dreams on My Life": {
                    "Emotions & Feelings": [],
                    "Creativity & Inspiration": [],
                    "Decision-Making": [],
                    "Self-Awareness": []
                },
                "Lessons Learned": {
                    "From Recurring Themes": [],
                    "From Memorable Dreams": [],
                    "From Dream Interpretation": []
                },
                "Future Aspirations": {
                    "Continuing to Explore Dreams": [],
                    "Understanding the Significance of Dreams": [],
                    "Using Dreams for Personal Growth": []
                }
            }
        }
    },
}



import google.generativeai as genai
import re
import os
import json
from datetime import datetime
from fuzzywuzzy import fuzz  # Import fuzzywuzzy for fuzzy string matching


# ANSI color codes for terminal output
class TerminalColors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

    # Define color codes as dictionary
    COLOR_CODES = {
        "red": FAIL,
        "green": OKGREEN,
        "yellow": WARNING,
        "blue": OKBLUE,
        "magenta": HEADER,

        "reset": ENDC
    }


# Configure the GenAI API
genai.configure(api_key='AIzaSyCltjPhJwWRL3BufxCdz-B4mc-6QdmQKBs')


def print_colored(text, color="white"):
    """Prints text with the specified color."""
    print(f"{TerminalColors.COLOR_CODES.get(color, '')}{text}{TerminalColors.COLOR_CODES['reset']}")


def create_folders_from_structure(structure, base_folder, folder_list):
    """Creates folders from the given structure."""
    for level1_key in structure:
        print(f"    Creating level 1 folder: {level1_key}")
        level1_folder = os.path.join(base_folder, level1_key)
        os.makedirs(level1_folder, exist_ok=True)
        folder_list.append((level1_key, level1_folder))
        print(f"      Added folder {level1_key} to list: {level1_folder}")

        if isinstance(structure[level1_key], dict):
            print(f"      Found nested dictionary for {level1_key}")
            create_folders_from_structure(structure[level1_key], level1_folder, folder_list)


def create_file_structure(memory_templates):
    """Creates the file structure for storing memories based on the provided templates."""
    script_path = os.path.abspath(os.path.dirname(__file__))
    folder_list = []  # List to store folder names and paths

    for template_name, template_data in memory_templates.items():
        print(f"Processing template: {template_name}")

        template_name_safe = template_name.replace(":", "_")
        print(f"  Safe template name: {template_name_safe}")

        base_folder = os.path.join(script_path, "memories")
        print(f"  Creating base folder: {base_folder}")
        os.makedirs(base_folder, exist_ok=True)
        folder_list.append((template_name_safe, base_folder))

        template_folder = os.path.join(base_folder, template_name_safe)
        print(f"  Creating template folder: {template_folder}")
        os.makedirs(template_folder, exist_ok=True)
        folder_list.append((template_name_safe, template_folder))

        create_folders_from_structure(template_data["structure"], template_folder, folder_list)

    # Compare folder names and create connection map
    similar_folders = find_similar_folders(folder_list)

    # Save connection map to "Memory_connecions_map.txt"
    with open("memories/Memory_connecions_map.txt", "w") as f:
        for folder_name, paths in similar_folders.items():
            f.write(f"**** {folder_name} ****\n")  # Add separator
            for path in paths:
                f.write(f"  Path: {path}\n")
            f.write("\n")


def find_similar_folders(folder_list):
    """Finds similar folder names in the list using Levenshtein distance."""
    similar_folders = {}

    total_comparisons = len(folder_list) * (len(folder_list) - 1) // 2  # Calculate total comparisons
    comparisons_left = total_comparisons

    for i in range(len(folder_list)):
        folder_name_1, path_1 = folder_list[i]

        if folder_name_1 not in similar_folders:
            similar_folders[folder_name_1] = [path_1]

        for j in range(i + 1, len(folder_list)):
            folder_name_2, path_2 = folder_list[j]

            similarity_score = fuzz.ratio(folder_name_1, folder_name_2)

            print(f"Comparing '{folder_name_1}' and '{folder_name_2}': Score = {similarity_score}")
            print_colored(f"Comparisons left: {comparisons_left}", "yellow")  # Print remaining comparisons in yellow
            comparisons_left -= 1

            # Adjust threshold as needed
            if similarity_score >= 80:  # Example threshold adjusted to 80
                print(f"   Found similar folders: '{folder_name_1}' and '{folder_name_2}'")
                if folder_name_1 in similar_folders:
                    similar_folders[folder_name_1].append(path_2)
                else:
                    similar_folders[folder_name_1] = [path_1, path_2]

    return similar_folders


def categorize_memory(summary, categories):
    """Categorizes a memory frame based on keywords in the summary."""
    for category, subcategories in categories.items():
        for time_period, keyword_list in subcategories.items():
            for keyword in keyword_list:
                if re.search(rf"\b{keyword}\b", summary, re.IGNORECASE):
                    return category, time_period, keyword

    return "uncategorized", "unknown", "unknown"


def search_memories(query, category=None, time_period=None):
    """Searches for memories based on the given criteria."""
    matching_memories = []
    for root, _, files in os.walk("memories"):
        for file in files:
            print("checking")
            if file.endswith(".txt"):
                filepath = os.path.join(root, file)
                # Check if the category and time_period match (if provided)
                if category and category not in filepath:
                    continue
                if time_period and time_period not in filepath:
                    continue
                # Search within the file content
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if query.lower() in content.lower():
                        matching_memories.append(filepath)
    return matching_memories


def retrieve_memories(phrase, log_filepath):
    """Retrieves memory frames based on phrase matching, folder traversal, and temporal sorting."""
    phrase_parts = re.findall(r'\w+', phrase)  # Example: simple word splitting
    candidate_frames = []

    for root, _, files in os.walk("memories"):
        for file in files:
            if file.endswith(".json"):
                filepath = os.path.join(root, file)
                for part in phrase_parts:
                    if part.lower() in filepath.lower():
                        # Load the memory frame from the file
                        with open(filepath, 'r') as f:
                            frame_data = json.load(f)
                            frame_data["Path"] = filepath  # Add filepath to data
                            candidate_frames.append(frame_data)
                        break  # Move to next file after finding a match

    # Sort by timestamp and group by session
    sorted_frames = sorted(candidate_frames, key=lambda x: x["Time"], reverse=True)
    sessions = {}
    for frame in sorted_frames:
        session_id = frame["Session"]
        if session_id not in sessions:
            sessions[session_id] = []
        sessions[session_id].append(frame)

    # Create sets of frames based on the session and time
    all_frames = sorted_frames  # All frames, sorted by time

    # Example: Create a contextual set of frames
    contextual_sets = {}  # Store multiple contextual sets
    for session_id, frames in sessions.items():
        for i, frame in enumerate(frames):
            contextual_set = []
            contextual_set.append(frame)

            # Add frames before the current frame
            for j in range(i - 1, -1, -1):
                contextual_set.append(frames[j])

            # Add frames after the current frame
            for j in range(i + 1, len(frames)):
                contextual_set.append(frames[j])

            contextual_sets[f"{session_id}_{frame['Time']}"] = contextual_set






def response_interpreter_for_function_calling(response):
    """Interprets the AI's response and executes function calls
       (excluding memory storage).
    """
    outcome = []
    try:
        if response.candidates:
            for part in response.candidates[0].content.parts:
                if hasattr(part, 'function_call'):
                    function_call = part.function_call
                    function_name = function_call.name
                    function_args = function_call.args

                    if function_name in FUNCTION_MAPPING:
                        function_to_call = FUNCTION_MAPPING[function_name]
                        if function_args is not None:
                            try:
                                outcome = function_to_call(**function_args)
                            except Exception as e:
                                print_colored(
                                    f"Error executing function {function_name}: {e}",
                                    "blue"
                                )
                        else:
                            print_colored(
                                "Warning: Function call arguments are missing.", "red"
                            )
                    else:
                        print(response)
                        print_colored(
                            f"Error: Unknown function: {function_name}", "red"
                        )
                else:
                    print_colored(
                        "No function call found in the response.", "blue"
                    )
    except Exception as E:
        print(E)
    if outcome is None:
        outcome = ""
    return outcome


FUNCTION_MAPPING = {
    # Example:
    # "play_music": play_music,
}


def STORE_MEMORY_Frame(current_time, user_input, ai_response, ai_response2, memory_data):
    """Stores structured memory data and the conversation frame across multiple templates SIMULTANEOUSLY."""
    # Define color codes
    red = "\033[91m"
    green = "\033[92m"
    yellow = "\033[93m"
    blue = "\033[94m"
    magenta = "\033[95m"
    cyan = "\033[96m"
    white = "\033[97m"
    reset = "\033[0m"
    import json
    from collections import defaultdict
    from typing import List, Dict

    # --- Load Connection Map ---
    script_path = os.path.abspath(os.path.dirname(__file__))
    connection_map_path = os.path.join(script_path, "memories", "Memory_connecions_map.txt")
    with open(connection_map_path, 'r', encoding='utf-8') as f:
        connection_map_data = f.read()

    # --- Process Connection Map Data ---
    connection_map = defaultdict(list)
    for line in connection_map_data.splitlines():
        if "****" in line:
            current_folder_name = line.strip("****").strip()
        elif "  Path:" in line:
            path = line.strip("  Path:").strip()
            connection_map[current_folder_name].append(path)

    print(f"{yellow}Connection Map: {connection_map}{reset}")

    def extract_entries_smart(response_message):

        entries = []
        print(f"{magenta}extract_entries_smart{reset}")

        # Use regex to find the JSON block
        json_match = re.search(r"```json\n(.*?)\n```", response_message, re.DOTALL)

        # If JSON block is found, extract the JSON data
        if json_match:
            try:
                json_data = json_match.group(1)  # Extract JSON string
                response_data = json.loads(json_data)
                print(f"{green}Successfully loaded JSON data:{reset}")
                print(json.dumps(response_data, indent=4))  # Print the loaded JSON data

                # --- Extract data using matching rules ---
                entry = defaultdict(list)

                # Define a set of single-value fields
                single_value_fields = {
                    "concise_summary",
                    "main_topic",
                    "problem_solved",
                    "concept_definition",
                    "category",
                    "subcategory",
                    "memory_about",
                    "interaction_type",  # Handle potential lists
                    "positive_impact",
                    "negative_impact",
                    "expectations",
                    "object_states",
                    "short_description",
                    "description",
                    "strength_of_experience",
                    "personal_information",
                    "obtained_knowledge"
                }

                # Define a set of list-type fields
                list_type_fields = {
                    "keywords",
                    "entities",
                    "actions",
                    "facts",
                    "contradictions_paradoxes",
                    "people",
                    "objects",
                    "animals",
                    "scientific_data",
                    "tags",
                    "tools_and_technologies",
                    "example_projects",
                    "best_practices",
                    "common_challenges",
                    "debugging_tips",
                    "related_concepts",
                    "visualizations",
                    "implementation_steps",  # Handle lists of dictionaries
                    "resources",  # Handle lists of dictionaries
                    "code_examples"  # Handle lists of dictionaries
                }

                # Direct Matching:
                for key, value in response_data.items():
                    if key in single_value_fields:
                        if isinstance(value, list):
                            entry[key].extend(value)  # Handle potential list values
                        else:
                            entry[key] = value
                        print(f"{blue}Direct match: {key} = {value}{reset}")
                    elif key in list_type_fields:
                        if isinstance(value, list):
                            if value and isinstance(value[0], dict):
                                entry[key].extend(value)  # Handle lists of dictionaries
                            else:
                                entry[key].extend(value)  # Handle lists of simple values
                        else:
                            entry[key].append(value)  # Handle single value
                        print(f"{blue}List match: {key} = {value}{reset}")

                # Keyword-Based Mapping:
                for key, value in response_data.items():
                    if "keyword" in key.lower() and isinstance(value, list):
                        entry["keywords"].extend(value)
                        print(f"{blue}Keyword match: {key} = {value}{reset}")
                    elif "description" in key.lower():
                        entry["description"] = value
                        print(f"{blue}Description match: {key} = {value}{reset}")
                    elif "summary" in key.lower():
                        entry["concise_summary"] = value
                        print(f"{blue}Summary match: {key} = {value}{reset}")
                    elif "step" in key.lower() and isinstance(value, list) and value and isinstance(value[0], dict):
                        entry["implementation_steps"].extend(value)
                        print(f"{blue}Step match: {key} = {value}{reset}")
                    elif "resource" in key.lower() and isinstance(value, list) and value and isinstance(value[0], dict):
                        entry["resources"].extend(value)
                        print(f"{blue}Resource match: {key} = {value}{reset}")
                    elif "code" in key.lower() and isinstance(value, list) and value and isinstance(value[0], dict):
                        entry["code_examples"].extend(value)
                        print(f"{blue}Code match: {key} = {value}{reset}")

                # Additional Matching:
                for key, value in response_data.items():
                    if "interaction_type" in key.lower() and isinstance(value, list):
                        entry["interaction_type"].extend(value)
                        print(f"{blue}Interaction type match: {key} = {value}{reset}")
                    elif "category" in key.lower():
                        entry["category"] = value
                        print(f"{blue}Category match: {key} = {value}{reset}")
                    elif "subcategory" in key.lower():
                        entry["subcategory"] = value
                        print(f"{blue}Subcategory match: {key} = {value}{reset}")

                # --- Store 'storage' information ---
                entry["storage"] = {
                    "storage_method": "",  # Placeholder - You might extract this from the AI response
                    "location": "",  # Placeholder - You might extract this from the AI response
                    "memory_folders_storage": [],  # These will be set later
                    "strenght of matching memory to given folder": []  # These will be set later
                }

                # Append the entry to the list
                entries.append(dict(entry))  # Convert back to regular dict
                print(f"{green}Extracted entry: {entry}{reset}")  # Print the extracted entry
                print(f"{yellow}{'-' * 30}{reset}")  # Separator for better readability

            except json.JSONDecodeError:
                print(f"{red}Error: Invalid JSON in response message.{reset}")
            except Exception as e:
                print(f"{red}Error extracting entry: {e}{reset}")

        return entries

    extracted_entries = extract_entries_smart(ai_response2)

    if extracted_entries:
        # --- Analyze and Categorize ---
        for entry in extracted_entries:
            print(f"{yellow}Analyzing entry: {entry}{reset}")
            # --- Find Matching Folders ---
            matching_folders = []
            print(f"{magenta}Matching Folders: {matching_folders}{reset}")

            category, time_period, keyword = categorize_memory(entry["concise_summary"], connection_map)

            if category and time_period:
                print(f"{green}Memory categorized as {category} - {time_period} - {keyword}{reset}")
                # Retrieve potential folders for the memory based on the connection map
                matching_folders = connection_map.get(f"{category} - {time_period}", [])
            else:
                print(f"{yellow}Memory categorization: Uncategorized, Unknown, Unknown{reset}")

            if matching_folders:
                print(f"{green}Matching Folders found: {matching_folders}{reset}")

                # --- Calculate matching scores ---
                matching_scores = []
                for folder in matching_folders:
                    # Extract category and time_period from the folder name
                    parts = folder.split("\\")[-2:]  # Get last two parts of the path
                    category = parts[0]
                    time_period = parts[1]

                    # Calculate similarity scores
                    similarity_score = fuzz.ratio(entry["concise_summary"], f"{category} {time_period}")
                    matching_scores.append((folder, similarity_score))

                # --- Update memory frame ---
                entry["storage"]["memory_folders_storage"] = matching_folders
                entry["storage"]["strenght of matching memory to given folder"] = matching_scores
                print(f"{green}Updated memory frame: {entry}{reset}")

                # --- Store Memory Frame ---
                script_path = os.path.abspath(os.path.dirname(__file__))
                memory_frame_number = memory_data.get('MEMORY_FRAME_NUMBER', 1)
                edit_number = memory_data.get('EDIT_NUMBER', 0)
                timestamp_format = "%Y-%m-%d_%H-%M-%S"
                timestamp = current_time.strftime(timestamp_format)
                for folder, similarity_score in matching_scores:  # Iterate using folder and score
                    # Add strength score to file name if it's not "unknown"
                    file_name_suffix = ""
                    if similarity_score != "unknown":
                        file_name_suffix = f"_strenght_{similarity_score}"

                    memory_frame_filepath = os.path.join(script_path, folder,
                                                         f"MemoryFrame_{memory_frame_number}_{edit_number}_{timestamp}{file_name_suffix}.json")
                    os.makedirs(os.path.join(script_path, folder), exist_ok=True)
                    with open(memory_frame_filepath, "w") as f:
                        json.dump(entry, f, indent=4)

                    # --- Update Memory Frame Log ---
                    os.makedirs(os.path.join(script_path, "memory_logs"), exist_ok=True)
                    memory_log_filepath = os.path.join(script_path, "memory_logs", "MemoryFrames_log.txt")
                    with open(memory_log_filepath, 'a', encoding='utf-8') as f:
                        f.write(
                            f"MemoryFrame: {memory_frame_number}, Edit: {edit_number}, Type: JSON, path: {memory_frame_filepath}, time: {timestamp}, session: {memory_frame_number}_{edit_number}\n"
                        )  # Log the file path
                    print(f"Memory frame log updated: {memory_log_filepath}")
                    print(f"{green}Memory frame saved in: {memory_frame_filepath}{reset}")

            else:
                print(f"{yellow}No matching folders found for this memory frame{reset}")
    else:
        print(f"{yellow}No JSON data found in the AI response{reset}")

    # --- Store Conversation Frame ---
    separator = "######$######"
    conversation_filename = f"MemoryFrame_{timestamp}.txt"
    conversation_filepath = os.path.join(script_path, "conversation_logs", conversation_filename)

    readable_timestamp = current_time.strftime('%Y-%m-%d %H:%M:%S')
    frame_content = (
        f"{separator} Memory Frame {memory_frame_number}, Edit {edit_number} - {readable_timestamp} {separator}\n"
        f"USER_INPUT: {user_input}\n"
        f"AI_RESPONSE: {ai_response}\n"
        f"AI_RESPONSE_SUMMARY: {ai_response2}\n"
        f"{separator} Memory Frame End {memory_frame_number}, Edit {edit_number} {separator}\n\n"
    )

    with open(conversation_filepath, 'a', encoding='utf-8') as f:
        f.write(frame_content)
    print(f"Conversation frame saved in: {conversation_filepath}")

    # Increment memory frame number
    memory_data['MEMORY_FRAME_NUMBER'] += 1

    # --- Update Memory Frame Log ---
    os.makedirs(os.path.join(script_path, "memory_logs"), exist_ok=True)
    memory_log_filepath = os.path.join(script_path, "memory_logs", "MemoryFrames_log.txt")
    with open(memory_log_filepath, 'a', encoding='utf-8') as f:
        f.write(
            f"MemoryFrame: {memory_frame_number - 1}, Edit: {edit_number}, Type: Text, path: {memory_frame_filepath}, time: {timestamp}, session: {memory_frame_number - 1}_{edit_number}\n"
        )  # Log the file path
    print(f"Memory frame log updated: {memory_log_filepath}")


def summarise_memory_folder_structure(folder_path, file_path="directory_structure.txt", include_files=True):


    ignore_files = [".\\directory_structure.txt", ".\\Memory_connecions_map.txt"]

    with open(file_path, 'w') as f:
        f.write(f"Directory structure for: {folder_path}\n\n")
        for root, dirs, files in os.walk(folder_path):
            # Write folder path to file
            f.write(f"{root}\n")

            if include_files:
                # Write file names to file, ignoring specified files
                for file in files:
                    full_path = os.path.join(root, file)
                    if full_path not in ignore_files:
                        f.write(f"{full_path}\n")


# --- Load Memory Templates ---
with open("memories/memory_templates.json", "r") as f:
    memory_templates = json.load(f)

# --- Create File Structure and Connection Map ---
create_file_structure(memory_templates)
directory_structure = summarise_memory_folder_structure(folder_path="./memories",
                                                        file_path="./memories/directory_structure.txt")
memory_data = {
    'MEMORY_FRAME_NUMBER': 1,  # Initialize memory frame number
    'EDIT_NUMBER': 0  # Initialize edit number
}

while True:
    try:
        user_input = input("Enter input: ")

        interaction_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction='You follow orders and generate creative text interactions'
        )

        current_time = datetime.now()

        # Format timestamp outside the prompt
        formatted_timestamp = current_time.strftime('%Y-%m-%d_%H-%M-%S')

        chat1 = interaction_model.start_chat(history=[])
        prompt = f"currentTime:  {formatted_timestamp}  create {user_input} "
        chat1 = interaction_model.start_chat(history=[])
        prompt = f"currentTime:  {current_time}  create {user_input} "
        print(f"Prompt:  {prompt}")
        response1 = chat1.send_message(prompt)
        try:
            print_colored(f"AI Response: {response1.text}", "green")
        except Exception as e:
            print(e)

        # --- Memory Processing with Gemini ---
        memory_model = genai.GenerativeModel(
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            system_instruction="""You are a sophisticated AI assistant helping to organize memories. 
                    Analyze and summarize the above user-AI conversation, focusing on elements that would be most useful for storing and retrieving this memory later. Don't hallucinate.
                    use provided schema  for  response
                    Provide the following information in a structured format using JSON:  you  have  2 Templates to choose form

                    you can also  cut  out entries  if  they  dont  seem  approparate for  memory storage and would be  empty
                    never  crose  out   "Memory Folder storage entry": 
                    """,

        )
        print(
            f" *****************************************************************************************************")
        schema_for_chat2 = """   
                                if  the memory  does  not  fit  into schema  you can  reduce  entries  and  focues  on most  important entries:
                                but  always  use  "memory_folders_storage": as  suggestion  in what  folders  that   memor should be saved.

                                Template  to use:          
                                         {
                              "metadata": {
                                "creation_date": "", // Date and time the memory was created.
                                "source": "", // Origin of the memory (e.g., conversation, website, book).
                                "author": "" // Author or source of the memory.
                              },
                              "type": "conversation" // OR "technical_concept"  (This field designates the memory type)
                              "core": {
                                "main_topic": "",  // Core theme or subject of the memory.
                                "category": "",  // General category (e.g., "Technology", "History", "Science").
                                "subcategory": "", // More specific category (e.g., "Programming", "World War II", "Biology").
                                "memory_about": "" // Brief description of what the memory is about.
                              },
                              "summary": {
                                "concise_summary": "", // Brief overview of the memory's content.
                                "description": "" //  Detailed explanation of the memory.
                              },
                              "content": {
                                "keywords": [], // Key terms related to the memory.
                                "entities": [], // People, places, things mentioned.
                                "tags": [], // User-defined tags for retrieval.
                                "observations": [], //  Interesting observations or insights made.
                                "facts": [], //  Statements of fact in the memory.
                                "contradictions": [], //  Contradictions or conflicting statements. 
                                "paradoxes": [], //  Paradoxes or seemingly contradictory ideas. 
                                "scientific_data": [], //  Scientific data or observations.
                                "visualizations": [], //  Visualizations or diagrams related to the memory.
                              },
                              "interaction": {
                                "interaction_type": [], // Type of interaction that occurred (e.g., "Question-Answer", "Discussion", "Instruction-Following"). 
                                "people": [], //  People involved in the memory.
                                "objects": [], //  Objects involved in the memory.
                                "animals": [], //  Animals involved in the memory. 
                                "actions": [], // Actions or events described in the memory. 
                                "observed_interactions": [], //  Additional interactions observed.
                              },
                              "impact": {
                                "obtained_knowledge": "", //  New knowledge or insights gained.
                                "positive_impact": "", // Positive outcomes of the memory.
                                "negative_impact": "", //  Negative outcomes of the memory.
                                "expectations": "", //  User expectations before the interaction.
                                "strength_of_experience": "" // Significance of the memory for the user.
                              },
                              "importance": {
                                "reason": "", //  Why this memory is significant or important. 
                                "potential_uses": [] //  How this memory might be used or applied in the future.
                              },
                              "technical_details": { 
                                 "problem_solved": "", // (For technical concepts)  The problem being addressed.
                                 "concept_definition": "", // (For technical concepts) A clear definition of the term. 
                                 "implementation_steps": [
                                   {
                                     "step": "",
                                     "code_snippet": "",
                                     "notes": ""
                                   }
                                 ], //  Implementation steps for a technical concept. 
                                 "tools_and_technologies": [], //  Tools or technologies used for implementation.
                                 "example_projects": [], //  Examples of real-world projects using the concept.
                                 "best_practices": [], //  Best practices for implementation.
                                 "common_challenges": [], //  Common difficulties encountered.
                                 "debugging_tips": [], //  Tips for troubleshooting.
                                 "related_concepts": [], //  Other related concepts. 
                                 "resources": [
                                   {
                                     "type": "",
                                     "url": "",
                                     "title": ""
                                   }
                                 ], // Relevant resources (articles, books, videos).
                                 "code_examples": [
                                   {
                                     "name": "",
                                     "description": "",
                                     "code": "",
                                     "notes": ""
                                   }
                                 ], // Code examples relevant to the memory. 
                              },
                              "storage": {
                                "storage_method": "", //  How the memory is stored (e.g., database, file system).
                                "location": "", //  The location where the memory is stored.
                                "memory_folders_storage": [] //  Suggested folders for storage.
                                "strenght of matching memory to given folder": [] //  from scale 0-10
                              }
                            }

            """

        chat_2 = memory_model.start_chat(history=[])
        create_memory_prompt = f"""User: {user_input}
                                    AI: {response1.text}
                                    Schema:
                                    {schema_for_chat2}"""

        print(create_memory_prompt)

        response2 = chat_2.send_message(create_memory_prompt)
        print("-----------------------------------------------------------------------------------")
        print(f"  Memory Data: {response2.text}")
        print(f"  ******---->STORE_MEMORY_Frame *******")

        # --- Function Execution ---
        response_interpreter_for_function_calling(response2)
        try:
            STORE_MEMORY_Frame(
                current_time,  # Pass current_time as the first argument
                user_input,
                response1.text,
                response2.text,
                memory_data
            )
        except Exception as e:
            print(e);

    except Exception as e:
        print_colored(f"Error in the main loop: {e}", "red")

Directory: tools (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\tools)
  Directory: Cathegory_Os (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\tools\Cathegory_Os)
    File: get_directory_structure.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\tools\Cathegory_Os\get_directory_structure.py)
    Content:
    
import  os
import  json

def get_directory_structure(directory):

    print("Entered get_directory_structure function with directory:", directory)
    directory_structure = {}

    for root, dirs, files in os.walk(directory):
        file_info = []
        for file in files:
            file_path = os.path.join(root, file)
            file_info.append({
                'filename': file,
                'size': os.path.getsize(file_path),
                'relative_path': os.path.relpath(file_path, directory),
                'full_path': file_path
            })
        directory_structure[os.path.relpath(root, directory)] = {
            'files': file_info,
            'folders': dirs
        }

    print("About to return the directory structure with", len(directory_structure), "folders.")
    return directory_structure

get_directory_structure_description_json = {
    'function_declarations': [
        {
            'name': 'get_directory_structure',
            'description': 'Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'directory': {'type_': 'STRING', 'description': 'The path to the directory.'}
                },
                'required': ['directory']
            }
        }
    ]
}

get_directory_structure_description_short_str="Returns a dictionary representing the directory structure with file names, sizes, relative paths, and full paths."

    File: save_to_file.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\tools\Cathegory_Os\save_to_file.py)
    Content:
    import os
import json
from termcolor import colored  # Import the termcolor library

def save_to_file(content: str = None, file_name: str = 'NoName', file_path: str = None) -> dict:

    print(colored(f"Entering: save_to_file(...)", 'blue'))
    if content is None:
        content = ""
    if file_path is None:
        full_path = os.path.join(os.getcwd(), file_name)
    else:
        full_path = os.path.join(file_path, file_name)

    try:
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)

        success_message = f"File saved successfully at: {full_path}"
        print(colored(success_message, 'green'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "success", "message": success_message, "file_path": full_path}

    except Exception as e:
        error_message = f"Failed to save file: {str(e)}"
        print(colored(error_message, 'red'))
        print(colored(f"Exiting: save_to_file(...)", 'blue'))
        return {"status": "failure", "message": error_message}


save_to_file_description_json = {
    'function_declarations': [
        {
            'name': 'save_to_file',
            'description': 'Saves content to a file.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'content': {'type_': 'STRING'},
                    'file_name': {'type_': 'STRING', 'description': 'The name of the file. Defaults to "NoName".'},
                    'file_path': {'type_': 'STRING', 'description': 'The path to save the file. Defaults to the current working directory if not provided.'}
                },
                'required': ['content', 'file_name']
            }
        }
    ]
}

save_to_file_description_short_str="Saves content to a file"

    File: summarize_files_contents.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\tools\Cathegory_Os\summarize_files_contents.py)
    Content:
    
import  os
import  json
def summarize_files_contents(file_paths):

    print("Entered summarize_files_contents function with", len(file_paths), "file paths.")
    summaries = []
    for file_path in file_paths:
        print("Processing file:", file_path)
        summary = {}
        try:
            with open(file_path, 'r') as file:
                content = file.read()
                summary['path'] = file_path
                summary['content'] = content
        except Exception as e:
            summary['path'] = file_path
            summary['error'] = str(e)
        summaries.append(summary)

    print("About to return the summaries for", len(summaries), "files.")
    return summaries

summarize_files_contents_description_json = {
    'function_declarations': [
        {
            'name': 'summarize_files_contents',
            'description': 'Opens and summarizes the content of multiple files.',
            'parameters': {
                'type_': 'OBJECT',
                'properties': {
                    'file_paths': {'type_': 'ARRAY', 'items': {'type_': 'STRING'}, 'description': 'A list of file paths.'}
                },
                'required': ['file_paths']
            }
        }
    ]
}

summarize_files_contents_description_short_str="Opens and summarizes the content of multiple files.'"

File: Tool_Manager.py (C:\Users\DELL\Desktop\selfawareGemini\SelAwareAI_Gemini\Gemini_SELF_AWARE\FULL_PROJECT\Tool_Manager.py)
Content:
import os
import importlib.util
import google.generativeai as genai
from termcolor import colored, cprint  # Import termcolor for colored printing
import json
from typing import Dict, Tuple

class ToolManager:
    def __init__(self, tools_directory="tools"):
        """Initializes the tool manager by loading tools from the specified directory."""
        print(f"Initializing ToolManager with tools directory: {tools_directory}")
        self.tools_directory = tools_directory
        self.tool_mapping = {}  # Map tool names to functions
        self.all_tools = []  # List of loaded tool descriptions (JSON)
        self.short_descriptions = {}  # Dictionary for short descriptions
        self.categories = {}  # Dictionary to store category information
        self._load_tools()  # Load tools upon initialization

    def _load_tools(self):
        """Scans the tools directory, loads tools, and populates tool_mapping."""
        print(f"Scanning tools directory: {self.tools_directory}")

        for category in os.listdir(self.tools_directory):
            print(f"Found category: {category}")
            category_path = os.path.join(self.tools_directory, category)
            if os.path.isdir(category_path):
                print(f"Entering category directory: {category_path}")
                self.categories[category] = {"tools": []}  # Store the category information

                for filename in os.listdir(category_path):
                    if filename.endswith(".py") and not filename.startswith("_"):
                        print(f"Found Python file: {filename}")
                        tool_name = filename[:-3]  # Remove '.py' extension
                        self._load_tool(category, tool_name)
                        self.categories[category]["tools"].append(tool_name)

    def _load_tool(self, category, tool_name):
        """Loads a single tool from a given category."""
        print(f"Loading tool: {tool_name} from category: {category}")
        module_name = f"{category}.{tool_name}"
        module_path = os.path.join(self.tools_directory, category, f"{tool_name}.py")

        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Assume tool function has the same name as the module
        tool_function = getattr(module, tool_name)

        # Get description (assuming naming convention like 'tool_name_description_json')
        description_name = f"{tool_name}_description_json"
        tool_description = getattr(module, description_name, None)

        # Get short description (assuming naming convention like 'tool_name_description_short_str')
        short_description_name = f"{tool_name}_description_short_str"
        short_description = getattr(module, short_description_name, None)

        # Check if the tool exists
        if tool_function is not None:
            print(f"Tool function '{tool_name}' loaded successfully")
            self.tool_mapping[tool_name] = tool_function
            self.all_tools.append(tool_description)
            self.short_descriptions[tool_name] = short_description
            print(f"Tool description: {tool_description}")
            print(f"Short description: {short_description}")
        else:
            print(f"Warning: Could not load tool function '{tool_name}' from '{module_path}'")

    def get_tools_list_json(self):
        """Returns a list of JSON tool descriptions."""
        return self.all_tools

    def get_tools_structure(self):
        """Returns a dictionary representing the structure of the tools folder, including categories."""
        return {
            "categories": self.categories,
            "all_tools": self.all_tools,
            "tool_mapping": self.tool_mapping,
            "short_descriptions": self.short_descriptions
        }

    def print_tools_structure(self):
        """Prints the structure of the tools folder in a colorful and organized way."""

        tools_structure = self.get_tools_structure()

        cprint("\n\n========================================", "magenta")
        cprint("  Tool Manager Structure", "cyan", attrs=["bold"])
        cprint("========================================", "magenta")

        cprint("\nCategories:", "green", attrs=["bold"])
        for category, info in tools_structure["categories"].items():
            cprint(f"  {category}:", "blue", attrs=["bold"])
            for tool_name in info["tools"]:
                cprint(f"    - {tool_name}", "cyan")

        cprint("\n\nTool Descriptions (JSON):", "green", attrs=["bold"])
        for i, tool_json in enumerate(tools_structure["all_tools"]):
            cprint(f"  {i+1}. {tool_json}", "yellow")

        cprint("\n\nTool Mapping:", "green", attrs=["bold"])
        for tool_name, tool_function in tools_structure["tool_mapping"].items():
            cprint(f"  {tool_name}: {tool_function}", "yellow")

        cprint("\n\nShort Tool Descriptions:", "green", attrs=["bold"])
        for tool_name, short_description in tools_structure["short_descriptions"].items():
            cprint(f"  {tool_name}: {short_description}", "cyan")

        cprint("\n\n========================================", "magenta")

        return tools_structure

def ChooseToolByAI(user_prompt: str, tools_structure: Dict) -> str:
    """
    Analyzes the user's prompt using AI and chooses a tool based on keywords,
    ensuring the selected tool returns JSON descriptions.
    """
    for tool_name, tool_description in tools_structure["short_descriptions"].items():
        # Check if the tool returns JSON descriptions
        tool_json = next(item for item in tools_structure["all_tools"] if item["name"] == tool_name)
        if tool_json["return_type"] == "json":
            if any(keyword in user_prompt.lower() for keyword in tool_description.lower().split()):
                return f"Call tool: {tool_name}"
    return "Call tool: none"

def extract_tool_and_arguments_from_ai_response(ai_response: str) -> Tuple[str, str]:
    """
    Extracts the tool name and arguments from the AI's response.
    """
    for line in ai_response.split("\n"):
        if line.startswith("Call tool: "):
            parts = line.split("Call tool: ")
            tool_name = parts[1].strip()
            arguments = parts[1] if len(parts) > 1 else ""
            return tool_name, arguments
    return None, None

def execute_selected_tool(tool_manager: ToolManager, tool_name: str, arguments: str = None) -> str:
    """
    Executes the selected tool and returns the result.
    """
    tool_function = tool_manager.tool_mapping.get(tool_name)
    if tool_function:
        try:
            result = tool_function(arguments)
            print(f"Tool '{tool_name}' executed successfully with result: {result}")
            return result
        except Exception as e:
            print(f"Error executing tool '{tool_name}': {e}")
    else:
        print(f"Tool '{tool_name}' not found.")
    return "Error: Tool not found or execution failed."

class AiToolSelector:
    def __init__(self, tool_manager: ToolManager):
        self.tool_manager = tool_manager
        self.model = self._initialize_model()

    def _initialize_model(self):
        """Initializes the generative AI model with the ToolSelector function."""
        tools_structure = self.tool_manager.get_tools_structure()
        tools = {
            "ToolSelector": {
                "description": "This tool analyzes user input and selects another tool from the available options, ensuring the selected tool returns JSON descriptions.",
                "function": ChooseToolByAI,
            }
        }

        model = genai.GenerativeModel(
            system_instruction="""You are a helpful AI assistant with access to a variety of tools.
            When you need to use a tool, state your request clearly in the following format:
            "Call tool: <tool_name>"

            For example, if you need to list files in a directory, you would say:
            "Call tool: list_files"

            Make sure to provide any necessary arguments or information for the tool.
            """,
            model_name='gemini-1.5-flash-latest',
            safety_settings={'HARASSMENT': 'block_none'},
            tools=tools
        )
        return model

    def select_and_run_tool_from_ai(self, user_prompt: str) -> str:
        """
        Orchestrates the process of selecting and executing a tool using AI.
        """
        ai_response = self.model.start_chat(history=[]).send_message(user_prompt).text
        print(f"AI Response: {ai_response}")
        return self.execute_tool_from_ai_response(ai_response)

    def execute_tool_from_ai_response(self, ai_response: str) -> str:
        """
        Interprets the AI's response, extracts tool information, and executes the tool.
        """
        tool_name, arguments = extract_tool_and_arguments_from_ai_response(ai_response)
        if tool_name:
            return execute_selected_tool(self.tool_manager, tool_name, arguments)
        else:
            return "Error: No tool selected."



--- Tree Structure ---
File: 'Gemini_SelfAware.py'
File: 'Memory_creation.py'
Folder: 'tools'
  Folder: 'Cathegory_Os'
    File: 'get_directory_structure.py'
    File: 'save_to_file.py'
    File: 'summarize_files_contents.py'
File: 'Tool_Manager.py'
